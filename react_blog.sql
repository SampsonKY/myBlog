CREATE DATABASE  IF NOT EXISTS `react_blog` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `react_blog`;
-- MySQL dump 10.13  Distrib 8.0.19, for Win64 (x86_64)
--
-- Host: localhost    Database: react_blog
-- ------------------------------------------------------
-- Server version	8.0.19

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `admin_user`
--

DROP TABLE IF EXISTS `admin_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `admin_user` (
  `Id` int NOT NULL,
  `userName` varchar(45) DEFAULT NULL,
  `password` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `admin_user`
--

LOCK TABLES `admin_user` WRITE;
/*!40000 ALTER TABLE `admin_user` DISABLE KEYS */;
INSERT INTO `admin_user` VALUES (1,'sampson','123456');
/*!40000 ALTER TABLE `admin_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `Id` int NOT NULL AUTO_INCREMENT,
  `type_id` int NOT NULL DEFAULT '0',
  `title` varchar(255) NOT NULL DEFAULT '',
  `article_content` text NOT NULL,
  `introduce` text NOT NULL,
  `addTime` int NOT NULL DEFAULT '0',
  `view_count` int DEFAULT '0',
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,2,'Java程序设计','# Java 程序设计笔记\n\n**第一行代码HelloWorld**\n\n```java\npublic class Hello{\n    public static void main(String args[]){\n        System.out.println(\'Hello,World!\')\n    }\n}\n```\n\n\n\n## 标识符与简单数据类型\n\n**标识符**：用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列称为标识符。\n\n**关键字**：Java语言中已经被赋予一些特殊意义的单词。\n\n**简单数据类型**：\n\n* **逻辑类型**：boolean\n* **整型**：byte（1）、short（2）、int（4字节）、long（8）【一个字节为8位，比如int类型的取值范围为：-2^31^~2^31^-1】\n* **字符类型**：char(2字节，0~65535)\n* **浮点类型**：float、double\n* **精度**从低到高：byte、short、char、int、long、float、double；**高级别变量转为低级别需要强制转换**。\n\n**输入和输出**\n\n* **输入**\n\n  包括：nextBoolean()、nextByte()、nextShort()、nextInt()、nextLong()、nextFloat()、nextDouble()\n\n  示例：\n\n  ```java\n  import java.util.Scanner; //第一步\n  public class Example{\n      public static void main(String args[]){\n          People zhangSan = new People();\n          Scanner reader = new Scanner(System.in); //第二步\n          System.out.println(\'请输入年龄，回车确认\');\n          zhangSan.age = reader.nextInt();  //第三步\n          System.out.println(\'输入体重，回车确认\');\n          zhangSan.weight = reader.nextFloat();//第三步\n          zhangSan.speak();\n      }\n  }\n  ```\n\n  另外，Scanner对象可以调用hasNextXXX()方法判断用户输入的数据的类型。\n\n  在从键盘输入数据时，我们经常让render对象先调用 hasNextXXX() 方法等待用户在键盘输入数据，然后再调用 nextXXX() 方法读取数据。\n\n  比如：\n\n  ```java\n  while(reader.hasNextDoublbe){\n  	double x = reader.nextDouble();\n  }\n  ```\n\n* 输出\n\n  System.out.println(‘###’)、System.out.print(‘##’)、System.out.printf(‘%d’, var)\n\n## 运算符、表达式与语句\n\n### **运算符与表达式**\n\n* 算术运算符：+ - * / %\n* 自增自减：++x(x++)  –x (x–)\n* 关系运算符：> < >= <= == !=\n* 逻辑运算符：&& || ！\n* 赋值运算符： =\n* 位运算符：| & ！^\n* instanceof运算符：该运算符是二目运算符，左面的操作元是一个对象，右面是一个类。当左面的对象是右面的类或子类创建的对象时，该运算符的结果为true，否则为false。\n\n### **语句**\n\n* if语句、if-else 语句、if-else if-else语句\n\n* switch开关语句\n\n  ```java\n  switch(表达式) #表达式的值可以是byte，short、int或char\n  {\n      case 常量值1:\n          若干语句;\n          break;\n      case 常量值2:\n          ……\n      case 常量值N:\n          若干语句;\n          break;\n      default:\n          若干语句；\n  }\n  ```\n\n* while语句、do-while循环\n\n### **数组**\n\n* 一维数组：int[] arr = new int [30]，int arr[] = new int [] ，int arr[] = new int [size],  float arr[] = { 21.3f, 23.5f, 2.0f }  数组元素的类型可以是Java的任何一种类型。\n\n* 二维数组：`int b[][] = {{1},{1,2},{1,3,4}}`，可以直接用若干个一维数组初始化一个二维数组，这些一维数组的长度不尽相同。\n\n* `int b[][] =  new int b[3][4]; b.length = 3;`\n\n* 创建数组后，系统会给数组的每个元素一个默认的值，在声明数组的同时也可以给数组的元素一个初始值。\n\n* 数组属于**引用型变量**，因此两个相同类型的数组如果具有相同的引用，它们就有完全相同的元素。\n\n* 【注意】：char型数组必须让数组和字符串做并置运算才能输出其引用，否则输出其全部元素的值\n\n  ```java\n  int a [] = {1,2,3,4}\n  char b [] = {\'您\',\'好\',\'中\',\'国\'}\n  \n  System.out.println(a); //a的引用\n  System.out.println(b); //b的全部元素的值：您好中国\n  System.out.println(\"\"+b) //b的引用\n  ```\n\n* **遍历数组：**\n\n  ```java\n  int a[] = {1,2,3,4}\n  //基于循环语句的遍历\n  for(int ch: a){\n      ···\n  }\n  for(int i = 0; i < a.length; i++){\n  }\n  //使用toString()方法遍历\n  import java.util.Arrays;\n  System.out.println(Arrays.toString(a))\n  ```\n\n  \n\n## 类与对象\n\n>封装性：面向对象编程核心思想之一就是将数据和对数据的操作封装在一起。通过抽象，即从具体的实例中抽取共同的性质形成一般的概念，例如对类的概念。\n>\n>继承性：继承性体现了一种先进的编程模式。子类可以继承父类的属性和功能，即继承了父类具有的数据上的操作，同时又可以增添子类独有的数据和数据上的操作。\n>\n>多态性：①一种是操作名称的多态，即有多个操作具有相同的名字，但这些操作所接受的信息类型必须不同。所谓操作名称的多态是指可以向操作传递不同的消息，以便让对象根据相应的消息来产生一定的行为。②另一种多态是和继承有关的多态，是指同一个操作被不同类型对象调用时可能产生不同的行为。\n\n### 类\n\n类是Java语言中最重要的“数据类型”，类声明的变量被称为对象，即类是用来创建对象的“模版”。\n\n类是Java语言中最重要的“数据类型”，类声明的变量被称为对象，\n\n```java\nclass 类名{\n    类体的内容\n}\n\nclass A{\n    int a = 12;  //声明成员变量时可以同时赋予初值\n    /*\n    int b;   //非法\n    b=11;\n    */\n    void f(){\n        int a;\n        a = 33;\n        System.out.println(a); //33\n	}\n}\n```\n\n类体由两部分构成：\n\n* **变量的声明**： 用来描述数据（体现对象的属性）。成员变量的类型可以是Java中任何一种数据类型，包括基本类型：整型、浮点型、字符型；引用类型：数组、对象、接口。成员变量在整个类中都有效，其有效性与它在类体中书写的先后位置无关。\n\n* **方法**： 方法可以对类中声明的变量进行操作，即给出算法（体现对象具有的功能）。\n\n  * 方法的**声明**包括方法名和方法返回的类型。不需要返回数据时，返回的类型是void\n\n    ```java\n    double getSpeed() {\n        reutnr speed;\n    }\n    ```\n\n  * 在**方法体**中声明的变量和方法的参数被称为**局部变量**。和类的**成员变量**不同的是，局部变量只在声明它的方法内有效，而且与其声明的位置有关。方法的声明在整个方法内有效，方法内的局部变量从声明它的位置之后开始有效。\n\n  * 如果局部变量的名字和成员变量的名字相同，则成员变量被隐蔽。如果想在该方法中使用被隐蔽的成员变量，必须使用关键字 **this**\n  \n  * 局部变量定义后需要赋初值，成员变量有默认值。\n  \n* 类的UML图\n\n  * 第一层：名字层\n  * 第二层：变量层（属性层）\n  * 第三层：方法层（操作层）\n\n### 构造方法与对象的创建\n\n> 用类声明的变量被称为**对象**。与基本数据类型不同，在用类声明对象后，还必须要创建对象，即为声明的对象分配变量，当时用一个类创建一个对象时，也给出了这个类的一个实例。\n\n**构造方法**：构造方法是类中的一种特殊方法，当程序用类创建对象时需要使用它的方法。**类中的构造方法的名字必须与它所在的类的名字完全相同，而且没有类型**。允许一个类中编写若干个构造方法，但必须保证他们的参数不同，即参数的个数不同，或者是参数的类型不同。如果没有编写构造方法，系统会默认该类只有一个构造方法，该默认的构造方法是无参数的，且方法体中没有语句。如果类中定义了一个或多个构造方法，那么Java不提供默认的构造方法。\n\n**对象的创建**：比如有一个People 类，`People KY = new People();`\n\n**对象的内存模型**\n\n* `People KY;`, 声明变量对象后，变量对象的内存中还没有任何数据，称这时的对象是一个空对象，空对象不能使用，因为它还没有得到任何“实体”，必须再进行为对象分配变量的步骤，即为对象分配实体。\n  * `KY = new People()`,对象分配变量后，①首先系统会为类中的*成员变量*分配内存空间，然后执行*构造方法*中的语句。如果成员变量在声明时没有指定初值，使用的构造方法也没有对成员变量进行初始化操作，那么，会赋予这些成员变量默认初始值。②给出一个信息，确保这些成员变量是属于对象KY的，即这些内存单元将由对象KY操作管理。为了做到这一点，new运算符在为这些成员变量分配内存后，将返回一个引用给对象变量KY。所谓为对象分配内存就是指为它分配变量，并获得一个引用，以确保这些变量由它来“操作管理”。③一个类通过使用new运算符可以创建多个不同的对象，这些对象将被分配不同的内存空间，因此，改变一个对象的状态不会影响到其他对象的状态。\n\n**对象的使用**\n\n* 抽象的目的是产生类，而类的目的是*创建具有属性和功能的对象*。对象不仅可以操作自己的变量改变状态，而且能调用类中的方法产生一定的行为。\n\n* 对象创建之后，就有了自己的变量，即对象的实体。通过使用“.”，对象可以对自己的变量访问。\n* 类中的方法可以操作成员变量，当对象调用该方法时，方法中出现的成员变量就是指该对象的成员变量。\n\n**对象的引用和实体**\n\n分配给对象的变量习惯地称为实体\n\n* 没有实体的对象称为空对象，空对象不能使用。\n* 垃圾回收：Java具有所谓的“垃圾收集”机制，这种机制周期的检测某个实体是否已不再被任何对象引用，如果发现这样的实体，就释放实体占有的内存。\n\n### 参数传值\n\n> 方法中最重要的部分之一就是方法的参数，参数属于局部变量，当对象调用方法时，参数被分配内存空间，并要求调用者向参数传递值，即方法被调用时，参数变量必须有具体的值。\n\n* Java中所有的参数都是“**传值**”的，也就是说，方法中参数变量的值是指调用者指定值的**复制**。\n* 对于基本数据类型的参数，向该参数传递的值的级别不可高于该参数的级别。\n* 当参数是*引用类型*时，“传值”传递的是变量中存放的“**引用**”，而不是变量引用的实体。对于两个同类型的引用型变量，如果具有同样的引用，就会用同样的实体，因此，如果改变参数变量中存放的“引用”，就会导致原变量的实体发生同样的变化。\n\n### 实例成员与类成员\n\n**实例变量与类变量**\n\n> 类体中包括成员变量的声明和方法的定义，而成员变量又可细分为实例变量和类变量。在声明成员变量时，用**关键字static给予修饰的称为类变量**，也称为静态变量。\n\n* 分配给不同的对象的**实例变量**占有不同的内存空间，改变其中一个对象的实例变量不会影响其他对象的实例变量。\n* 如果类中有**类变量**，当使用new运算符创建多个不同的对象时，分配给这些对象的这个类变量**占有相同的一处内存**，改变其中一个对象的类变量会影响其他对象的这个类变量。也就是说对象共享类变量。\n* 类中的类变量在该类被加载到内存中时，就分配了相应的内存空间。\n* 类变量不仅可以通过某个对象访问，也*可以通过类名访问*。实例变量可以通过对象访问，不能使用类名访问。\n* 【注】：类变量似乎破坏了封装性，其实不然，当对象调用实例方法时，该方法中出现的类变量也是该对象的变量，只不过这个变量和所有的其他对象共享而已。\n\n**实例方法和类方法**\n\n> 方法声明时，方法类型前面不加static修饰的是实例方法。\n\n* 当类的字节码文件被加载到内存的时候，**类的实例方法**不会分配入口地址，只有该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类中创建的任何对象调用执行。\n* 【注】：当我们创建第一个对象时，类中的实例方法就分配了入口地址，再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地之才被取消。\n* 实例方法不仅可以操作实例变量，也可以操作类变量。\n* 对于类中的类方法，在该类加载到内存时，就分配了相应的入口地址。类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。\n* 实例方法不可以通过类名调用，而类方法可以。\n* **类方法不可以操作实例变量**，因为在类创建对象之前，实例成员变量还没有分配内存。\n* 如果一个方法不需要操作实例成员变量就可以实现某种功能，就可以考虑将这样的方法声明为类方法。这样可以避免创建对象浪费内存。\n\n### 方法的重载和多态\n\n> Java中存在两种多态：重载（overload）和重写（override）。\n\n* 所谓功能多态性是指可以向功能传递不同的信息，以便让对象根据相应的消息来产生相应的行为。对象的功能通过类中的方法来体现，那么功能的多态性就是方法的**重载**。\n* 方法的**重载**意思是**一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。**\n* 【注】：方法的返回类型和参数的名字不参与比较，也就是说如果两个方法的名字相同，即使类型不同，也必须保证参数不同。\n\n### this关键字\n\n> this 是Java的一个关键字，表示某个对象。this可以出现在实例方法和构造方法中，但不可以出现在类方法中。\n\n* this关键字出现在类的构造方法中时，代表使用该构造方法创建的对象。\n* 实例方法必须只能通过对象来调用，不能用类名来调用。当this关键字出现在实例方法中时，代表正在调用该方法的当前对象。\n* 实例成员变量在实例方法中出现时：this.成员变量；\n* static成员变量在实例方法中出现时：类名.成员变量。\n* 通常可以省略 this. 和 类名. ；但当实例成员变量的名字和局部变量名字相同时，不可省略。\n* 类的实例方法可以调用类的其他方法，对于实例方法调用的默认格式：this.方法 （this.可省略）\n* 【注】：this 不能出现在类方法中，因为，类方法可以通过类名直接调用，这是，可能还没有任何对象诞生。\n\n### 包\n\n> 包是 Java 语言中有效地管理类的一个机制。不同 Java 源文件中可能出现名字相同的类如果想区分这些类，就需要使用包名。\n\n* 语法： package 包名;\n* 如果一个类有包名，那么就不能在任意位置存放它，否则虚拟机将无法家在这样的类。\n* 比如使用： package tom.jiafei； 那么存储文件的目录结构必须包含有这样的结构：…\\tom\\jiafei；\n* 如果源程序省略了包名，源文件中所定义命名的类被隐含认为是无名包的一部分，只要这些类的字节码被存放在相同的目录中，那么它们就属于同一个包。\n\n### 访问权限\n\n访问限制修饰符有 private、protected、public，都是Java的关键字。\n\n【注】：在编写类的时候，类中的实例方法总是可以操作该类中的实例变量和类变 量；类中的类方法总是可以操作该类中的类变量，与访问限制符没有关系。\n\n* 用关键字 **private** 修饰的成员变量和方法称为私有变量和私有方法。在另一个类中用某个类创建了一个对象后，该对象不能访问自己的私有变量和私有方法。如果类中某个成员是私有类变量（方法），那么在另外一个类中，也不能通过类名来操作（调用）这个私有类变量（方法）。\n* 用关键字 **public** 随时的成员变量和方法称为共有变量和共有方法。\n* 不用 public、protected、private 修饰符的成员变量和方法被称为 **友好变量**和**友好方法**；同一个包能访问。\n* 用 **protected** 修饰的成员变量和方法被称为受保护的成员变量和受保护的方法，同一个包能访问。子类可访问。\n* 不能用protected、private修饰类，可以用public修饰（public类），或不加public（友好类）。\n* 访问限制符按访问权限从高到低排列顺序：public、protected、友好的、private。\n\n### 基本类型的类包装\n\n> Java 提供了基本数据类型相关的类，实现了对基本数据类型的封装。这些类在 java.lang 包中，分别是：Byte,Interger, Short, Long, Float, Double,Character类。\n\n下述构造方法分别可以创建Double、Float、Byte、Integer、Short、Long 类型的对象。\n\n- Double(double num);\n\n- Float(Float num)\n\n- Short(short num)\n\n- Byte(byte num)\n\n- …\n\n\n使用xxxValue()方法可以返回该对象含有的xxx型数据。\n\n### 可变参数\n\n- 可变参数是指在声明方法时不给出参数列表中从某项直至最后一项参数的名字和个数，但这些参数的类型必须相同。\n- 可变参数使用“···”表示若干个参数，这些参数的类型必须相同，最后一个参数必须是参数列表中的最后一个参数。\n- 例如：\n\n```java\npublic void f(int ···x)\n```\n\n\n\n## 子类与继承\n\n> 继承是一种已有的类创建新类的机制\n\n### 子类与父类\n\n* 由继承得到的类称为**子类**，被继承的类称为**父类（超类）**。\n\n* 利用继承可以先创建一个共有属性的一般类，根据该类再创建具有特殊属性的新类，新类继承一般类的状态和行为，并根据需要增加自己的新的状态和行为。\n\n* 格式：\n\n  ```java\n  class 子类名 extends 父类名{\n      ···\n  }\n  ```\n\n* 如果一个类中没有使用extends关键字，这个类被系统默认是 **Object 的子类**，Object是java.lang 包中的类。\n\n### 子类的继承\n\n> 一个子类继承的成员应当是这个类的完全意义的成员。\n\n* 如果子类和父类在同一个包中，那么子类自然的继承了父类中不是private的成员变量和方法作为自己的成员变量和方法，继承的成员或方法的访问权限保持不变。\n* 当子类和父类不在同一个包中时，父类中的private和友好访问权限的成员变量不会被子类继承。\n\n### 成员变量的隐藏和重写\n\n* 如果声明的成员的变量的名字和从父类继承来的成员变量**名字相同**（声明的类型可以不同），在这种情况下，子类就会隐藏掉继承的成员变量。【注意】：子类对象仍然可以调用从父类继承的方法操作隐藏的成员变量。\n* 子类通过**重写**可以隐藏已继承的实例方法（方法重写也称方法覆盖）。\n* **方法的重写**是指：子类中定义一个方法，这个方法的类型和父类的方法的类型一致或者是父类的方法的类型的子类型（所谓子类型是指：如果父类的方法的类型是“类”，那么允许子类的重写方法的类型是“子类”）一致，并且这个**方法的名字**、**参数个数**、**参数类型**和父类的方法完全相同。子类如此定义的方法称为子类重写的方法(不属于新增的方法)。\n* 重写方法既可以操作继承的成员变量、调用继承的方法，也可以操作子类新声明的成员变量、调用新定义的其他方法，但无法操作被子类隐藏的成员变量和方法。如果子类想使用被隐藏的成员变量或方法，**必须使用super关键字**。\n* 重写父类的方法时，不可以降低方法的访问权限，但可以提高。\n\n### super 关键字\n\n> 子类一旦隐藏了继承的成员变量和方法，那么子类创建的对象就不再拥有该变量和方法，该变量和方法归关键字super拥有。\n>\n> 子类的构造函数 super()；\n>\n> 子类的其他函数中使用 super().Member super\n\n* 如果在子类中想使用被子类隐藏的成员变量或方法就需要使用关键字super。\n* 当用**子类的构造方法**创建一个子类对象时，子类的构造方法总是先调用父类的某个构造方法。（如果子类没有显示指出使用父类那个构造方法，子类就调用父类不带参数的构造方法）。\n* 由于**子类不继承父类的构造方法**，所以，**子类在其构造方法中需要使用 super 关键字来调用父类的构造方法**，而且super必须是子类构造方法的头一条语句。如果没有明显写出，默认有 `super();`\n* 在父类中定义多个构造方法时，应当包括一个不带参数的构造方法。\n\n### final 关键字\n\n> final 关键字可以修饰类、成员变量和方法中的局部变量。\n\n* 可以使用 final 将类声明为final 类。final 类不能被继承，即不能有子类。比如Java提供的 String 类。\n* 如果final修饰父类中的一个方法，那么这个方法不允许子类重写。子类可以访问。\n* 如果成员变量或局部变量被修饰为 final 的，就是常量。声明常量时必须指定该常量的值。\n\n### 对象的上转型对象\n\n假设，A 类是 B 类的父类，当用子类创建一个对象，并把这个对象的引用放到父类的对象中时，例如\n\n```java\nA a;\na = new B();\n//或者\nA a;\nB b = new B();\na = b;\n```\n\n这时，称对象 a 是对象 b 的上转型对象。\n\n* 对象的上转型对象的实体是子类负责创建的，但**上转型对象会失去原有对象的一些属性和功能。**\n  * 上转型对象不能操作子类新增的成员变量；不能调用子类新增的方法。\n  * 上转型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或**子类重写**的实例方法。\n* 可以将对象的上转型对象**再强制转换到一个子类对象**，这时，该子类对象又**具备了子类所有属性和功能**。\n* **不可以将父类创建的对象的引用赋值给子类声明的对象**。\n* 如果子类重写了父类的静态方法，那么子类对象的上转型对象不能调用子类重写的静态方法，只能调用父类的静态方法。\n\n### 继承与多态\n\n* 当一个类有很多子类时，并且这些**子类都重写了父类中的某个方法**。那么当我们**把子类创建的对象的引用放到父类的一个对象中**时，就得到了该对象的一个**上转型对象**。那么**这个上转型对象在调用这个方法时就可能有多种形态**，因为不同的子类再重写父类的方法时就可能产生不同的行为。\n* **多态性**就是指父类的某个方法被其子类重写时，可以各自产生自己的功能行为。\n\n### abstract 类和 abstract 方法\n\n- 当用关键字 abstract 修饰的类称为 abstract 类（抽象类）。如：\n 	```java\n  abstract class A{\n   	···\n  }\n  ```\n- 用关键字 abstract 修饰的方法称为 abstract 方法（抽象方法），如：\n\n```Java\nabstract int main(int x, int y);\n```\n\n  	对于 abstract 方法，只允许声明，不允许实现（没有方法体），而且还不允许使用 final 和 abstract 同时修饰一个类。\n\n* 和普通的类相比，**abstract 类中可以有 abstract 方法，也可以有非 abstract 方法**。\n\n  ```java\n  abstract class A{\n      abstract int min(int x, int y); //abstract 方法\n      int max(int x, int y){          //普通方法\n          return x>y?x:y;\n      }\n  }\n  ```\n\n* **abstract 类不能使用 new 运算符创建该类的对象**。如果一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体。（这就是为什么 final 和 abstract 不能同时修饰一个方法或类的原因）。\n\n* abstract 类也可以没有abstract 方法；如果一个 abstract 类是 abstract 类的子类，它可以重写父类的 abstract 方法，也可以继承这个 abstract 方法。\n\n* 可以定义抽象类的引用，但不能实例化new\n\n### 面向抽象编程\n\n> 在设计程序时，经常会使用 abstract 类，原因是abstract类只关心操作，但不关心这些操作的具体实现细节（将这些细节留给子类的设计者）。\n\n* 例如：在设计地图时，首先考虑地图最重要的轮廓，不必去考虑诸如城市中的某街道牌号等细节，**细节应当由抽象类的非抽象子类去实现**，这些子类可以给出具体的实例，来完成程序的某些功能。\n* 在设计一个程序时，可以通过abstract类中声明若干个abstract方法，表明这些方法在整个系统设计中的重要性，方法体的内容细节由它的非abstract子类去完成。\n* 使用多态进行程序设计的核心技术之一是使用上转型对象，即将abstract类声明对象作为其子类的上转型对象，那么这个上转型对象就可以调用子类重写的方法。\n* 所谓面向抽象编程，是指当设计某种重要的类时，不让该类面向具体的类，而是面对抽象的类，级设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。\n\n### 开-闭原则\n\n> 所谓开-闭原则（Open-Closed Principle）就是让设计的系统应当对扩展开放，对修改关闭。\n\n\n\n## 接口与实现\n\n### 接口\n\n```java\ninterface Printable {\n	final int MAX = 100;\n    void add();\n    float sum(float x, float y);\n}\n```\n\n**接口声明**：interface 接口的名字\n\n**接口体**：接口体中包含常量的声明（没有变量）和抽象方法两部分。接口体中只有**抽象方法**，没有普通的方法，而且结构体中所有的常量的访问权限一定都是**public**（允许省略public、final修饰符），所有的抽象方法的访问权限一定都是public（允许省略public、abstract修饰符）\n\n### 实现接口\n\n> 接口由内去实现，以便使用接口中的方法。\n\n* 一个类可以实现多个接口类，类通过使用关键字implements声明自己实现一个或多个接口。\n\n```java\nclass A implements B,C //实现多个接口，用逗号分割\nclass A extends B implements C,D // B的子类A类实现C和D接口\n```\n\n* 如果一个非抽象类实现了某个接口，那么这个类必须重写该接口的所有方法\n\n* 注意：由于接口中的方法一定是public abstracts方法，所以非抽象类在重写接口方法时不仅要去掉abstract修饰给出方法体，而且方法的访问权限一定要明显的用public来修饰（否则就降低了访问权限，这是不允许的）\n\n* 实现接口的非抽象类一定要重写接口的方法，因此也称这个类实现了接口中的方法。\n\n* java提供的接口都在相应的包中，通过import语句不仅可以引入包中的类，也可以引入包中的接口。\n* 类重写的接口方法以及接口中的常量，可以被类的对象调用，而且常量的也可以用接口名直接调用。\n* Public接口可以被任何一个类实现，如果一个接口不加public修饰就称为友好接口类，友好接口可以被与该接口在同一包中的类实现\n* 如果父类实现了某个接口，那么子类就自然实现了该接口，子类不必再显示的使用关键字implements声明实现这个接口\n* 接口也可以被继承，既可以通过关键字extends声明一个接口是另一个接口的子接口，由于接口中的方法和常量都是public，子接口将继承父接口中的全部方法和常量\n* 注意：如果一个类声明实现一个接口，但没有重写接口中的所有方法，那么这个类必须是abstract类\n\n### 理解接口\n\n* 接口只关心操作，并不关心操作的具体实现，即只关心方法的类型、名称和参数，但不关心方法的具体行为（接口中只有abstract方法）。实现同一个接口的两个类就会具有接口规定的方法，但方法内部的细节（方法体的内容）可能不同。\n* 不同类可以实现相同的接口，同一个类也可以实现多个接口。但不希望某些类通过继承使得他们具有一些相同的方法时，就可以考虑让这些类来去实现相同的接口而不是把他们声明为同一个类的子类\n\n### 接口回调\n\n> 用接口声明的变量称为接口变量。\n\n* 接口属于引用型变量，接口变量中可以存放实现该接口的类的实例的引用，即存放对象的引用\n\n* “接口回调”表示一个变量的地址，在某一个时刻存放在一个指针变量中，那么指针变量就可以操作该变量中存放的数据\n* 在java中，接口回调是指可以把实现某一接口的类创建的对象的引用赋给该接口声明的接口变量中，那么该接口变量就可以调用被类实现的接口方法，\n* 注意：接口无法调用类中的其他非接口方法\n\n### 接口与多态\n\n* 由接口产生的多态就是指不同的类在实现同一接口时可能具有不同的实现方式，那么接口变量在回调接口方法时就可能具有多种形态。          \n\n## 内部类与异常类\n\n### 内部类\n\n```java\nOuter$Inner.class\n```\n\n* Java支持在一个类中声明另一个类，这样的类称作内部类，而包含内部类的类称为内部类的外嵌类。\n* 内部类的外嵌类的成员变量在内部类中仍然有效，内部类中的方法也可以调用外嵌类中的方法。\n* 内部类的类体中不可以声明类变量和类方法。外嵌类的内体中可以用内部类声明对象，作为外嵌类的成员。\n* 内部类仅供它的外嵌类使用，其他类不可以用某个类的内部类声明对象。\n* 另外由于内部类的外嵌类的成员变量在内部类中仍然有效，使得内部类和外圈内的交互更加方便，\n* 【注意】：Java编译器生成的内部类的字节码文件的名字和通常的类不同，内部类对应的字节码文件的名字格式是“外嵌类名$内部类名“\n* ![image-20200417141926323](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200417141926323.png)\n\n\n\n### 匿名类\n\n```java\nOuter$1.class   Outer$2.class\n```\n\n#### 和子类有关的匿名类\n\nJava允许我们直接使用一个类的子类的**类体**创建一个子类对象，也就是说，创建子类对象时，除了使用父类的构造方法外还有类体，**此类体被认为是一个子类去掉内声明后的类体，称作匿名类**。匿名类就是一个子类，由于无名可用，所以不可能用匿名类声明对象，但却可以直接用匿名类创建一个对象。\n\n假设Bank是一个类，那么下列代码就是用bank的一个子类（匿名类）创建对象：\n\n```java\nnew Bank() {\n	//匿名类的类体\n}\n```\n\n因此匿名类可以继承父类的方法，也可以重写父类的方法。使用匿名类时，必然是在某个类中直接用匿名类创建对象，因此匿名类一定是内部类，匿名类可以访问外嵌类中的成员变量和方法。匿名类的类体中不可以声明static成员变量和static方法。\n\n由于匿名类是一个子类，但没有类名，所以在用匿名类创建对象时，要直接使用父类的构造方法。\n\n尽管匿名类创建的对象没有经过类声明步骤，但匿名对象的引用可以传递给一个匹配的参数，匿名类的常用的方式是向方法的参数传值。\n\n例如：用户程序中的一个对象需要调用如下方法。\n\n```java\nvoid f(A a){\n}\n```\n\n该方法的参数类型是A类，用户希望向方法传递A的子类对象，但系统没有提供符合要求的子类，那么用户在编写代码时就可以考虑使用匿名类。\n\n传递给匿名的内部的参数-》final\n\n#### 和接口有关的匿名类\n\n假设Computable是一个接口，那么java允许直接用接口名和一个类体创建一个匿名对象，此类体被认为是实现了Computable接口的类去掉类声明后的类体，称作匿名类，下列代码就是用实现了Computable接口的类（匿名类）创建对象。\n\n```java\nnew Computable(){\n    //实现接口的匿名类类体\n}\n```\n\n如果某个方法的参数是接口类型，那么可以使用接口名和类名组合创建一个匿名对象传递给方法的参数，类体必须要重写接口中的全部方法，例如对于\n\n```java\nvoid f(Computable x)\n```\n\n其中的参数x是接口，那么在调用f时可以向f的参数x传递一个匿名对象，例如\n\n```java\nf(new Computable(){\n    //实现接口的匿名类的类体\n})\n```\n\n![image-20200417142414930](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200417142414930.png)\n\n### 异常类\n\n所谓异常就是程序运行时可能出现一些错误，例如试图打开一个根本不存在的文件等，异常处理将会改变程序的控制流程，让程序有机会对错误做出处理。\n\nJava的异常出现在方法调用过程中，其在方法调用过程中抛出异常对象，终止当前方法的继续执行，同时导致程序运行出现异常，并等待处理。\n\n异常对象可以调用如下方法，得到或输出有关异常的信息\n\n* public String getMessage();\n* public void printStackTrace();\n* public String toString();\n\n#### try-catch 语句\n\njava使用try-catch语句来处理异常，将可能出现的异常操作放在try-catch语句的try部分，当try部分中的某个方法调用发生异常后，try部分将立即结束执行而转向执行相应的catch部分，所以程序可以将发生异常后的处理放在catch部分，try-catch语句可由几个catch组成，分别处理发生的相应异常。\n\n基本格式如下：\n\n```java\ntry{\n    包含可能发生异常的句子\n}\ncatch(ExceptionSubClass1 e){\n    …\n}\ncatch(ExceptionSubClass2 e){\n    …\n}\n```\n\n各个catch参数中的异常类都是Exception的某个子类，表明try部分可能发生的异常，这些子类之间不能有父子关系，否则保留一个含有父类参数的catch即可。\n\n#### 自定义异常类\n\n在编写程序时可以拓展Exception类，定义自己的异常类，然后根据程序的需要来规定哪些方法产生这样的异常。\n\n一个方法在声明时可以使用throws关键字声明要产生的若干个异常，并在该方法的方法体中具体给出产生异常的操作，即用相应的异常类创建对象，并使用throw关键字抛出该异常对象，导致该方法结束执行。\n\n程序必须在try-catch语句中调用能发生异常的方法，其中catch的作用就是捕获throw方法抛出的异常对象。\n\n【注意】throw是java的关键字，该关键字的作用就是抛出异常throw和throws是两个不同的关键字。\n\n#### finally 子语句\n\n语法格式：\n\n```java\ntry{}\ncatch(ExceptionSubClass e){}\nfinally{}\n```\n\n其执行机制是:在执行try-catch语句后执行finally子语句，也就是说无论在try内部是否发生异常,finally子语句都会被执行\n\n但需要注意以下两种特殊情况\n\n* 如果在try-catch语句中执行了return语句，那么finally子语句仍然会被执行。\n* try-catch语句执行了程序退出代码，即执行System.exit(0)；，则不执行finally子语句（当然包括其后的所有语句）\n\n### 断言\n\n断言语句在调试代码阶段非常有用，断言语句一般用于程序不准备通过捕获异常来处理的错误。\n\n例如，当发生某个错误时，要求程序必须立即停止执行，在调试代码阶段让断言语句发挥作用，这样就可以发现一些致命的错误，当程序正在运行时就可以关闭断言语句，但仍把断言语句保留在源代码中，如果以后应用程序又需要调试，可以重新启用断言语句。\n\n使用关键字assert声明一条断言语句，断言语句有以下两种格式：\n\n* assert booleanExpression;\n* assert booleanExpression:messageException;\n\n其中booleanExpression要求必须是求值boolean型的表达式，Messageexception可以是求职字符串的表达式。\n\n如果使用asserts booleanExpression; 形式的断言语句，当booleanExpression的值是false时，程序从断言语句处停止执行，并输出messageException表达式的值，提示用户出现了怎样的问题；当messageException的值是true时，程序从断言语句处继续执行。\n\n当使用java解释器直接运行程序时，默认地关闭断言语句，在调试程序时可以使用-ea启用断言语句。例如：`java -ea mainClass`\n\n## 常用实用类\n\n### String类\n\n> Java专门提供了用来处理字符序列的String类，因此Java程序可以使用String类的对象来处理有关字符序列。\n>\n> String类在java.lang包中，由于java.lang中的类被默认引入，因此程序可以直接使用String\n>\n> 需要注意的是java把String类声明为final类，因此用户不能拓展String类，即String类不可以有子类\n\n#### 构造字符串对象\n\n可以使用String类来创建一个字符串变量，字符串变量是对象。\n\n**字符串对象**\n\n```java\nString s = new String(\"lalala\");\nString t = new String(s); //可以用一个已创建的字符串创建另一个字符串\nchar a = {\'j\',\'a\',\'v\',\'a\'}\nString s = new String(a);//用一个字符数组a创建一个字符串对象，相当于 String s = new String(\"java\");\nchar a[] = {\'A\',\'B\',\'C\',\'D\',\'E\'}\nString s = new String(a, 2, 3); //相当于String s = new String(\"CDE\")\n```\n\n**引用字符串常量对象**\n\n字符串常量是对象，因此可以把字符串常量的引用赋给一个字符串变量。\n\n```java\nstring s1,s2;\ns1 = \"how are you\";\ns2 = \"how are you\";\n```\n\n这样s1，s2具有相同的引用，而且具有相同的实体。\n\n#### String类的常用方法\n\n* public int length()：获取一个字符串长度\n* public boolean equals(String s)：比较当前字符串对象的**实体**是否与参数s指定的字符串的实体相同。public boolean equalsIgnoreCase(String s)忽略大小写。\n* public boolean startsWith(String s)、public boolean endsWith(String s)：判断当前字符串对象的前（后）缀是否是参数s指定的字符串。\n* public int compareTo(String s)：按字典序与参数s指定的字符串比较大小。相同返回0，当前字符串对象大于s，返回正值，否则返回负值。public int compareToIgnoreCase(String s)忽略大小写。\n* public boolean contains(String s)：判断当前字符串对象是否含有参数指定的字符串s。\n* public int indexOf(String s)：从当前字符串的头开始检索字符串s，并返回首次出现s的引位置。如果没有返回-1。indexOf(String s, int startpoint)从startpoint处开始检索。\n* public String substring(int startpoint)：获得一个当前字符串的子串，从startpoint到最后。substring(int start, int end)从start到end不包括end位置。\n* public String trim()：得到一个去掉前后空格的字符串。\n* public static int parseInt(String s)：将由数字组成的字符串转为int型数据。\n* public static String valueOf(int n)：将数值字符串转为数值\n* public void getChars(int start, int end, char c[], int offset)：将字符串（start->end-1）存放到数组(从offset处开始)中。必须保证数组c能容纳被复制的字符。\n* public char[] toCharArray()：将字符串中全部字符存放在一个字符数组中。\n* public boolean marches(String regex)：判断当前字符串对象是否和参数regex指定的正则表达式匹配。\n* public String replaceAll(String regex, String replacement)：返回一个字符串，该字符串是当前字符串中所有和参数regex指定的正则表达式匹配的子字符串被参数replacement指定的字符串替换后的字符串。该方法返回一个字符串，但不会改变原字符串。\n* public String[] split(String regex)：字符串调用该方法时，使用参数指定的正则表达式regex作为分隔标记分解出其中的单词，并将分解出的单词存放在字符串数组中。\n\n### StringBuffer类\n\nString类创建的字符串对象是不可修改的，也就是说String字符串不能修改、删除或替换字符串中的某个字符，即String对象一旦创建那么实体是不可以再发生变化的。\n\nStringBuffer类能创建可修改的字符串序列，也就是说该类的对象的实体的内存空间可以自动的改变大小，便于存放一个可变的字符序列。\n\n**StringBuffer对象的创建**\n\n三个构造方法：\n\n* StringBuffer()：初始容量16个字符，大于16时，实体容量自动增加，以便存放增加的字符。可通过length()方法获取实体中存放的字符序列的长度，通过capacity()方法获取当前实体的实际容量。\n* StringBuffer(int size)：初始容量为size。\n* StringBuffer(String s)：初始容量为字符串s的长度再加16个字符。\n\n**StringBuffer类的常用方法**\n\n* append方法：将其他java类型数据转化为字符串后，再追加到StringBuffer对象中。\n* public char charAt(int n)：得到参数n位置上的单个字符。n非负且小于字符串长度，从0开始。\n* public void setCharAt(int n, char ch)：将n处字符用ch代替。\n* StringBuffer insert(int index, String str)：将参数str指定的字符串插入到参数index指定的位置，并返回当前对象的引用。\n* public StringBuffer reverse()：将该对象实体中的字符翻转，并返回当前对象的引用。\n* StringBuffer delete(int startIndex, int endIndex)： 删除一个子字符串，并返回当前对象的引用。deleteCharAt(int index)删除index处的一个字符。\n* StringBuffer replace(int startIndex, int endIndex, String str)：替换并返回引用。\n\n### StringTokenizer类\n\nStringTokenizer对象用于分解字符串，与split不同的是，StringTokenizer对象不是用正则表达式作为分隔标记。\n\n**构造方法**：\n\n* StringTokenizer(String s):为字符串s构造一个分析器。使用默认的分隔标记，即空格符（若干个空格被看作一个空格）换行符、回车符、Tab符，进纸符做分隔标记，\n* StringTokenizer(String s, String delim)：为字符串s构造一个分析器。参数delim中的字符被作为分隔标记。\n\n称一个StringTokenizer对象为一个字符串分析器，一个分析器可以使用**nextToken()方法逐个获取字符串中的语言符号(单词)**，每当调用nextToken()时都将在字符串中获得下一个语言符号，每当获得到一个语言符号，字符串分析器中的负责计数的变量的值就自动减1，该计数变量的初始值等于字符串中的单词数目，通常用while循环来逐个获取语言符号，为了控制循环，可以使用StringTokenizer类中的**hasMoreTokens()方法**，只要字符串中还有语言符号，即计数器的值大于0，该方法就返回true，否则返回false，另外还可以随时让分析器调用**countTokens()方法得到分析器中计数变量的值。**\n\n### Date类\n\n**构造方法**：\n\n* Date nowTime = new Date(); 获取本地当前时间。\n* Date date = new Date(1000);带参数，表示1970年1月1日0时（格林威治时间）后的1毫秒。\n\n使用 public long currentTimeMillis()获取系统当前时间。\n\n**日期格式化**：\n\n示例：\n\n```java\nimport java.util.Date;\nimport java.text.SimpleDateFormat; //使用java.text包中的DateFormat的子类SimpleDateFormat来实现日期的格式化\npublic class DateExample{\n    public static void main(String args[]){\n        Date noWTime = new Date();\n        String pattern = \"yyyy-MM-dd\"; //指定格式\n        SimpleDateFormat SDF = new SimpleDateFormat(pattern);//创建一个对象\n        String time = SDF.format(nowTime);//格式化\n    }\n}\n```\n\n### Calendar 类\n\n- Calendar 类在java.util包中，使用Calendar 类的static方法getInstance()可以初始化一个日历对象。如：`Calendar calendar = Calendar.getInstance()`\n- calendar对象可以调用方法：`public final void set(int year, int month, int date, int hour, int minute, int second)`将日历翻到任何一个时间。\n- public int get(int field)方法可以获取有关年、月、小时、星期等信息。参数field有效值由Calendar的静态常量指定，如`calendar.get(Calendar.MONTH);`返回一个整数。\n- public long getTimeInMillis()可以将时间表示为毫秒。\n\n### Math类和BigInteger类\n\n**Math类常用方法：**\n\n* public static int abs(double a)： 返回a的绝对值。\n* public static double max(double a, double b):a、b的最大值\n* public static double min (double a, double b):a、b的最小值\n* public static double random():产生一个0~1之间的随机数\n* public static double pow(double a, double b):a的b次幂\n* public static double sqrt(double a):平方根\n* public static double log(double a):返回a的对数\n* public static double sin(double a):返回正弦值\n* public static double asin(doble a):返回反正弦值\n\n程序有时需要处理大整数，java.math中的BigInteger来提供任意精度的整数运算，可以使用构造方法public bigInteger(Stirng val)，构造一个十进制的BigInteger对象，该构造方法可以发生NumberFormatException异常，也就是说，字符串参数val中如果含有非数字字符就会发生NumberFormatException异常。\n\n**常用方法**：\n\n* public BigInteger add(BigInteger val)：和\n* public BigInteger substract(BigInteger val)：差\n* public BigInteger multiply(BigInteger val)：积\n* public BigInteger divide(BigInteger val)：商\n* public BigInteger remainder(BigInteger val)：余\n* public BigInteger abs()：绝对值\n* public BigInteger pow(int a)：平方\n* public int compareTo(BigInteger val)：比较，1，-1，0\n* public String toString()：十进制的字符串表示\n* public String toString(int p)：p进制的字符串表示\n\n### DecimalFormat类\n\n> 对输出的数字结果进行必要的格式化。\n>\n> java.text包\n\n```java\nDecimalFormat format = new DecimalFormat(\"###,##00.00\"); //格式化整数位和小数位，用0和.;整数的分组用#\nString result = format.format(123456789.543210);//1,2345,6789.54\n//模式尾加%，可以将数字格式化为百分数，加”\\u2030\"将数字格式化为钱分数。加“E0\"，将数字格式化为科学计数法。加￥、$将数字格式化为带货币符号的串。\n```\n\n将格式化字符串转为数字：\n\n```java\nDecimalFormat df = new DecimalFormat(\"###,#00.000$\");\nNumber num = df.parse(\"3,322,456.234$\");\ndouble d = num.doubleValue();\nd//3322456.234\n```\n\n### Pattern 与 Match 类\n\n> 模式匹配就是检索和指定模式匹配的字符串。java提供了专门用来进行模式匹配的 Pattern 类和 Match 类，这些类在java.util.regex包中。\n\n**模式对象**\n\n进行模式匹配的第1步就是使用Pattern类创建一个对象，称作模式对象。模式对象是对正则表达式的封装。Pattern类调用方法compile(String regex)返回一个模式对象，其中参数regex是一个正则表达式，称作模式对象使用的模式。比如：`Pattern p = Pattern.compile(\"hello\\\\d\")`\n\n如果参数regex指定的正则表达式有错，方法将抛出异常:PatternSyntaxException。\n\nPattern 类也可以调用类方法compile(String regex, int flags)返回一个Pattern 对象，参数flag可以取下列有效值：Pattern.CASE_INSENSITIVE，Pattern.MULTILINE，Pattern.DOTALL，Pattern.UNICODE_CASE，Pattern.CANON_EQ。\n\n**匹配对象**\n\n模式对象p调用matcher(CharSequence input)方法返回一个Matcher对象m，称作匹配对象，参数input可以是任何一个实现接口CharSequence 的类创建的对象，前面学过的String类和StringBuffer类都实现了接口。\n\n一个Matcher对象可以使用下列方法寻找参数指定的字符序列中是否有和模式匹配的子序列.\n\n* public boolean find()\n* public boolean matches()\n* public boolean lookingAt()\n* public boolean find(int start)\n* public String replaceAll(String replacement)\n* public String replaceFirst(String replacement)\n\n### Scanner类\n\n使用 Scanner 类从字符串中解析程序需要的数据。\n\n**使用默认分隔标记解析字符串**\n\n例子：\n\n```java\nString NBA = \"I LOVE THIS GAME\";\nScanner scanner = new Scanner(NBA);//构造一个Scanner对象\n```\n\nscanner将**空白**作为分隔标记、调用方法next()依次返回NBA中的单词，如果NBA最后一个单词已被next()方法返回，scanner调用hasNext()将返回false,否则返回true。对于数字型单词，可用nextDouble()、nextInt()等。\n\n如果单词不是数字型单词，调用nextInt()等方法将发生 InputMismatchException异常。\n\n**使用正则表达式作为分隔标记解析字符串**\n\nScanner可以调用 useDelimiter(正则表达式); 方法将一个正则表达式作为分隔标记，即和正则表达式匹配的字符串都是分隔标记。\n\n## 输入输出流\n\n> 程序在运行期间，可能需要从外部的存储媒介或其他程序中读入需要的数据，这就需要使用输入流对象。输入流的指向称作它的源，程序从指向源的输入流中读取源中的数据。\n>\n> 另一方面程序在处理数据后，可能需要将处理的结果写入到永久的存储媒介中或传送给其他的应用程序，这就需要使用输出流对象。输出流的指向称作它的目的地，程序通过向输出流中写入数据把数据传送到目的地。\n\n### File类\n\n程序可能经常需要获取磁盘上文件的有关信息，或者在磁盘上创建新的文件等，这就需要File类。File类的对象，主要是用来获取文件本身的一些信息，例如文件所在的目录、文件的长度、文件读写权限等，不涉及对文件的读写操作。\n\n创建File对象的构造方法：\n\n```java\nFile(String filename);  //该文件认为与当前应用程序在同意目录\nFile(String directoryPath, String filename);\nFile(File f, String filename);//filename是文件名字，directoryPath是文件路径，f是制定一个目录的文件\n```\n\n#### 文件的属性\n\n* public String getName()：获取文件的名字\n* public boolean canRead()：判断文件是否可读\n* public boolean canWrite()：判断文件是否可写\n* public long length()：获取文件长度（单位是字节）\n* public String getAbsolutePath()：获取文件绝对路径\n* public String getParent()：获取文件父目录\n* public boolean isFile()：判断文件是否是一个普通文件，而不是目录\n* public boolean isDirectory()：判断文件是否是一个目录\n* public boolean isHidden()：判断文件是否是隐藏文件\n* public long lastModified()：获取文件最后修改时间（时间是从1970年午夜至文件最后修改时刻的毫秒数）\n\n#### 目录\n\n**创建目录**\n\n```java\n//File对象调用方法\npublic boolean mkdir()//创建一个目录，成功返回true，否则返回false\n```\n\n**列出目录中的文件**\n\n如果File对象是一个目录，可调用下述方法列出该目录的文件和子目录\n\n* public String[] list()用字符串形式返回目录下的全部文件\n* public File [] listFiles()用File对象形式返回目录下的全部文件\n* public String[] list(FilenameFilter obj)该方法用字符串形式返回目录下的指定类型的所有文件\n* public File [] listFiles(FilenameFilter obj)该方法用File对象形式返回目录下的指定类型所有文件\n\nFilenameFilter是一个接口，该接口有一个方法：public boolean accept(File dir, String name)。\n\n使用list方法时，需向该方法传递一个实现接口FilenameFilter的对象，list 方法执行时，参数obj不断回调接口方法accept(File dir, String name)，该方法中的参数dir为调用list的当前目录、参数name被实例化目录中的一个文件名，当接口方法返回true时，list方法就将名字为name的文件存放到返回的数组中。\n\n#### 文件的创建与删除\n\n当使用file类创建一个文件对象后，例如`File file = new File(\"c:\\\\myletter\",\"letter.txt\");`\n\n如果c:\\\\myletter目录中没有名字为letter.txt的文件。文件对象调用方法`public boolean createNewFile();`\n\n可以在c:\\\\myletter目录中建立一个名字为letter.txt的文件。文件对象调用方法`public boolean delete();`\n\n可以删除当前文件，例如:`file.delete();`\n\n#### 运行可执行文件\n\n当要执行一个本地机上的可执行文件时，可以使用 java.lang 包中的Runtime类，首先使用Runtime类声明一个对象，例如:`Runtime ec;`\n\n然后使用该类的静态方法 getRuntime() 创建这个对象:`ec = Runtime.getRuntime();`\n\nec可以调用exec(String command) 方法打开本地机的可执行文件或执行一个操作。\n\n### 字节流与字符流\n\njava.io包中提供了大量的流类，java把InputStream抽象类的子类创建的流对象称为字节输入流、OutputStream抽象流的子类对象创建的流对象称作字节输出流，Java把Reader抽象类的子类创建的流对象称作字符输入流、Writer抽象类的子类创建的流对象称作字符输出流。\n\n针对不同的语言或目的地，java.io 包为程序提供了相应的输入流或输出流。这些输入输出流，绝大部分都是InputStream OutputStream Reader Writer的子类。\n\n例如，如果需要以字节为单位对磁盘上的文件进行读写操作，就可以分别使用InputStream和OutputStream的子类FileInputStream FileOutputStream来创建文件流和文件输出流。\n\n#### InputStream类和OutputStream类\n\nInputStream提供的read方法以字节为单位顺序的读取源中的数据，只要不关闭流，每次调用read方法就会顺序的读取源中的其余内容，直到源的末尾或输入流被关闭。\n\n方法：\n\n* int read()\n* int read(byte b[])\n* int read(byte b[], int off, int len)\n* void close()\n* long skip(long numBytes)\n\nOutputStream类以字节为单位顺序的写文件，只要不关闭流，每次调用write方法就会顺序的向目的地写入内容，直到流被关闭\n\n方法：\n\n* void write(int n)\n* void wirte(byte b[])\n* void wirte(byte b[], int off, int len)\n* void close()\n\n#### Reader类和Writer类\n\nReader 类提供的read方法以字符为单位顺序的读取源中的数据，只要不关闭流，每次调用read方法就顺序的读取源中的其余内容，直到源的末尾或输入流被关闭\n\n常用方法：\n\n* int read()\n* int read(char b[])\n* int read(char b[], int off, int len)\n* void close()\n* long skip(long numBytes)\n\nOutStream流以字符为单位顺序的写文件，只要不关闭流，每次调用write方法就顺序地向目的地写入内容，直到流被关闭。\n\n常用方法：\n\n* void wirte(int n)\n* void wirte(byte b[])\n* void wirte(byte b[], int off, int length)\n* void close()\n\n#### 关闭流\n\n流都提供了关闭方法close()，尽管程序结束时会自动关闭所有打开的流，但是当程序使用完流后，显示的关闭任何打开的流仍是一个良好的习惯。\n\n如果没有关闭那些被打开的流，那么就可能不允许另一个程序操作这些流所用的资源。\n\n另外需要注意的是，在操作系统把程序写到输出流上的那些字节保存到磁盘上之前，有时被存放在内存缓冲区中，通过调用close()方法可以保证操作系统把流缓冲区的内容写到它的目的地，即关闭输出流可以把该流所用的缓冲区的内容冲洗掉（通常冲洗到磁盘文件上）\n\n### 文件字节流\n\nInputStream专门提供了读写文件的子类：FileInputStream和FileOutputStram类。\n\n### 文件字符流\n\nFileReader、Filewirter\n\n### 缓冲流\n\nBufferedReader和BufferedWriter类创建的对象称作缓冲输入输出流。\n\n### 随机流\n\nRandomAccessFile类创建的流称作随机流。\n\n### 数组流\n\n字节数组流\n\n字符数组流\n\n### 数据流\n\nDataInputStream和DataOutputStream类创建的对象称为数据输入流和数据输出流。\n\n### 对象流\n\nObjectInputStream 和 ObjectOutputStream\n\n### 序列化和对象克隆\n\n### 文件锁\n\n### 使用Scanner对象解析文件\n\n','java程序设计思考与总结',1590508800,0),(2,3,'javascript算法与数据结构','# JavaScript数据结构与算法\n\n> 加油！坚持下去，一定会成功的！\n\n## 数组\n\n### 创建和初始化数组\n\n```js\nvar arr = new Array();\nvar arr = new Array(5);\nvar arr = new Array(\"hello\", \"world\");\n//用new创建数组并不是最好的方式，可以直接用[]\nvar arr = [];\nvar arr = [\"he\",\"lo\",\"wor\"];\n\narr.length //求数组长度\n```\n\n### 添加元素\n\n```js\nvar nums = [1,2,3,4,5,6,7];\nnums[nums.length] = 8;//js中数组是可修改对象。如果添加元素，它就会动态增长。\nnums.push(8); //push添加在元素末尾，返回数组长度\nnums.unshift();//数组首位添加元素\nnums.splice(5,0,1,2,3) //在索引5的位置插入1,2,3；0表示删除0个元素\n```\n\n### 删除元素\n\n```js\nnums.pop();//返回pop出去的值\nnums.shift();//从数组首位删除\nnums.splice(5,3);//删除从索引5开始的3个元素\ndelete nums[3] //删除索引3的值，此处值变为undefined，建议不用\n```\n\n### JavaScript数组参考方法\n\n| 方法名      | 描述                                                         | 示例 |\n| ----------- | ------------------------------------------------------------ | ---- |\n| concat      | 连接2个或更多数组，并返回结果                                |      |\n| every       | 对数组每一项运行给定函数，如果该函数每一项都返回true，则返回true |      |\n| some        | 对数组每一项运行给定函数，如果该函数任一项都返回true，则返回true |      |\n| filter      | 对数组每一项运行给定函数，返回该函数会返回true的项组成的数组 |      |\n| map         | 对数组每一项运行给定函数，返回每次函数调用的结果组成的数组（item,index) |      |\n| reduce      | 接受一个函数作参数：见下方                                   |      |\n| forEach     | 对数组每一项运行给定函数，没有返回值                         |      |\n| indexOf     | 返回第一个与给定参数相等的数组元素的索引，没有则返回-1       |      |\n| lastindexOf | 返回最后一个与给定参数相等的数组元素的索引，没有则返回-1     |      |\n| join        | 将所有数组元素连成一个字符串                                 |      |\n| reverse     | 将数组逆序                                                   |      |\n| slice       | 传入索引值，将数组里对应索引范围内的元素作为新数组返回       |      |\n| sort        | 按字母顺序对数组排序                                         |      |\n| toString    | 将数组作为字符串返回                                         |      |\n| valueOf     | 和toString类似，将数组作为字符串返回                         |      |\n\n[toString()和valueOf的区别](https://www.cnblogs.com/niulina/p/5699031.html)\n\n**reduce**：reduce方法接收一个函数作为参数，该函数有四个参数：previousValue,currentValue,index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器。\n\n```js\nnums.reduce((pre,cur,index)=>pre+cur);//将一个数组中所有元素求和\n```\n\n### ES6 数组新增方法\n\nES6为Array类增加了一个@@interator属性，需要通过Symbol.iterator来访问。\n\n| 方法        | 描述                                                         | 例子 |\n| ----------- | ------------------------------------------------------------ | ---- |\n| @@interator | 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 |      |\n| copyWithin  | 复制数组中一系列元素到同一数组指定的起始位置(替换位置，该位置读取，到该位置为止) |      |\n| entries     | 返回包含数组所有键值对的@@interator                          |      |\n| includes    | 如果数组中存在某个元素则返回true                             |      |\n| find        | 根据回调函数给定条件从数组中查找元素，如果找到返回该元素     |      |\n| findIndex   | 根据回调函数给定条件从数组中查找元素，如果找到返回该元素索引 |      |\n| fill        | 用静态值填充数组                                             |      |\n| from        | 根据已有数组创建一个新的数组                                 |      |\n| keys        | 返回包含数组所有索引的@@interator                            |      |\n| of          | 根据传入的参数创建一个新数组                                 |      |\n| values      | 返回包含数组中所有值的@@interator                            |      |\n\n```js\nb=[1,2,3,4,5]\nb.copyWithin(0,3)//[4, 5, 3, 4, 5],b的值已改变\nb=[1,2,3,4,5]\nb.includes(3)//true\nb.find(v=>v<2)//1\nb.findIndex(v=>v<3)//0\n\nfor(let n in b){ n%2===0?\'even\':\'odd\'}//使用for in 迭代 \"odd\"\n\nlet iterator = b[Symbol.iterator]();\niterator.next().value//1\niterator.next().value//2\niterator.next().value//3\niterator.next().value//4\niterator.next().value//5\niterator.next().value//undefined\n\nlet aEntries=b.entries()\naEntries.next().value//[0, 1]\n...\naEntries.next().value//[4,5]\naEntries.next().value//undefined\n\nlet aKeys = b.keys()\naKeys.next()//{value: 0, done: false}\n...\naKeys.next()//{value: 4, done: false}\naKeys.next()//{value: undefined, done: true}\n\nlet aValues=b.values()\naValues.next()//{value: 1, done: false}\n...\naValues.next()//{value: undefined, done: true}\n\nlet c=Array.from(b)//[1,2,3,4,5]\nlet c=Array.from(b,v=>v>2)//\n\nlet d=Array.from(b,v=>v+2)//[3,4,5,6,7]\nArray.of(...b)//[1,2,3,4,5]\nk=[1,2]\nk.fill(0)//[0, 0]\nk.fill(1,3,5)//3-5的位置填为1\nlet ones = new Array(6).fill(1)//[1, 1, 1, 1, 1, 1]\nd.sort((a,b)=>a-b)\n(6)?[1, 3, 4, 6, 10, 23]\nd.sort((a,b)=>b-a)\n(6)?[23, 10, 6, 4, 3, 1]\nd.toString()\n\"23,10,6,4,3,1\"\nd.join(\'-\')\n\"23-10-6-4-3-1\"\n```\n\n\n\n## 栈\n\n栈是一种先进后出的数据结构。可以用数组来表示。\n\n```js\nfunction Stack(){ //栈类\n    let items = []\n    this.push = function (element){ //添加\n        items.push(element)\n    }\n    this.pop = function (){//删除\n        return items.pop()\n    }\n    this.peek = function(){//取得栈顶元素\n        return items[items.length-1]\n    }\n    this.isEmpty = function(){//判断是否为空\n        return items.length==0\n    }\n    this.size = function(){//计算栈的大小\n        return items.length\n    }\n    this.clear = function(){//清空栈\n        items = []\n    }\n    this.print = function{//打印\n        console.log(items.toString())\n    }\n}\n//使用\nlet stack = new Stack()\n```\n\n上面的语法创建了一个可以当作类来使用的Stack函数。js函数都有构造函数，可以用来模拟类的行为。我们声明了一个私有变量items，他只能被Stack函数/类访问。然而这个方法为每个类的实例都创建了一个items变量的副本。因此如果创建更多Stack实例，他就不太合适了。\n\n**ES6语法声明Stack类**（基于原型的类，比基于函数的类更节省内存，也更适合创建多个实例，但不能声明私有变量！！）\n\n```js\nclass Stack{\n    constructor(){\n        this.items=[]  //这里的items变量是公共的。\n    }\n    push(element){\n        this.items.push(element)\n    }\n    //其他方法\n}\n```\n\n**ES6限定作用域Symbol实现类**（创建伪私有属性，因为ES6的Object.getOwnPropertySymbols方法能取到类中声明的所有Symbols属性）\n\n```js\nlet _items = Symbol()\nclass Stack{\n    constructor(){\n        this[_items]=[]\n    }\n    //Stack方法\n}\n```\n\n**ES6的WeakMap实现类**\n\n```js\nconst items = new WeakMap()\nclass Stack(){\n    constructor(){\n        items.set[this,[]]\n    }\n    push(element){\n        let s = items.get(this)\n        s.push(element)\n    }\n    pop(){\n        let s = items.get(this)\n        let r = s.pop()\n        return r;\n    }\n    //其他\n}\n```\n\nitems在Stack类里面是真正的私有属性了。但items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们可以用一个闭包（外层函数）把Stack类包装。\n\n```js\nlet Stack = (function(){\n    const items = new WeakMap()\n    class Stack{\n        constructor(){\n            items.set(this,[])\n        }\n        push(e){\n            let s = items.get(this)\n            s.push(e)\n        }\n        //其他\n    }\n    return Stack\n})()\n```\n\n缺点：拓展类无法继承私有属性。\n\n**应用**\n\n十进制转任意进制。\n\n```js\nfunction bascConverter(decNumber, base){\n    var remStack = new Stack(),rem,baseStrig=\'\',digits=\'0123456789ABCDEF\';\n    while(decNumber{>0){\n        rem = Math.floor(decNumber%base)\n        remStack.push(rem)\n        decNumber=Math.floor(decNumber/base)\n    }\n    while(remStack.isEmpty()){\n        baseString+=digits[remStack.pop()]\n    }\n    return remStack\n}\n```\n\n\n\n## 队列\n\n### 队列表示\n\n```js\nfunction Queue(){\n    let items = []\n    this.enqueue=function(element){\n        items.push(element)\n    }\n    this.dequeue = function(){\n        return items.shift()\n    }\n    this.front=function(){//查看队列头元素，即最先被移除的元素\n        return items[0]\n    }\n    this.isEmpty=function(){\n        return items.length==0\n    }\n    this.size=function(){\n        return items.length\n    }\n    this.print = function(){\n        console.log(items.toString())\n    }\n}\n\nlet queue = new Queue();\n```\n\nES6实现\n\n```js\nlet Queue=(function(){\n	const items = new WeakMap()\n    class Queue{\n		constructor(){\n			items.set(this,[])\n        }\n        enqueue(element){\n            let q = items.get(this)\n            q.push(element)\n        }\n        dequeue(){\n            let q = items.get(this)\n            let r = q.shift()\n            return r\n        }\n        //其他方法\n    }\n})();\n```\n\n### 优先队列\n\n元素的添加和移除是基于优先级的。此例为最小优先队列。即优先值小的在前。\n\n```js\nfunction PriorityQueue(){\n	let items = []\n    function QueueElment(element, priority){\n        this.element = element\n        this.priority = priority\n    }\n    this.enqueue = function (element, priority){\n        let queueElement = new QueueElement(element, priority)\n        let added = false\n        for(let i = 0; i < items.length; i++){\n            if(queueElement.priotity<items[i].priority){\n                items.splice(i,0,queueElement)\n                added = true\n                break\n            }\n        }\n        if(!added){\n            items.push(queueElement)\n        }\n    }\n}\nlet priorityQueue = new PriorityQueue()\npriorityQueue.enqueue(\"aa\",1);\n```\n\n### 循环队列--击鼓传花\n\n```js\nfunction hotPotato(nameList, num){\n    let queue = new Queue();\n    for(let i = 0; i < nameList.length; i++){\n        queue.enqueue(nameList[i])\n    }\n    let eliminated = \'\'\n    while(queue.size()>1){\n        for(let i = 0; i < num; i++){\n            queue.enqueue(queue.dequeue())\n        }\n        eliminated = queue.dequeue()\n        console.log(eliminated+\"被淘汰\")\n    }\n    return queue.dequeue();\n}\n\nlet names = [\'zhang\',\'li\',\'wang\',\'liu\']\nlet  winnner = hotPotato(names, 7)\nconsole.log(winner)\n```\n\n\n\n## 链表\n\n> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。\n>\n> 相对传统数组，链表一个好处在于，添加和移动元素不需要移动其他元素。但链表需要用到指针。\n>\n> 数组可以直接访问任何位置的元素，而想访问链表中的一个元素需要从表头开始迭代列表知道找到所需的元素。\n\n### 创建链表\n\n```js\nfunction LinkedList(){\n    //需要一个Node辅助类，Node类表示要加入列表的项。包含一个element属性，即要添加到列表的值，以及一个next属性，即指向下一个节点项的指针。\n    let Node = function(element){\n        this.element = element;\n        this.next = null;\n    }\n    \n    let length = 0;//列表长度\n    let head = null;\n    //向列表尾部添加一个新的项\n    this.append = function(element){\n        let node = new Node(element);\n        let current;\n        if(head == null) head = node;\n        else{\n            current = head;\n            while(current.next){\n                current = current.next\n            }\n            current.next = node;\n        }\n        length++;\n    }\n    //向列表特定位置插入一个新的项\n    this.insert = function(position, element){\n        if(position>=0&&position <=length){\n            let node =new Node(element), current = head, pervious, index=0;\n            if(position == 0) {\n                node.next = current\n            	head = node\n            } else{\n                while(index++<position){\n                    pervious = current;\n                    current = current.next;\n                }\n                node.next = current\n                pervious.next = node\n            }\n            length++\n            return true\n        }else{\n            return false\n        }\n    }\n    //从列表中特定位置移除一项\n    this.removeAt = function(position){\n        if(position>-1&&position<length){\n            let previous, index = 0, current = head;\n          	if(position==0) head = current.next;\n            else{\n                while(index++<position){\n                    previous = current;\n                    current = current.next;\n                }\n                previous.next = current.next\n            }\n            length--;\n            return current.element;\n        }else{\n            return null;\n        }\n    }\n    //从列表中移除一项\n    this.remove = function(element){\n        let index = this.indexOf(element)\n        return this.removeAt(index)\n    }\n    //返回元素在列表中的索引\n    this.indexOf = function(element){\n        let current = head;\n        index = -1;\n        while(current){\n            if(element === current.element){\n                return index\n            }\n            index++;\n            current = current.next\n        }\n        return -1;\n    }\n    //如果链表不包含任何元素，返回true\n    this.isEmpty = function(){\n        return length === 0;\n    }\n    //返回链表包含的元素个数\n    this.size = function(){\n        return length;\n    }\n    this.getHead = function(){\n        return head;\n    }\n    //输出元素的值\n    this.toString = function(){\n        let current = head, string = \'\';\n        while(current){\n            string+=current.element+(current.next?\'n\':\'\');\n            current = current.next\n        }\n        return string\n    }\n    this.print = function(){}\n}\n```\n\n### 双向链表\n\n```js\nfunction DoublyLinkedList(){\n    let Node = function(element){\n        this.element = element\n        this.next = null\n        this.prev = null\n    }\n    let length = 0\n    let head = null\n    let tail = null //保存对列表最后一项的引用\n    \n    this.insert = function(position, element){\n        if(position>=0&&position<=length){\n            let node = new Node(element)\n        	let current = head , previous, index = 0;\n            if(position == 0) {\n                if(!head){//如果列表为空\n                    head = node;\n                    tail = node;\n                } else{\n                    node.next = current\n                    current.prev = node\n                    head = node\n                }\n            }else if(position == length){\n                current = tail\n                current.next = node\n                node.prev = current\n                tail=node\n            }else{\n                while(index++<position){\n                    previous = current\n                    current =current.next\n                }\n                node.next = current\n                previous.next = node\n                \n                current.prev = node\n                node.prev = previous\n            }\n            length++\n            return true\n        } else{\n            return false\n        }\n    }\n    \n    this.removeAt = function(element){\n        if(position>-1&&position<length){\n            let current = head,previous,index=0;\n            if(position ==0){\n                head = current.next\n                if(length==1){\n                    tail = null\n                }else{\n                    head.prev=null\n                }\n            }else if(position === length-1){\n                current = tail\n                tail = current.prev\n                tail.next = null\n            }else{\n                while(index++<position){\n                    previous = current\n                    current = current.next\n                }\n                previous.next = current.next\n                current.next.prev = previous\n            }\n            length--;\n            return current.element\n        }else{\n            return null\n        }\n    }\n}\n```\n\n\n\n## 集合\n\n**一种不允许重复的顺序数据结构。**\n\n### 集合的创建\n\n```js\nfunction Set(){\n    let items = {} //使用对象而不是数组来表示集合\n    //向集合添加一个新的项\n    this.add=function(value){\n        if(!this.has(value)){\n            items[value]=value\n            reutrn true\n        }\n        return false\n    }\n    //从集合移除一个值\n    this.delete=function(value){\n        if(this.has(value)){\n            delete items[value];\n            return true\n        }\n        return false\n    }\n    //如果值在集合中，返回true\n    this.has = function(value){\n        return value in items\n        //或者\n        //return items.hasOwnProperty(value) \n        //js对象都有这个方法，该方法返回一个表明对象是否具有特定属性的布尔值\n    }\n    //移除集合中所有项\n    this.clear(){\n        items={}\n    }\n    //返回集合所包含元素的数量\n    this.size=function(){\n        //Object类有一个keys方法，它返回一个包含给定对象所有属性的数组\n        return Object.keys(items).length\n    }\n    //另一种求size的方法\n    this.sizeLegacy = function(){\n        let count=0\n        for(let key in items){ \n            if(items.hasOwnProperty(key)) ++count  //避免重复计数\n        }\n        return count\n    }\n    //返回一个集合中所有值的数组\n    this.values=function(){\n        let values = []\n        for(let i = 0; keys = Object.keys(items);i<keys.length;i++){\n            values.push(items[keys[i]])\n        }\n        return values\n    }\n    //另一种方法实现values()方法\n    this.valuesLegacy = function(){\n        let values = []\n        for(let key in items){\n            if(items.hasOwnProperty(key)){\n                values.push(items[key])\n            }\n        }\n        return values\n    }\n}\n//使用\nlet set = new Set()\nset.add(1)\nset.values()//1\nset.has(1)//true\nset.size()//1\n```\n\n### 集合的操作\n\n#### A并B\n\n```js\nthis.union = function(otherSet){\n    let unionSet = new Set()\n    let values = this.values()\n    for(let i = 0; i < values.length; i++){\n        unionSet.add(values[i])\n    }\n    values = otherSet.values()\n    for(let i = 0; i < values.length; i++){\n        unionSet.add(values[i])\n    }\n    return unionSet\n}\n```\n\n#### A交B\n\n```js\nthis.intersection = function(otherSet){\n    let intersectionSet = new Set()\n    let values = this.values()\n    for(let i = 0; i < length; i++){\n        if(otherSet.has(values[i])){\n            itersectionSet.add(values[i])\n        }\n    }\n    return itersectionSet\n}\n```\n\n#### 差集A-B\n\n```js\nthis.difference = function(otherSet){\n    let differenceSet = new Set()\n    let values = this.values()\n    for(let i = 0; i < values.length; i++){\n        if(!otherSet.has(values[i])){\n            differenceSet.add(values[i])\n        }\n    }\n    return differenceSet\n}\n```\n\n#### 子集--A是B的子集\n\n```js\nthis.subset = function(otherSet){\n    if(this.size()>otherSet.size){\n        return false\n    }else{\n        let values = this.values()\n        for(let i = 0; i < values.length; i++){\n            if(!otherSet.has(values[i])){\n                return false\n            }\n        }\n        return true\n    }\n}\n```\n\n\n\n### ES6 — Set类\n\n与我们自定义的Set类不同，Es6的Set的values方法返回Iterator,而不是构成值的数组。ES6的Set有一个size属性，而我们实现的size是一个方法。\n\n#### 模拟并集操作\n\n```js\nlet unionAb = new Set()\nfor(let x of setA) unionAb.add(x)\nfor(let x of setB) unionAb.add(x)\n```\n\n#### 模拟交集操作\n\n```js\nlet intersection = function(setA, setB){\n    let intersectionSet = new Set()\n    for(let x of setA){\n        if(setB.has(x)){\n            intersectionSet.add(x)\n        }\n    }\n    return intersectionSet\n}\nlet intersectionAb = intersection(setA, setB)\n\n//或者\nintersectionAb = new Set([x for (x of setA) if(setB.has(x))])\n```\n\n#### 模拟差集操作\n\n```js\nthis.difference = function(setA, setB){\n    let differenceSet = new Set()\n    for(let x of setA){\n        if(!setB.has(x)){\n            differenceSet.add(x)\n        }\n    }\n    return differenceSet\n}\n\n//或者\nlet differenceAb = new Set([x for (x of setA) if(!setB.has(x))])\n```\n\n## 字典和散列表\n\n集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是值的本身，并把它当作主要元素。在字典中，我们用[键，值]对的形式来存储数据，散列表中也是如此，但实现方式略有不同。\n\n### 字典\n\n```js\nfunction Dictionary(){\n    var items = {}\n    //向字典中添加新元素\n    this.set = function(key, value){\n        items[key] = value\n    }\n    //通过键值来从字典中移除键值对应的数据值\n    this.delete = function(key){\n        if(this.has(key)){\n            delete items[key]\n            return true\n        }\n        return false\n    }\n    //如果某个键值存在于这个字典中，则返回true\n    this.has = function(key){\n        return key in items\n    }\n    //通过键值查找特定的数值并返回\n    this.get = function(key){\n        return this.has(key)?items[key]:undefined\n    }\n    //将字典中所有元素删除\n    this.clear = function(){\n        items = {}\n    }\n    //返回字典中包含元素的数量\n    this.size = function(){\n        return Object.keys(items).length\n    }\n    //将字典包含的所有键名以数组形式返回\n    this.keys = function(){\n        return Object.keys(items)\n    }\n    this.getItems = function(){\n        return items\n    }\n    //将字典包含的所有数值以数组形式返回\n    this.values = function(){\n        var values =[]\n        for(var k in items){\n            if(this.has(k)){\n                values.push(items[k])\n            }\n        }\n        return values;\n    }\n}\n```\n\n### 散列表\n\n> 散列算法的作用是尽可能快地在数据结构中找到一个值。前面的方法中获得一个值（get方法），需要遍历整个数据结构。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。\n\n#### 散列表的创建\n\n```js\nfunction HashTable(){\n    vat table = []\n    //在实现下列方法之前，要实现的第一个方法是散列函数，它是HashTable的一个私有方法\n    var loseloseHashCode = function(key){\n        var hash = 0;\n        for(var i = 0; i < key.length; i++){\n            hash+=key.charCodeAt(i)\n        }\n        return hash%37\n    }\n    //向散列表中增加一个新的项，也可以更新散列表\n    this.put = function(key,value){\n        var position = loseloseHashCode(key)\n        console.log(position+\'-\'+key)\n        table[position] = value\n    }\n    //根据键值从散列表中移除值\n    this.remove = function(key){\n        table[loseloseHashCode(key)] = undefined\n    }\n    //返回根据键值检索到的特定的值\n    this.get = function(key){\n        return table[loseloseHashCode(key)]\n    }\n}\n//使用\nvar hash = new HashTable()\nhash.put(\'Gandalf\', \'gandalf@email.com\') //19-Gandalf\nhash.get(\'Gandalf\') //gandalf@email.com\nhash.remove(\'Gandalf\')\n```\n\n#### 处理散列表的冲突\n\n##### 分离链接\n\n分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单方法，但需要更多的额外空间。\n\n```js\n//增加辅助类，在HashTable类内部定义\nvar ValuePair = function(key, value){\n    this.key = key\n    this.value = value\n    this.toString = function(){\n        return \'[\'+this.key+\'-\'+this.value+\']\'\n    }\n}\n//改写put方法\nthis.put=function(key,value){\n    var position = loseloseHashCode(key)\n    if(table[position]==undefined){\n        table[position] = new LinkedList()\n    }\n    table[position].append(new ValuePair(key,value))\n}\n//改写get方法\nthis.get=function(key){\n    var position = loseloseHashCode(key)\n    if(table[position]!==undefined){\n        var current = table[positon].getHead()\n        while(current.next){\n            if(current.element.key===key){\n                return current.element.value\n            }\n            current=current.next\n        }\n        if(current.element.key===key){\n            return current.element.key\n        }\n    }\n    return undefined\n}\n//改写remove方法\nthis.remove=function(key){\n    var  position = loseloseHashCode(key)\n    if(table[position]!==undefined){\n        var current = table[position].getHead()\n        while(current.next){\n            if(current.element.key===key){\n                table[positon].remove(current.element)\n                if(table[position].isEmpty()){\n                    table[position]=undefined\n                }\n                return true\n            }\n            current = current.next\n        }\n        if(current.element.key===key){\n            table[position].remove(current.element)\n            if(table[position].isEmpty()){\n                table[position]=undefined\n            }\n            return true\n        }\n    }\n    return false\n}\n\n```\n\n##### 线性探查\n\n```js\nthis.put = function(key,value){\n    var postion = loseloseHashCode(key)\n    if(table[position]==undefined){\n        table[position] = new ValuePair(key,value)\n    }else{\n        var index = ++position\n        while(table[index]!=undefined){\n            index++\n        }\n        table[index]=new ValuePair(key,value) \n    }\n}\nthis.get=function(key){\n    var position = loseloseHashCode(key)\n    if(table[position]!==undefined){\n        if(table[position].key===key){\n            return table[positon].value //1\n        }else{\n            var index = ++position\n     			while(table[index]===undefined||table[index].key!==key){\n            	index++\n        	}\n        	if(table[index].key===key){\n                return table[index].value //2\n            }\n        }\n    }\n}\n//this.remove和get方法基本相同，不同在于1,2,它们由table[index]=undefined代替\n```\n\n#### 创建更好的散列函数\n\n```js\nvar djb2HashCode = function(key){\n    var hash = 5381\n    for(var i = 0; i < key.length; i++){\n        hash = hash*33+key.charCodeAt(i)\n    }\n    return hash%1013\n}\n```\n\n\n\n### ES6---Map类\n\n与我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator，而不是值或键构成的数组。另一方面，我们实现的size方法返回字典中存储的值的个数，而Es6的Map类则有一个size属性。\n\n删除map中的元素可以用delete方法\n\n### ES6---WeakMap类和WeakSet类\n\n基本上，Map和Set与其弱化版本之间仅有的区别是：\n\n* WeakMap或WeakSet类没有entries、keys和values等方法\n* 只能用对象作为键\n\n创建和使用这两个类主要是为了性能。WeakMap或WeakSet是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。\n\n另外一个优点，必须用键才可以取出值。这些类没有entries、values、keys等迭代器方法，因此，除非你知道键，否则无法取出值。印证了栈那一节的做法，即使用WeakMap类封装ES6类的私有方法。\n\n## 树\n\n### 树的相关术语\n\n* 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部节点）以及0个或多个子节点。\n* 位于树顶部的节点叫作根节点。\n* 至少有一个子节点的节点称为内部节点。没有子元素的节点称为外部节点或叶节点。\n\n### 二叉树和二叉搜索树\n\n* 二叉搜索树（BST）是二叉树的一种，但是它只允许在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。\n\n#### 创建二叉搜索树\n\n```js\n//BinarySearchTree类\nfunction BinarySearchTree(){\n    //先声明其结构\n    var Node = function(key){\n        this.key=key;\n        this.left=null;\n        this.right=null;\n    }\n    var root = null;\n    //向树中插入一个新键\n    this.insert = function(key){\n        var newNode = new Node(key);\n        if(root===null){\n            root = newNode\n        }else{\n            insertNode(root,newNode);\n        }\n    }\n    //插入--辅助函数\n    this.insertNode = function(node,newNode){\n        if(newNode.key<node.key){\n            if(node.left===null){\n                node.left=newNode\n            }else{\n                insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right===null){\n                node.right=newNode\n            }else{\n                insertNode(node.right,newNode)\n            }\n        }\n    }\n}\n```\n\n#### 树的遍历\n\n##### 中序遍历\n\n```js\nthis.inOrderTraverse=function(callback){\n    inOrderTraverseNode(root,callback)\n}\nvar inOrderTraverseNode=function(node,callback){\n    if(node!==null){\n        inOrderTraverseNode(node.left,callback);\n        callback(node.key);\n        inOrderTraverseNode(node.right,callback)\n    }\n}\n```\n\n##### 先序遍历\n\n```js\nthis.preOrderTraverse=function(callback){\n    preOrderTraverseNode(root,callback)\n}\nvar preOrderTraverseNode = function(node,callback){\n    if(node!==null){\n        callback(node.key);\n        preOrderTraverseNode(node.left,callback);\n        preOrderTraverseNode(node.right,callback)\n    }\n}\n```\n\n#### 搜索树中的值\n\n```js\n//寻找树中最小键（最大键类似）\nthis.min = function(){\n    return minNode(root);\n}\nvar minNode=function(node){\n    if(node){\n        while(node&&node.left!==null){\n            node=node.left\n        }\n        return node.key\n    }\n    return null\n}\n//搜索一个特定值\nthis.search = function(key){\n    return searchNode(root,key);\n}\nvar search = function(node,key){\n    if(node===null) return false;\n    if(key<node.key){\n        return searchNode(node.left,key)\n    }else if(key>node.key){\n        return searchNode(node.right,key)\n    }else{\n        return true\n    }\n}\n```\n\n#### 移除一个节点\n\n```js\nthis.remove = function(key){\n    root = removeNode(root,key)\n}\nvar removeNode = function(node,key){\n    if(node === null) return null;\n    if(key<node.key){\n        node.left=removeNode(node.left,key)\n        return node\n    }else if(key>node.key){\n        node.right = removeNode(node.right,key);\n        return node\n    }else{\n        if(node.left===null&&node.right===null){\n            node=null;\n            return node;\n        }\n        if(node.left===null){\n            node=node.right;\n            return node;\n        }else if(node.right === null){\n            node =node.left\n            return node\n        }else{\n            var aux = findMinNode(node.right);\n            node.key=aux.key;\n            node.right=removeNode(node.right,aux.key);\n            return node;\n        }\n    }\n}\nvar findMinNode = function(node){\n    while(node&&node.left!==null){\n        node=node.left;\n    }\n    return node;\n}\n```\n\n### AVL树\n\n* AVL树是一种自平衡树。添加和移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1.添加或移除节点时，AVL树会尽可能尝试转换为完全树。\n\n#### \n\n## 排序和搜索算法\n\n### 排序算法\n\n#### 冒泡排序\n\n```js\nfunction bubbleSort(array){\n   for(var i = 0; i < array.length; i++){\n       for(var j = 0; j < array.length; j++){\n       //此处可改进，将array.length-->array.length-1-i\n           if(array[j]>array[j+1]){\n               [array[j],array[j+1]]=[array[j+1],array[j]]\n           }\n       }\n   }\n}\n```\n\n#### 选择排序\n\n```js\nfunction selectionSort(array){\n    var length = array.length, indexMin\n    for(var i = 0; i < length-1; i++){\n        indexMin = i;\n        for(var j = i; j < length; j++){\n            if(array[indexMin]>array[j]){\n                indexMin = j;\n            }\n        }\n        if(i!== indexMin){\n        	[array[i],array[indexMin]]=[array[indexMin],array[i]]\n    	}\n    }\n}\n```\n\n#### 插入排序\n\n```js\nfunction insertionSort(array){\n    var len = array.length, j, tmp;\n    for(var i = 1; i < len;i++){\n        j=i;\n        tmp=array[i];\n        while(j>0&&array[j-1]>tmp){\n            array[j]=array[j-1];\n            j--;\n        }\n        array[j]=tmp\n    }\n}\n```\n\n#### 归并排序\n\n```js\n//分治法，归并排序是递归的\nthis.mergeSort = function(){\n    array = mergeSortRec(array)\n}\nvar mergeSortRec = function(array){\n    var length = array.length\n    if(length===1) return array;\n    \n    var mid = Math.floor(length);\n    left = array.slice(0,mid);\n    right = array.slice(mid,length);\n    return merge(mergeSortRec(left),mergeSortRec(right));\n}\n\nvar merge=function(left,right){\n    var result = []\n    il = 0; ir=0;\n    while(il<left.length&&ir<right.length){\n        if(left[il]<right[ir]){\n            result.push(left[il++])\n        }else{\n            result.push(right(ir++))\n        }\n    }\n    while(il<left.length){\n        result.push(left[il++])\n    }\n    while(ir<right.length){\n        result.push(right[ir++])\n    }\n    return result;\n}\n```\n\n#### 快速排序\n\n```js\nthis.quickSort = function(){\n    quick(array,0,array.length-1);\n}\nvar quick = function(array,left,right){\n    var index;\n    if(array.length>1){\n        index=partition(array,left,right);\n        if(left<index-1){\n            quick(array,left,index-1)\n        }\n        if(right>index){\n            quick(array,index,right)\n        }\n    }\n}\nvar partition = function(array,left,right){\n    var pivot = array[Math.floor((right+left)/2)],\n        i= left, j=right;\n    while(i<=j){\n        while(array[i]<pivot){\n            i++;\n        }\n        while(array[j]>pivot){\n            j--;\n        }\n        if(i<=j){\n            swap(i,j)\n            i++;\n            j--;\n        }\n    }\n    return i;\n}\n```\n\n### 搜索算法\n\n#### 顺序搜索\n\n```js\nthis.sequentialSearch = function(item){\n    for(var i =0; i < array.length; i++){\n        if(item===array[i]){\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n#### 二分搜索\n\n```js\nthis.binarySearch = function(item){\n    this.quickSort()\n    var low = 0,high=array.length-1,mid,element;\n    while(low<=high){\n        mid=Math.floor((low+high)/2);\n        element = array[mid];\n        if(element<item){\n            low=mid+1;\n        }else if{\n            high=mid-1;\n        }else{\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n## 图\n\n### 图的相关术语\n\n### 图的表示\n\n#### 邻接矩阵\n\n#### 邻接表\n\n#### 关联矩阵\n\n### 创建Graph类\n\n### 图的遍历\n\n#### 广度优先搜索\n\n#### 深度优先搜索\n\n### 最短路径算法\n\n#### Dijkstra算法\n\n#### Floyd-Warshall算法\n\n### 最小生成树\n\n#### Prim算法\n\n#### Kruskal算法','Javascript算法与数据结构笔记',1588262400,0),(3,2,'test3','test3testlskdajfl;sakdjf;la','test3',1588003200,0),(4,3,'test3','dd','dd',1588694400,0),(5,2,'test5','ddasdf','dd',1588348800,0),(6,2,'test7','的撒发生地方sdaf','阿萨法发生',2131200,23),(7,3,'test6','dsaf','sdaf',1588003200,0);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `type`
--

DROP TABLE IF EXISTS `type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `type` (
  `Id` int NOT NULL AUTO_INCREMENT,
  `typeName` varchar(255) NOT NULL,
  `orderNum` int NOT NULL DEFAULT '0',
  `icon` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `type`
--

LOCK TABLES `type` WRITE;
/*!40000 ALTER TABLE `type` DISABLE KEYS */;
INSERT INTO `type` VALUES (1,'视频教程',1,'youtube'),(2,'精彩视频',2,'message'),(3,'快乐生活',3,'smile');
/*!40000 ALTER TABLE `type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping routines for database 'react_blog'
--
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-05-28 11:16:31
