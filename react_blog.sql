/*
 Navicat Premium Data Transfer

 Source Server         : react_blog
 Source Server Type    : MySQL
 Source Server Version : 50648
 Source Host           : localhost:3306
 Source Schema         : react_blog

 Target Server Type    : MySQL
 Target Server Version : 50648
 File Encoding         : 65001

 Date: 14/11/2020 13:43:10
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admin_user
-- ----------------------------
DROP TABLE IF EXISTS `admin_user`;
CREATE TABLE `admin_user`  (
  `Id` int(11) NOT NULL,
  `userName` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`Id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of admin_user
-- ----------------------------
INSERT INTO `admin_user` VALUES (1, 'sampson', '123456');

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `Id` int(11) NOT NULL AUTO_INCREMENT,
  `type_id` int(11) NOT NULL DEFAULT 0,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `article_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `introduce` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `addTime` int(11) NOT NULL DEFAULT 0,
  `view_count` int(11) NULL DEFAULT 0,
  PRIMARY KEY (`Id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 21 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 7, 'Java程序设计', '# Java 程序设计笔记\n\n**第一行代码HelloWorld**\n\n```java\npublic class Hello{\n    public static void main(String args[]){\n        System.out.println(\'Hello,World!\')\n    }\n}\n```\n\n\n\n## 标识符与简单数据类型\n\n**标识符**：用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列称为标识符。\n\n**关键字**：Java语言中已经被赋予一些特殊意义的单词。\n\n**简单数据类型**：\n\n* **逻辑类型**：boolean\n* **整型**：byte（1）、short（2）、int（4字节）、long（8）【一个字节为8位，比如int类型的取值范围为：-2^31^~2^31^-1】\n* **字符类型**：char(2字节，0~65535)\n* **浮点类型**：float、double\n* **精度**从低到高：byte、short、char、int、long、float、double；**高级别变量转为低级别需要强制转换**。\n\n**输入和输出**\n\n* **输入**\n\n  包括：nextBoolean()、nextByte()、nextShort()、nextInt()、nextLong()、nextFloat()、nextDouble()\n\n  示例：\n\n  ```java\n  import java.util.Scanner; //第一步\n  public class Example{\n      public static void main(String args[]){\n          People zhangSan = new People();\n          Scanner reader = new Scanner(System.in); //第二步\n          System.out.println(\'请输入年龄，回车确认\');\n          zhangSan.age = reader.nextInt();  //第三步\n          System.out.println(\'输入体重，回车确认\');\n          zhangSan.weight = reader.nextFloat();//第三步\n          zhangSan.speak();\n      }\n  }\n  ```\n\n  另外，Scanner对象可以调用hasNextXXX()方法判断用户输入的数据的类型。\n\n  在从键盘输入数据时，我们经常让render对象先调用 hasNextXXX() 方法等待用户在键盘输入数据，然后再调用 nextXXX() 方法读取数据。\n\n  比如：\n\n  ```java\n  while(reader.hasNextDoublbe){\n  	double x = reader.nextDouble();\n  }\n  ```\n\n* 输出\n\n  System.out.println(‘###’)、System.out.print(‘##’)、System.out.printf(‘%d’, var)\n\n## 运算符、表达式与语句\n\n### **运算符与表达式**\n\n* 算术运算符：+ - * / %\n* 自增自减：++x(x++)  –x (x–)\n* 关系运算符：> < >= <= == !=\n* 逻辑运算符：&& || ！\n* 赋值运算符： =\n* 位运算符：| & ！^\n* instanceof运算符：该运算符是二目运算符，左面的操作元是一个对象，右面是一个类。当左面的对象是右面的类或子类创建的对象时，该运算符的结果为true，否则为false。\n\n### **语句**\n\n* if语句、if-else 语句、if-else if-else语句\n\n* switch开关语句\n\n  ```java\n  switch(表达式) #表达式的值可以是byte，short、int或char\n  {\n      case 常量值1:\n          若干语句;\n          break;\n      case 常量值2:\n          ……\n      case 常量值N:\n          若干语句;\n          break;\n      default:\n          若干语句；\n  }\n  ```\n\n* while语句、do-while循环\n\n### **数组**\n\n* 一维数组：int[] arr = new int [30]，int arr[] = new int [] ，int arr[] = new int [size],  float arr[] = { 21.3f, 23.5f, 2.0f }  数组元素的类型可以是Java的任何一种类型。\n\n* 二维数组：`int b[][] = {{1},{1,2},{1,3,4}}`，可以直接用若干个一维数组初始化一个二维数组，这些一维数组的长度不尽相同。\n\n* `int b[][] =  new int b[3][4]; b.length = 3;`\n\n* 创建数组后，系统会给数组的每个元素一个默认的值，在声明数组的同时也可以给数组的元素一个初始值。\n\n* 数组属于**引用型变量**，因此两个相同类型的数组如果具有相同的引用，它们就有完全相同的元素。\n\n* 【注意】：char型数组必须让数组和字符串做并置运算才能输出其引用，否则输出其全部元素的值\n\n  ```java\n  int a [] = {1,2,3,4}\n  char b [] = {\'您\',\'好\',\'中\',\'国\'}\n  \n  System.out.println(a); //a的引用\n  System.out.println(b); //b的全部元素的值：您好中国\n  System.out.println(\"\"+b) //b的引用\n  ```\n\n* **遍历数组：**\n\n  ```java\n  int a[] = {1,2,3,4}\n  //基于循环语句的遍历\n  for(int ch: a){\n      ···\n  }\n  for(int i = 0; i < a.length; i++){\n  }\n  //使用toString()方法遍历\n  import java.util.Arrays;\n  System.out.println(Arrays.toString(a))\n  ```\n\n  \n\n## 类与对象\n\n>封装性：面向对象编程核心思想之一就是将数据和对数据的操作封装在一起。通过抽象，即从具体的实例中抽取共同的性质形成一般的概念，例如对类的概念。\n>\n>继承性：继承性体现了一种先进的编程模式。子类可以继承父类的属性和功能，即继承了父类具有的数据上的操作，同时又可以增添子类独有的数据和数据上的操作。\n>\n>多态性：①一种是操作名称的多态，即有多个操作具有相同的名字，但这些操作所接受的信息类型必须不同。所谓操作名称的多态是指可以向操作传递不同的消息，以便让对象根据相应的消息来产生一定的行为。②另一种多态是和继承有关的多态，是指同一个操作被不同类型对象调用时可能产生不同的行为。\n\n### 类\n\n类是Java语言中最重要的“数据类型”，类声明的变量被称为对象，即类是用来创建对象的“模版”。\n\n类是Java语言中最重要的“数据类型”，类声明的变量被称为对象，\n\n```java\nclass 类名{\n    类体的内容\n}\n\nclass A{\n    int a = 12;  //声明成员变量时可以同时赋予初值\n    /*\n    int b;   //非法\n    b=11;\n    */\n    void f(){\n        int a;\n        a = 33;\n        System.out.println(a); //33\n	}\n}\n```\n\n类体由两部分构成：\n\n* **变量的声明**： 用来描述数据（体现对象的属性）。成员变量的类型可以是Java中任何一种数据类型，包括基本类型：整型、浮点型、字符型；引用类型：数组、对象、接口。成员变量在整个类中都有效，其有效性与它在类体中书写的先后位置无关。\n\n* **方法**： 方法可以对类中声明的变量进行操作，即给出算法（体现对象具有的功能）。\n\n  * 方法的**声明**包括方法名和方法返回的类型。不需要返回数据时，返回的类型是void\n\n    ```java\n    double getSpeed() {\n        reutnr speed;\n    }\n    ```\n\n  * 在**方法体**中声明的变量和方法的参数被称为**局部变量**。和类的**成员变量**不同的是，局部变量只在声明它的方法内有效，而且与其声明的位置有关。方法的声明在整个方法内有效，方法内的局部变量从声明它的位置之后开始有效。\n\n  * 如果局部变量的名字和成员变量的名字相同，则成员变量被隐蔽。如果想在该方法中使用被隐蔽的成员变量，必须使用关键字 **this**\n  \n  * 局部变量定义后需要赋初值，成员变量有默认值。\n  \n* 类的UML图\n\n  * 第一层：名字层\n  * 第二层：变量层（属性层）\n  * 第三层：方法层（操作层）\n\n### 构造方法与对象的创建\n\n> 用类声明的变量被称为**对象**。与基本数据类型不同，在用类声明对象后，还必须要创建对象，即为声明的对象分配变量，当时用一个类创建一个对象时，也给出了这个类的一个实例。\n\n**构造方法**：构造方法是类中的一种特殊方法，当程序用类创建对象时需要使用它的方法。**类中的构造方法的名字必须与它所在的类的名字完全相同，而且没有类型**。允许一个类中编写若干个构造方法，但必须保证他们的参数不同，即参数的个数不同，或者是参数的类型不同。如果没有编写构造方法，系统会默认该类只有一个构造方法，该默认的构造方法是无参数的，且方法体中没有语句。如果类中定义了一个或多个构造方法，那么Java不提供默认的构造方法。\n\n**对象的创建**：比如有一个People 类，`People KY = new People();`\n\n**对象的内存模型**\n\n* `People KY;`, 声明变量对象后，变量对象的内存中还没有任何数据，称这时的对象是一个空对象，空对象不能使用，因为它还没有得到任何“实体”，必须再进行为对象分配变量的步骤，即为对象分配实体。\n  * `KY = new People()`,对象分配变量后，①首先系统会为类中的*成员变量*分配内存空间，然后执行*构造方法*中的语句。如果成员变量在声明时没有指定初值，使用的构造方法也没有对成员变量进行初始化操作，那么，会赋予这些成员变量默认初始值。②给出一个信息，确保这些成员变量是属于对象KY的，即这些内存单元将由对象KY操作管理。为了做到这一点，new运算符在为这些成员变量分配内存后，将返回一个引用给对象变量KY。所谓为对象分配内存就是指为它分配变量，并获得一个引用，以确保这些变量由它来“操作管理”。③一个类通过使用new运算符可以创建多个不同的对象，这些对象将被分配不同的内存空间，因此，改变一个对象的状态不会影响到其他对象的状态。\n\n**对象的使用**\n\n* 抽象的目的是产生类，而类的目的是*创建具有属性和功能的对象*。对象不仅可以操作自己的变量改变状态，而且能调用类中的方法产生一定的行为。\n\n* 对象创建之后，就有了自己的变量，即对象的实体。通过使用“.”，对象可以对自己的变量访问。\n* 类中的方法可以操作成员变量，当对象调用该方法时，方法中出现的成员变量就是指该对象的成员变量。\n\n**对象的引用和实体**\n\n分配给对象的变量习惯地称为实体\n\n* 没有实体的对象称为空对象，空对象不能使用。\n* 垃圾回收：Java具有所谓的“垃圾收集”机制，这种机制周期的检测某个实体是否已不再被任何对象引用，如果发现这样的实体，就释放实体占有的内存。\n\n### 参数传值\n\n> 方法中最重要的部分之一就是方法的参数，参数属于局部变量，当对象调用方法时，参数被分配内存空间，并要求调用者向参数传递值，即方法被调用时，参数变量必须有具体的值。\n\n* Java中所有的参数都是“**传值**”的，也就是说，方法中参数变量的值是指调用者指定值的**复制**。\n* 对于基本数据类型的参数，向该参数传递的值的级别不可高于该参数的级别。\n* 当参数是*引用类型*时，“传值”传递的是变量中存放的“**引用**”，而不是变量引用的实体。对于两个同类型的引用型变量，如果具有同样的引用，就会用同样的实体，因此，如果改变参数变量中存放的“引用”，就会导致原变量的实体发生同样的变化。\n\n### 实例成员与类成员\n\n**实例变量与类变量**\n\n> 类体中包括成员变量的声明和方法的定义，而成员变量又可细分为实例变量和类变量。在声明成员变量时，用**关键字static给予修饰的称为类变量**，也称为静态变量。\n\n* 分配给不同的对象的**实例变量**占有不同的内存空间，改变其中一个对象的实例变量不会影响其他对象的实例变量。\n* 如果类中有**类变量**，当使用new运算符创建多个不同的对象时，分配给这些对象的这个类变量**占有相同的一处内存**，改变其中一个对象的类变量会影响其他对象的这个类变量。也就是说对象共享类变量。\n* 类中的类变量在该类被加载到内存中时，就分配了相应的内存空间。\n* 类变量不仅可以通过某个对象访问，也*可以通过类名访问*。实例变量可以通过对象访问，不能使用类名访问。\n* 【注】：类变量似乎破坏了封装性，其实不然，当对象调用实例方法时，该方法中出现的类变量也是该对象的变量，只不过这个变量和所有的其他对象共享而已。\n\n**实例方法和类方法**\n\n> 方法声明时，方法类型前面不加static修饰的是实例方法。\n\n* 当类的字节码文件被加载到内存的时候，**类的实例方法**不会分配入口地址，只有该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类中创建的任何对象调用执行。\n* 【注】：当我们创建第一个对象时，类中的实例方法就分配了入口地址，再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地之才被取消。\n* 实例方法不仅可以操作实例变量，也可以操作类变量。\n* 对于类中的类方法，在该类加载到内存时，就分配了相应的入口地址。类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。\n* 实例方法不可以通过类名调用，而类方法可以。\n* **类方法不可以操作实例变量**，因为在类创建对象之前，实例成员变量还没有分配内存。\n* 如果一个方法不需要操作实例成员变量就可以实现某种功能，就可以考虑将这样的方法声明为类方法。这样可以避免创建对象浪费内存。\n\n### 方法的重载和多态\n\n> Java中存在两种多态：重载（overload）和重写（override）。\n\n* 所谓功能多态性是指可以向功能传递不同的信息，以便让对象根据相应的消息来产生相应的行为。对象的功能通过类中的方法来体现，那么功能的多态性就是方法的**重载**。\n* 方法的**重载**意思是**一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。**\n* 【注】：方法的返回类型和参数的名字不参与比较，也就是说如果两个方法的名字相同，即使类型不同，也必须保证参数不同。\n\n### this关键字\n\n> this 是Java的一个关键字，表示某个对象。this可以出现在实例方法和构造方法中，但不可以出现在类方法中。\n\n* this关键字出现在类的构造方法中时，代表使用该构造方法创建的对象。\n* 实例方法必须只能通过对象来调用，不能用类名来调用。当this关键字出现在实例方法中时，代表正在调用该方法的当前对象。\n* 实例成员变量在实例方法中出现时：this.成员变量；\n* static成员变量在实例方法中出现时：类名.成员变量。\n* 通常可以省略 this. 和 类名. ；但当实例成员变量的名字和局部变量名字相同时，不可省略。\n* 类的实例方法可以调用类的其他方法，对于实例方法调用的默认格式：this.方法 （this.可省略）\n* 【注】：this 不能出现在类方法中，因为，类方法可以通过类名直接调用，这是，可能还没有任何对象诞生。\n\n### 包\n\n> 包是 Java 语言中有效地管理类的一个机制。不同 Java 源文件中可能出现名字相同的类如果想区分这些类，就需要使用包名。\n\n* 语法： package 包名;\n* 如果一个类有包名，那么就不能在任意位置存放它，否则虚拟机将无法家在这样的类。\n* 比如使用： package tom.jiafei； 那么存储文件的目录结构必须包含有这样的结构：…\\tom\\jiafei；\n* 如果源程序省略了包名，源文件中所定义命名的类被隐含认为是无名包的一部分，只要这些类的字节码被存放在相同的目录中，那么它们就属于同一个包。\n\n### 访问权限\n\n访问限制修饰符有 private、protected、public，都是Java的关键字。\n\n【注】：在编写类的时候，类中的实例方法总是可以操作该类中的实例变量和类变 量；类中的类方法总是可以操作该类中的类变量，与访问限制符没有关系。\n\n* 用关键字 **private** 修饰的成员变量和方法称为私有变量和私有方法。在另一个类中用某个类创建了一个对象后，该对象不能访问自己的私有变量和私有方法。如果类中某个成员是私有类变量（方法），那么在另外一个类中，也不能通过类名来操作（调用）这个私有类变量（方法）。\n* 用关键字 **public** 随时的成员变量和方法称为共有变量和共有方法。\n* 不用 public、protected、private 修饰符的成员变量和方法被称为 **友好变量**和**友好方法**；同一个包能访问。\n* 用 **protected** 修饰的成员变量和方法被称为受保护的成员变量和受保护的方法，同一个包能访问。子类可访问。\n* 不能用protected、private修饰类，可以用public修饰（public类），或不加public（友好类）。\n* 访问限制符按访问权限从高到低排列顺序：public、protected、友好的、private。\n\n### 基本类型的类包装\n\n> Java 提供了基本数据类型相关的类，实现了对基本数据类型的封装。这些类在 java.lang 包中，分别是：Byte,Interger, Short, Long, Float, Double,Character类。\n\n下述构造方法分别可以创建Double、Float、Byte、Integer、Short、Long 类型的对象。\n\n- Double(double num);\n\n- Float(Float num)\n\n- Short(short num)\n\n- Byte(byte num)\n\n- …\n\n\n使用xxxValue()方法可以返回该对象含有的xxx型数据。\n\n### 可变参数\n\n- 可变参数是指在声明方法时不给出参数列表中从某项直至最后一项参数的名字和个数，但这些参数的类型必须相同。\n- 可变参数使用“···”表示若干个参数，这些参数的类型必须相同，最后一个参数必须是参数列表中的最后一个参数。\n- 例如：\n\n```java\npublic void f(int ···x)\n```\n\n\n\n## 子类与继承\n\n> 继承是一种已有的类创建新类的机制\n\n### 子类与父类\n\n* 由继承得到的类称为**子类**，被继承的类称为**父类（超类）**。\n\n* 利用继承可以先创建一个共有属性的一般类，根据该类再创建具有特殊属性的新类，新类继承一般类的状态和行为，并根据需要增加自己的新的状态和行为。\n\n* 格式：\n\n  ```java\n  class 子类名 extends 父类名{\n      ···\n  }\n  ```\n\n* 如果一个类中没有使用extends关键字，这个类被系统默认是 **Object 的子类**，Object是java.lang 包中的类。\n\n### 子类的继承\n\n> 一个子类继承的成员应当是这个类的完全意义的成员。\n\n* 如果子类和父类在同一个包中，那么子类自然的继承了父类中不是private的成员变量和方法作为自己的成员变量和方法，继承的成员或方法的访问权限保持不变。\n* 当子类和父类不在同一个包中时，父类中的private和友好访问权限的成员变量不会被子类继承。\n\n### 成员变量的隐藏和重写\n\n* 如果声明的成员的变量的名字和从父类继承来的成员变量**名字相同**（声明的类型可以不同），在这种情况下，子类就会隐藏掉继承的成员变量。【注意】：子类对象仍然可以调用从父类继承的方法操作隐藏的成员变量。\n* 子类通过**重写**可以隐藏已继承的实例方法（方法重写也称方法覆盖）。\n* **方法的重写**是指：子类中定义一个方法，这个方法的类型和父类的方法的类型一致或者是父类的方法的类型的子类型（所谓子类型是指：如果父类的方法的类型是“类”，那么允许子类的重写方法的类型是“子类”）一致，并且这个**方法的名字**、**参数个数**、**参数类型**和父类的方法完全相同。子类如此定义的方法称为子类重写的方法(不属于新增的方法)。\n* 重写方法既可以操作继承的成员变量、调用继承的方法，也可以操作子类新声明的成员变量、调用新定义的其他方法，但无法操作被子类隐藏的成员变量和方法。如果子类想使用被隐藏的成员变量或方法，**必须使用super关键字**。\n* 重写父类的方法时，不可以降低方法的访问权限，但可以提高。\n\n### super 关键字\n\n> 子类一旦隐藏了继承的成员变量和方法，那么子类创建的对象就不再拥有该变量和方法，该变量和方法归关键字super拥有。\n>\n> 子类的构造函数 super()；\n>\n> 子类的其他函数中使用 super().Member super\n\n* 如果在子类中想使用被子类隐藏的成员变量或方法就需要使用关键字super。\n* 当用**子类的构造方法**创建一个子类对象时，子类的构造方法总是先调用父类的某个构造方法。（如果子类没有显示指出使用父类那个构造方法，子类就调用父类不带参数的构造方法）。\n* 由于**子类不继承父类的构造方法**，所以，**子类在其构造方法中需要使用 super 关键字来调用父类的构造方法**，而且super必须是子类构造方法的头一条语句。如果没有明显写出，默认有 `super();`\n* 在父类中定义多个构造方法时，应当包括一个不带参数的构造方法。\n\n### final 关键字\n\n> final 关键字可以修饰类、成员变量和方法中的局部变量。\n\n* 可以使用 final 将类声明为final 类。final 类不能被继承，即不能有子类。比如Java提供的 String 类。\n* 如果final修饰父类中的一个方法，那么这个方法不允许子类重写。子类可以访问。\n* 如果成员变量或局部变量被修饰为 final 的，就是常量。声明常量时必须指定该常量的值。\n\n### 对象的上转型对象\n\n假设，A 类是 B 类的父类，当用子类创建一个对象，并把这个对象的引用放到父类的对象中时，例如\n\n```java\nA a;\na = new B();\n//或者\nA a;\nB b = new B();\na = b;\n```\n\n这时，称对象 a 是对象 b 的上转型对象。\n\n* 对象的上转型对象的实体是子类负责创建的，但**上转型对象会失去原有对象的一些属性和功能。**\n  * 上转型对象不能操作子类新增的成员变量；不能调用子类新增的方法。\n  * 上转型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或**子类重写**的实例方法。\n* 可以将对象的上转型对象**再强制转换到一个子类对象**，这时，该子类对象又**具备了子类所有属性和功能**。\n* **不可以将父类创建的对象的引用赋值给子类声明的对象**。\n* 如果子类重写了父类的静态方法，那么子类对象的上转型对象不能调用子类重写的静态方法，只能调用父类的静态方法。\n\n### 继承与多态\n\n* 当一个类有很多子类时，并且这些**子类都重写了父类中的某个方法**。那么当我们**把子类创建的对象的引用放到父类的一个对象中**时，就得到了该对象的一个**上转型对象**。那么**这个上转型对象在调用这个方法时就可能有多种形态**，因为不同的子类再重写父类的方法时就可能产生不同的行为。\n* **多态性**就是指父类的某个方法被其子类重写时，可以各自产生自己的功能行为。\n\n### abstract 类和 abstract 方法\n\n- 当用关键字 abstract 修饰的类称为 abstract 类（抽象类）。如：\n 	```java\n  abstract class A{\n   	···\n  }\n  ```\n- 用关键字 abstract 修饰的方法称为 abstract 方法（抽象方法），如：\n\n```Java\nabstract int main(int x, int y);\n```\n\n  	对于 abstract 方法，只允许声明，不允许实现（没有方法体），而且还不允许使用 final 和 abstract 同时修饰一个类。\n\n* 和普通的类相比，**abstract 类中可以有 abstract 方法，也可以有非 abstract 方法**。\n\n  ```java\n  abstract class A{\n      abstract int min(int x, int y); //abstract 方法\n      int max(int x, int y){          //普通方法\n          return x>y?x:y;\n      }\n  }\n  ```\n\n* **abstract 类不能使用 new 运算符创建该类的对象**。如果一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体。（这就是为什么 final 和 abstract 不能同时修饰一个方法或类的原因）。\n\n* abstract 类也可以没有abstract 方法；如果一个 abstract 类是 abstract 类的子类，它可以重写父类的 abstract 方法，也可以继承这个 abstract 方法。\n\n* 可以定义抽象类的引用，但不能实例化new\n\n### 面向抽象编程\n\n> 在设计程序时，经常会使用 abstract 类，原因是abstract类只关心操作，但不关心这些操作的具体实现细节（将这些细节留给子类的设计者）。\n\n* 例如：在设计地图时，首先考虑地图最重要的轮廓，不必去考虑诸如城市中的某街道牌号等细节，**细节应当由抽象类的非抽象子类去实现**，这些子类可以给出具体的实例，来完成程序的某些功能。\n* 在设计一个程序时，可以通过abstract类中声明若干个abstract方法，表明这些方法在整个系统设计中的重要性，方法体的内容细节由它的非abstract子类去完成。\n* 使用多态进行程序设计的核心技术之一是使用上转型对象，即将abstract类声明对象作为其子类的上转型对象，那么这个上转型对象就可以调用子类重写的方法。\n* 所谓面向抽象编程，是指当设计某种重要的类时，不让该类面向具体的类，而是面对抽象的类，级设计类中的重要数据是抽象类声明的对象，而不是具体类声明的对象。\n\n### 开-闭原则\n\n> 所谓开-闭原则（Open-Closed Principle）就是让设计的系统应当对扩展开放，对修改关闭。\n\n\n\n## 接口与实现\n\n### 接口\n\n```java\ninterface Printable {\n	final int MAX = 100;\n    void add();\n    float sum(float x, float y);\n}\n```\n\n**接口声明**：interface 接口的名字\n\n**接口体**：接口体中包含常量的声明（没有变量）和抽象方法两部分。接口体中只有**抽象方法**，没有普通的方法，而且结构体中所有的常量的访问权限一定都是**public**（允许省略public、final修饰符），所有的抽象方法的访问权限一定都是public（允许省略public、abstract修饰符）\n\n### 实现接口\n\n> 接口由内去实现，以便使用接口中的方法。\n\n* 一个类可以实现多个接口类，类通过使用关键字implements声明自己实现一个或多个接口。\n\n```java\nclass A implements B,C //实现多个接口，用逗号分割\nclass A extends B implements C,D // B的子类A类实现C和D接口\n```\n\n* 如果一个非抽象类实现了某个接口，那么这个类必须重写该接口的所有方法\n\n* 注意：由于接口中的方法一定是public abstracts方法，所以非抽象类在重写接口方法时不仅要去掉abstract修饰给出方法体，而且方法的访问权限一定要明显的用public来修饰（否则就降低了访问权限，这是不允许的）\n\n* 实现接口的非抽象类一定要重写接口的方法，因此也称这个类实现了接口中的方法。\n\n* java提供的接口都在相应的包中，通过import语句不仅可以引入包中的类，也可以引入包中的接口。\n* 类重写的接口方法以及接口中的常量，可以被类的对象调用，而且常量的也可以用接口名直接调用。\n* Public接口可以被任何一个类实现，如果一个接口不加public修饰就称为友好接口类，友好接口可以被与该接口在同一包中的类实现\n* 如果父类实现了某个接口，那么子类就自然实现了该接口，子类不必再显示的使用关键字implements声明实现这个接口\n* 接口也可以被继承，既可以通过关键字extends声明一个接口是另一个接口的子接口，由于接口中的方法和常量都是public，子接口将继承父接口中的全部方法和常量\n* 注意：如果一个类声明实现一个接口，但没有重写接口中的所有方法，那么这个类必须是abstract类\n\n### 理解接口\n\n* 接口只关心操作，并不关心操作的具体实现，即只关心方法的类型、名称和参数，但不关心方法的具体行为（接口中只有abstract方法）。实现同一个接口的两个类就会具有接口规定的方法，但方法内部的细节（方法体的内容）可能不同。\n* 不同类可以实现相同的接口，同一个类也可以实现多个接口。但不希望某些类通过继承使得他们具有一些相同的方法时，就可以考虑让这些类来去实现相同的接口而不是把他们声明为同一个类的子类\n\n### 接口回调\n\n> 用接口声明的变量称为接口变量。\n\n* 接口属于引用型变量，接口变量中可以存放实现该接口的类的实例的引用，即存放对象的引用\n\n* “接口回调”表示一个变量的地址，在某一个时刻存放在一个指针变量中，那么指针变量就可以操作该变量中存放的数据\n* 在java中，接口回调是指可以把实现某一接口的类创建的对象的引用赋给该接口声明的接口变量中，那么该接口变量就可以调用被类实现的接口方法，\n* 注意：接口无法调用类中的其他非接口方法\n\n### 接口与多态\n\n* 由接口产生的多态就是指不同的类在实现同一接口时可能具有不同的实现方式，那么接口变量在回调接口方法时就可能具有多种形态。          \n\n## 内部类与异常类\n\n### 内部类\n\n```java\nOuter$Inner.class\n```\n\n* Java支持在一个类中声明另一个类，这样的类称作内部类，而包含内部类的类称为内部类的外嵌类。\n* 内部类的外嵌类的成员变量在内部类中仍然有效，内部类中的方法也可以调用外嵌类中的方法。\n* 内部类的类体中不可以声明类变量和类方法。外嵌类的内体中可以用内部类声明对象，作为外嵌类的成员。\n* 内部类仅供它的外嵌类使用，其他类不可以用某个类的内部类声明对象。\n* 另外由于内部类的外嵌类的成员变量在内部类中仍然有效，使得内部类和外圈内的交互更加方便，\n* 【注意】：Java编译器生成的内部类的字节码文件的名字和通常的类不同，内部类对应的字节码文件的名字格式是“外嵌类名$内部类名“\n* ![image-20200417141926323](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200417141926323.png)\n\n\n\n### 匿名类\n\n```java\nOuter$1.class   Outer$2.class\n```\n\n#### 和子类有关的匿名类\n\nJava允许我们直接使用一个类的子类的**类体**创建一个子类对象，也就是说，创建子类对象时，除了使用父类的构造方法外还有类体，**此类体被认为是一个子类去掉内声明后的类体，称作匿名类**。匿名类就是一个子类，由于无名可用，所以不可能用匿名类声明对象，但却可以直接用匿名类创建一个对象。\n\n假设Bank是一个类，那么下列代码就是用bank的一个子类（匿名类）创建对象：\n\n```java\nnew Bank() {\n	//匿名类的类体\n}\n```\n\n因此匿名类可以继承父类的方法，也可以重写父类的方法。使用匿名类时，必然是在某个类中直接用匿名类创建对象，因此匿名类一定是内部类，匿名类可以访问外嵌类中的成员变量和方法。匿名类的类体中不可以声明static成员变量和static方法。\n\n由于匿名类是一个子类，但没有类名，所以在用匿名类创建对象时，要直接使用父类的构造方法。\n\n尽管匿名类创建的对象没有经过类声明步骤，但匿名对象的引用可以传递给一个匹配的参数，匿名类的常用的方式是向方法的参数传值。\n\n例如：用户程序中的一个对象需要调用如下方法。\n\n```java\nvoid f(A a){\n}\n```\n\n该方法的参数类型是A类，用户希望向方法传递A的子类对象，但系统没有提供符合要求的子类，那么用户在编写代码时就可以考虑使用匿名类。\n\n传递给匿名的内部的参数-》final\n\n#### 和接口有关的匿名类\n\n假设Computable是一个接口，那么java允许直接用接口名和一个类体创建一个匿名对象，此类体被认为是实现了Computable接口的类去掉类声明后的类体，称作匿名类，下列代码就是用实现了Computable接口的类（匿名类）创建对象。\n\n```java\nnew Computable(){\n    //实现接口的匿名类类体\n}\n```\n\n如果某个方法的参数是接口类型，那么可以使用接口名和类名组合创建一个匿名对象传递给方法的参数，类体必须要重写接口中的全部方法，例如对于\n\n```java\nvoid f(Computable x)\n```\n\n其中的参数x是接口，那么在调用f时可以向f的参数x传递一个匿名对象，例如\n\n```java\nf(new Computable(){\n    //实现接口的匿名类的类体\n})\n```\n\n![image-20200417142414930](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200417142414930.png)\n\n### 异常类\n\n所谓异常就是程序运行时可能出现一些错误，例如试图打开一个根本不存在的文件等，异常处理将会改变程序的控制流程，让程序有机会对错误做出处理。\n\nJava的异常出现在方法调用过程中，其在方法调用过程中抛出异常对象，终止当前方法的继续执行，同时导致程序运行出现异常，并等待处理。\n\n异常对象可以调用如下方法，得到或输出有关异常的信息\n\n* public String getMessage();\n* public void printStackTrace();\n* public String toString();\n\n#### try-catch 语句\n\njava使用try-catch语句来处理异常，将可能出现的异常操作放在try-catch语句的try部分，当try部分中的某个方法调用发生异常后，try部分将立即结束执行而转向执行相应的catch部分，所以程序可以将发生异常后的处理放在catch部分，try-catch语句可由几个catch组成，分别处理发生的相应异常。\n\n基本格式如下：\n\n```java\ntry{\n    包含可能发生异常的句子\n}\ncatch(ExceptionSubClass1 e){\n    …\n}\ncatch(ExceptionSubClass2 e){\n    …\n}\n```\n\n各个catch参数中的异常类都是Exception的某个子类，表明try部分可能发生的异常，这些子类之间不能有父子关系，否则保留一个含有父类参数的catch即可。\n\n#### 自定义异常类\n\n在编写程序时可以拓展Exception类，定义自己的异常类，然后根据程序的需要来规定哪些方法产生这样的异常。\n\n一个方法在声明时可以使用throws关键字声明要产生的若干个异常，并在该方法的方法体中具体给出产生异常的操作，即用相应的异常类创建对象，并使用throw关键字抛出该异常对象，导致该方法结束执行。\n\n程序必须在try-catch语句中调用能发生异常的方法，其中catch的作用就是捕获throw方法抛出的异常对象。\n\n【注意】throw是java的关键字，该关键字的作用就是抛出异常throw和throws是两个不同的关键字。\n\n#### finally 子语句\n\n语法格式：\n\n```java\ntry{}\ncatch(ExceptionSubClass e){}\nfinally{}\n```\n\n其执行机制是:在执行try-catch语句后执行finally子语句，也就是说无论在try内部是否发生异常,finally子语句都会被执行\n\n但需要注意以下两种特殊情况\n\n* 如果在try-catch语句中执行了return语句，那么finally子语句仍然会被执行。\n* try-catch语句执行了程序退出代码，即执行System.exit(0)；，则不执行finally子语句（当然包括其后的所有语句）\n\n### 断言\n\n断言语句在调试代码阶段非常有用，断言语句一般用于程序不准备通过捕获异常来处理的错误。\n\n例如，当发生某个错误时，要求程序必须立即停止执行，在调试代码阶段让断言语句发挥作用，这样就可以发现一些致命的错误，当程序正在运行时就可以关闭断言语句，但仍把断言语句保留在源代码中，如果以后应用程序又需要调试，可以重新启用断言语句。\n\n使用关键字assert声明一条断言语句，断言语句有以下两种格式：\n\n* assert booleanExpression;\n* assert booleanExpression:messageException;\n\n其中booleanExpression要求必须是求值boolean型的表达式，Messageexception可以是求职字符串的表达式。\n\n如果使用asserts booleanExpression; 形式的断言语句，当booleanExpression的值是false时，程序从断言语句处停止执行，并输出messageException表达式的值，提示用户出现了怎样的问题；当messageException的值是true时，程序从断言语句处继续执行。\n\n当使用java解释器直接运行程序时，默认地关闭断言语句，在调试程序时可以使用-ea启用断言语句。例如：`java -ea mainClass`\n\n## 常用实用类\n\n### String类\n\n> Java专门提供了用来处理字符序列的String类，因此Java程序可以使用String类的对象来处理有关字符序列。\n>\n> String类在java.lang包中，由于java.lang中的类被默认引入，因此程序可以直接使用String\n>\n> 需要注意的是java把String类声明为final类，因此用户不能拓展String类，即String类不可以有子类\n\n#### 构造字符串对象\n\n可以使用String类来创建一个字符串变量，字符串变量是对象。\n\n**字符串对象**\n\n```java\nString s = new String(\"lalala\");\nString t = new String(s); //可以用一个已创建的字符串创建另一个字符串\nchar a = {\'j\',\'a\',\'v\',\'a\'}\nString s = new String(a);//用一个字符数组a创建一个字符串对象，相当于 String s = new String(\"java\");\nchar a[] = {\'A\',\'B\',\'C\',\'D\',\'E\'}\nString s = new String(a, 2, 3); //相当于String s = new String(\"CDE\")\n```\n\n**引用字符串常量对象**\n\n字符串常量是对象，因此可以把字符串常量的引用赋给一个字符串变量。\n\n```java\nstring s1,s2;\ns1 = \"how are you\";\ns2 = \"how are you\";\n```\n\n这样s1，s2具有相同的引用，而且具有相同的实体。\n\n#### String类的常用方法\n\n* public int length()：获取一个字符串长度\n* public boolean equals(String s)：比较当前字符串对象的**实体**是否与参数s指定的字符串的实体相同。public boolean equalsIgnoreCase(String s)忽略大小写。\n* public boolean startsWith(String s)、public boolean endsWith(String s)：判断当前字符串对象的前（后）缀是否是参数s指定的字符串。\n* public int compareTo(String s)：按字典序与参数s指定的字符串比较大小。相同返回0，当前字符串对象大于s，返回正值，否则返回负值。public int compareToIgnoreCase(String s)忽略大小写。\n* public boolean contains(String s)：判断当前字符串对象是否含有参数指定的字符串s。\n* public int indexOf(String s)：从当前字符串的头开始检索字符串s，并返回首次出现s的引位置。如果没有返回-1。indexOf(String s, int startpoint)从startpoint处开始检索。\n* public String substring(int startpoint)：获得一个当前字符串的子串，从startpoint到最后。substring(int start, int end)从start到end不包括end位置。\n* public String trim()：得到一个去掉前后空格的字符串。\n* public static int parseInt(String s)：将由数字组成的字符串转为int型数据。\n* public static String valueOf(int n)：将数值字符串转为数值\n* public void getChars(int start, int end, char c[], int offset)：将字符串（start->end-1）存放到数组(从offset处开始)中。必须保证数组c能容纳被复制的字符。\n* public char[] toCharArray()：将字符串中全部字符存放在一个字符数组中。\n* public boolean marches(String regex)：判断当前字符串对象是否和参数regex指定的正则表达式匹配。\n* public String replaceAll(String regex, String replacement)：返回一个字符串，该字符串是当前字符串中所有和参数regex指定的正则表达式匹配的子字符串被参数replacement指定的字符串替换后的字符串。该方法返回一个字符串，但不会改变原字符串。\n* public String[] split(String regex)：字符串调用该方法时，使用参数指定的正则表达式regex作为分隔标记分解出其中的单词，并将分解出的单词存放在字符串数组中。\n\n### StringBuffer类\n\nString类创建的字符串对象是不可修改的，也就是说String字符串不能修改、删除或替换字符串中的某个字符，即String对象一旦创建那么实体是不可以再发生变化的。\n\nStringBuffer类能创建可修改的字符串序列，也就是说该类的对象的实体的内存空间可以自动的改变大小，便于存放一个可变的字符序列。\n\n**StringBuffer对象的创建**\n\n三个构造方法：\n\n* StringBuffer()：初始容量16个字符，大于16时，实体容量自动增加，以便存放增加的字符。可通过length()方法获取实体中存放的字符序列的长度，通过capacity()方法获取当前实体的实际容量。\n* StringBuffer(int size)：初始容量为size。\n* StringBuffer(String s)：初始容量为字符串s的长度再加16个字符。\n\n**StringBuffer类的常用方法**\n\n* append方法：将其他java类型数据转化为字符串后，再追加到StringBuffer对象中。\n* public char charAt(int n)：得到参数n位置上的单个字符。n非负且小于字符串长度，从0开始。\n* public void setCharAt(int n, char ch)：将n处字符用ch代替。\n* StringBuffer insert(int index, String str)：将参数str指定的字符串插入到参数index指定的位置，并返回当前对象的引用。\n* public StringBuffer reverse()：将该对象实体中的字符翻转，并返回当前对象的引用。\n* StringBuffer delete(int startIndex, int endIndex)： 删除一个子字符串，并返回当前对象的引用。deleteCharAt(int index)删除index处的一个字符。\n* StringBuffer replace(int startIndex, int endIndex, String str)：替换并返回引用。\n\n### StringTokenizer类\n\nStringTokenizer对象用于分解字符串，与split不同的是，StringTokenizer对象不是用正则表达式作为分隔标记。\n\n**构造方法**：\n\n* StringTokenizer(String s):为字符串s构造一个分析器。使用默认的分隔标记，即空格符（若干个空格被看作一个空格）换行符、回车符、Tab符，进纸符做分隔标记，\n* StringTokenizer(String s, String delim)：为字符串s构造一个分析器。参数delim中的字符被作为分隔标记。\n\n称一个StringTokenizer对象为一个字符串分析器，一个分析器可以使用**nextToken()方法逐个获取字符串中的语言符号(单词)**，每当调用nextToken()时都将在字符串中获得下一个语言符号，每当获得到一个语言符号，字符串分析器中的负责计数的变量的值就自动减1，该计数变量的初始值等于字符串中的单词数目，通常用while循环来逐个获取语言符号，为了控制循环，可以使用StringTokenizer类中的**hasMoreTokens()方法**，只要字符串中还有语言符号，即计数器的值大于0，该方法就返回true，否则返回false，另外还可以随时让分析器调用**countTokens()方法得到分析器中计数变量的值。**\n\n### Date类\n\n**构造方法**：\n\n* Date nowTime = new Date(); 获取本地当前时间。\n* Date date = new Date(1000);带参数，表示1970年1月1日0时（格林威治时间）后的1毫秒。\n\n使用 public long currentTimeMillis()获取系统当前时间。\n\n**日期格式化**：\n\n示例：\n\n```java\nimport java.util.Date;\nimport java.text.SimpleDateFormat; //使用java.text包中的DateFormat的子类SimpleDateFormat来实现日期的格式化\npublic class DateExample{\n    public static void main(String args[]){\n        Date noWTime = new Date();\n        String pattern = \"yyyy-MM-dd\"; //指定格式\n        SimpleDateFormat SDF = new SimpleDateFormat(pattern);//创建一个对象\n        String time = SDF.format(nowTime);//格式化\n    }\n}\n```\n\n### Calendar 类\n\n- Calendar 类在java.util包中，使用Calendar 类的static方法getInstance()可以初始化一个日历对象。如：`Calendar calendar = Calendar.getInstance()`\n- calendar对象可以调用方法：`public final void set(int year, int month, int date, int hour, int minute, int second)`将日历翻到任何一个时间。\n- public int get(int field)方法可以获取有关年、月、小时、星期等信息。参数field有效值由Calendar的静态常量指定，如`calendar.get(Calendar.MONTH);`返回一个整数。\n- public long getTimeInMillis()可以将时间表示为毫秒。\n\n### Math类和BigInteger类\n\n**Math类常用方法：**\n\n* public static int abs(double a)： 返回a的绝对值。\n* public static double max(double a, double b):a、b的最大值\n* public static double min (double a, double b):a、b的最小值\n* public static double random():产生一个0~1之间的随机数\n* public static double pow(double a, double b):a的b次幂\n* public static double sqrt(double a):平方根\n* public static double log(double a):返回a的对数\n* public static double sin(double a):返回正弦值\n* public static double asin(doble a):返回反正弦值\n\n程序有时需要处理大整数，java.math中的BigInteger来提供任意精度的整数运算，可以使用构造方法public bigInteger(Stirng val)，构造一个十进制的BigInteger对象，该构造方法可以发生NumberFormatException异常，也就是说，字符串参数val中如果含有非数字字符就会发生NumberFormatException异常。\n\n**常用方法**：\n\n* public BigInteger add(BigInteger val)：和\n* public BigInteger substract(BigInteger val)：差\n* public BigInteger multiply(BigInteger val)：积\n* public BigInteger divide(BigInteger val)：商\n* public BigInteger remainder(BigInteger val)：余\n* public BigInteger abs()：绝对值\n* public BigInteger pow(int a)：平方\n* public int compareTo(BigInteger val)：比较，1，-1，0\n* public String toString()：十进制的字符串表示\n* public String toString(int p)：p进制的字符串表示\n\n### DecimalFormat类\n\n> 对输出的数字结果进行必要的格式化。\n>\n> java.text包\n\n```java\nDecimalFormat format = new DecimalFormat(\"###,##00.00\"); //格式化整数位和小数位，用0和.;整数的分组用#\nString result = format.format(123456789.543210);//1,2345,6789.54\n//模式尾加%，可以将数字格式化为百分数，加”\\u2030\"将数字格式化为钱分数。加“E0\"，将数字格式化为科学计数法。加￥、$将数字格式化为带货币符号的串。\n```\n\n将格式化字符串转为数字：\n\n```java\nDecimalFormat df = new DecimalFormat(\"###,#00.000$\");\nNumber num = df.parse(\"3,322,456.234$\");\ndouble d = num.doubleValue();\nd//3322456.234\n```\n\n### Pattern 与 Match 类\n\n> 模式匹配就是检索和指定模式匹配的字符串。java提供了专门用来进行模式匹配的 Pattern 类和 Match 类，这些类在java.util.regex包中。\n\n**模式对象**\n\n进行模式匹配的第1步就是使用Pattern类创建一个对象，称作模式对象。模式对象是对正则表达式的封装。Pattern类调用方法compile(String regex)返回一个模式对象，其中参数regex是一个正则表达式，称作模式对象使用的模式。比如：`Pattern p = Pattern.compile(\"hello\\\\d\")`\n\n如果参数regex指定的正则表达式有错，方法将抛出异常:PatternSyntaxException。\n\nPattern 类也可以调用类方法compile(String regex, int flags)返回一个Pattern 对象，参数flag可以取下列有效值：Pattern.CASE_INSENSITIVE，Pattern.MULTILINE，Pattern.DOTALL，Pattern.UNICODE_CASE，Pattern.CANON_EQ。\n\n**匹配对象**\n\n模式对象p调用matcher(CharSequence input)方法返回一个Matcher对象m，称作匹配对象，参数input可以是任何一个实现接口CharSequence 的类创建的对象，前面学过的String类和StringBuffer类都实现了接口。\n\n一个Matcher对象可以使用下列方法寻找参数指定的字符序列中是否有和模式匹配的子序列.\n\n* public boolean find()\n* public boolean matches()\n* public boolean lookingAt()\n* public boolean find(int start)\n* public String replaceAll(String replacement)\n* public String replaceFirst(String replacement)\n\n### Scanner类\n\n使用 Scanner 类从字符串中解析程序需要的数据。\n\n**使用默认分隔标记解析字符串**\n\n例子：\n\n```java\nString NBA = \"I LOVE THIS GAME\";\nScanner scanner = new Scanner(NBA);//构造一个Scanner对象\n```\n\nscanner将**空白**作为分隔标记、调用方法next()依次返回NBA中的单词，如果NBA最后一个单词已被next()方法返回，scanner调用hasNext()将返回false,否则返回true。对于数字型单词，可用nextDouble()、nextInt()等。\n\n如果单词不是数字型单词，调用nextInt()等方法将发生 InputMismatchException异常。\n\n**使用正则表达式作为分隔标记解析字符串**\n\nScanner可以调用 useDelimiter(正则表达式); 方法将一个正则表达式作为分隔标记，即和正则表达式匹配的字符串都是分隔标记。\n\n## 输入输出流\n\n> 程序在运行期间，可能需要从外部的存储媒介或其他程序中读入需要的数据，这就需要使用输入流对象。输入流的指向称作它的源，程序从指向源的输入流中读取源中的数据。\n>\n> 另一方面程序在处理数据后，可能需要将处理的结果写入到永久的存储媒介中或传送给其他的应用程序，这就需要使用输出流对象。输出流的指向称作它的目的地，程序通过向输出流中写入数据把数据传送到目的地。\n\n### File类\n\n程序可能经常需要获取磁盘上文件的有关信息，或者在磁盘上创建新的文件等，这就需要File类。File类的对象，主要是用来获取文件本身的一些信息，例如文件所在的目录、文件的长度、文件读写权限等，不涉及对文件的读写操作。\n\n创建File对象的构造方法：\n\n```java\nFile(String filename);  //该文件认为与当前应用程序在同意目录\nFile(String directoryPath, String filename);\nFile(File f, String filename);//filename是文件名字，directoryPath是文件路径，f是制定一个目录的文件\n```\n\n#### 文件的属性\n\n* public String getName()：获取文件的名字\n* public boolean canRead()：判断文件是否可读\n* public boolean canWrite()：判断文件是否可写\n* public long length()：获取文件长度（单位是字节）\n* public String getAbsolutePath()：获取文件绝对路径\n* public String getParent()：获取文件父目录\n* public boolean isFile()：判断文件是否是一个普通文件，而不是目录\n* public boolean isDirectory()：判断文件是否是一个目录\n* public boolean isHidden()：判断文件是否是隐藏文件\n* public long lastModified()：获取文件最后修改时间（时间是从1970年午夜至文件最后修改时刻的毫秒数）\n\n#### 目录\n\n**创建目录**\n\n```java\n//File对象调用方法\npublic boolean mkdir()//创建一个目录，成功返回true，否则返回false\n```\n\n**列出目录中的文件**\n\n如果File对象是一个目录，可调用下述方法列出该目录的文件和子目录\n\n* public String[] list()用字符串形式返回目录下的全部文件\n* public File [] listFiles()用File对象形式返回目录下的全部文件\n* public String[] list(FilenameFilter obj)该方法用字符串形式返回目录下的指定类型的所有文件\n* public File [] listFiles(FilenameFilter obj)该方法用File对象形式返回目录下的指定类型所有文件\n\nFilenameFilter是一个接口，该接口有一个方法：public boolean accept(File dir, String name)。\n\n使用list方法时，需向该方法传递一个实现接口FilenameFilter的对象，list 方法执行时，参数obj不断回调接口方法accept(File dir, String name)，该方法中的参数dir为调用list的当前目录、参数name被实例化目录中的一个文件名，当接口方法返回true时，list方法就将名字为name的文件存放到返回的数组中。\n\n#### 文件的创建与删除\n\n当使用file类创建一个文件对象后，例如`File file = new File(\"c:\\\\myletter\",\"letter.txt\");`\n\n如果c:\\\\myletter目录中没有名字为letter.txt的文件。文件对象调用方法`public boolean createNewFile();`\n\n可以在c:\\\\myletter目录中建立一个名字为letter.txt的文件。文件对象调用方法`public boolean delete();`\n\n可以删除当前文件，例如:`file.delete();`\n\n#### 运行可执行文件\n\n当要执行一个本地机上的可执行文件时，可以使用 java.lang 包中的Runtime类，首先使用Runtime类声明一个对象，例如:`Runtime ec;`\n\n然后使用该类的静态方法 getRuntime() 创建这个对象:`ec = Runtime.getRuntime();`\n\nec可以调用exec(String command) 方法打开本地机的可执行文件或执行一个操作。\n\n### 字节流与字符流\n\njava.io包中提供了大量的流类，java把InputStream抽象类的子类创建的流对象称为字节输入流、OutputStream抽象流的子类对象创建的流对象称作字节输出流，Java把Reader抽象类的子类创建的流对象称作字符输入流、Writer抽象类的子类创建的流对象称作字符输出流。\n\n针对不同的语言或目的地，java.io 包为程序提供了相应的输入流或输出流。这些输入输出流，绝大部分都是InputStream OutputStream Reader Writer的子类。\n\n例如，如果需要以字节为单位对磁盘上的文件进行读写操作，就可以分别使用InputStream和OutputStream的子类FileInputStream FileOutputStream来创建文件流和文件输出流。\n\n#### InputStream类和OutputStream类\n\nInputStream提供的read方法以字节为单位顺序的读取源中的数据，只要不关闭流，每次调用read方法就会顺序的读取源中的其余内容，直到源的末尾或输入流被关闭。\n\n方法：\n\n* int read()\n* int read(byte b[])\n* int read(byte b[], int off, int len)\n* void close()\n* long skip(long numBytes)\n\nOutputStream类以字节为单位顺序的写文件，只要不关闭流，每次调用write方法就会顺序的向目的地写入内容，直到流被关闭\n\n方法：\n\n* void write(int n)\n* void wirte(byte b[])\n* void wirte(byte b[], int off, int len)\n* void close()\n\n#### Reader类和Writer类\n\nReader 类提供的read方法以字符为单位顺序的读取源中的数据，只要不关闭流，每次调用read方法就顺序的读取源中的其余内容，直到源的末尾或输入流被关闭\n\n常用方法：\n\n* int read()\n* int read(char b[])\n* int read(char b[], int off, int len)\n* void close()\n* long skip(long numBytes)\n\nOutStream流以字符为单位顺序的写文件，只要不关闭流，每次调用write方法就顺序地向目的地写入内容，直到流被关闭。\n\n常用方法：\n\n* void wirte(int n)\n* void wirte(byte b[])\n* void wirte(byte b[], int off, int length)\n* void close()\n\n#### 关闭流\n\n流都提供了关闭方法close()，尽管程序结束时会自动关闭所有打开的流，但是当程序使用完流后，显示的关闭任何打开的流仍是一个良好的习惯。\n\n如果没有关闭那些被打开的流，那么就可能不允许另一个程序操作这些流所用的资源。\n\n另外需要注意的是，在操作系统把程序写到输出流上的那些字节保存到磁盘上之前，有时被存放在内存缓冲区中，通过调用close()方法可以保证操作系统把流缓冲区的内容写到它的目的地，即关闭输出流可以把该流所用的缓冲区的内容冲洗掉（通常冲洗到磁盘文件上）\n\n### 文件字节流\n\nInputStream专门提供了读写文件的子类：FileInputStream和FileOutputStram类。\n\n### 文件字符流\n\nFileReader、Filewirter\n\n### 缓冲流\n\nBufferedReader和BufferedWriter类创建的对象称作缓冲输入输出流。\n\n### 随机流\n\nRandomAccessFile类创建的流称作随机流。\n\n### 数组流\n\n字节数组流\n\n字符数组流\n\n### 数据流\n\nDataInputStream和DataOutputStream类创建的对象称为数据输入流和数据输出流。\n\n### 对象流\n\nObjectInputStream 和 ObjectOutputStream\n\n### 序列化和对象克隆\n\n### 文件锁\n\n### 使用Scanner对象解析文件\n\n', 'java程序设计思考与总结', 1592668800, 28);
INSERT INTO `article` VALUES (2, 3, 'javascript算法与数据结构', '# JavaScript数据结构与算法\n\n> 加油！坚持下去，一定会成功的！\n\n## 数组\n\n### 创建和初始化数组\n\n```js\nvar arr = new Array();\nvar arr = new Array(5);\nvar arr = new Array(\"hello\", \"world\");\n//用new创建数组并不是最好的方式，可以直接用[]\nvar arr = [];\nvar arr = [\"he\",\"lo\",\"wor\"];\n\narr.length //求数组长度\n```\n\n### 添加元素\n\n```js\nvar nums = [1,2,3,4,5,6,7];\nnums[nums.length] = 8;//js中数组是可修改对象。如果添加元素，它就会动态增长。\nnums.push(8); //push添加在元素末尾，返回数组长度\nnums.unshift();//数组首位添加元素\nnums.splice(5,0,1,2,3) //在索引5的位置插入1,2,3；0表示删除0个元素\n```\n\n### 删除元素\n\n```js\nnums.pop();//返回pop出去的值\nnums.shift();//从数组首位删除\nnums.splice(5,3);//删除从索引5开始的3个元素\ndelete nums[3] //删除索引3的值，此处值变为undefined，建议不用\n```\n\n### JavaScript数组参考方法\n\n| 方法名      | 描述                                                         | 示例 |\n| ----------- | ------------------------------------------------------------ | ---- |\n| concat      | 连接2个或更多数组，并返回结果                                |      |\n| every       | 对数组每一项运行给定函数，如果该函数每一项都返回true，则返回true |      |\n| some        | 对数组每一项运行给定函数，如果该函数任一项都返回true，则返回true |      |\n| filter      | 对数组每一项运行给定函数，返回该函数会返回true的项组成的数组 |      |\n| map         | 对数组每一项运行给定函数，返回每次函数调用的结果组成的数组（item,index) |      |\n| reduce      | 接受一个函数作参数：见下方                                   |      |\n| forEach     | 对数组每一项运行给定函数，没有返回值                         |      |\n| indexOf     | 返回第一个与给定参数相等的数组元素的索引，没有则返回-1       |      |\n| lastindexOf | 返回最后一个与给定参数相等的数组元素的索引，没有则返回-1     |      |\n| join        | 将所有数组元素连成一个字符串                                 |      |\n| reverse     | 将数组逆序                                                   |      |\n| slice       | 传入索引值，将数组里对应索引范围内的元素作为新数组返回       |      |\n| sort        | 按字母顺序对数组排序                                         |      |\n| toString    | 将数组作为字符串返回                                         |      |\n| valueOf     | 和toString类似，将数组作为字符串返回                         |      |\n\n[toString()和valueOf的区别](https://www.cnblogs.com/niulina/p/5699031.html)\n\n**reduce**：reduce方法接收一个函数作为参数，该函数有四个参数：previousValue,currentValue,index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器。\n\n```js\nnums.reduce((pre,cur,index)=>pre+cur);//将一个数组中所有元素求和\n```\n\n### ES6 数组新增方法\n\nES6为Array类增加了一个@@interator属性，需要通过Symbol.iterator来访问。\n\n| 方法        | 描述                                                         | 例子 |\n| ----------- | ------------------------------------------------------------ | ---- |\n| @@interator | 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 |      |\n| copyWithin  | 复制数组中一系列元素到同一数组指定的起始位置(替换位置，该位置读取，到该位置为止) |      |\n| entries     | 返回包含数组所有键值对的@@interator                          |      |\n| includes    | 如果数组中存在某个元素则返回true                             |      |\n| find        | 根据回调函数给定条件从数组中查找元素，如果找到返回该元素     |      |\n| findIndex   | 根据回调函数给定条件从数组中查找元素，如果找到返回该元素索引 |      |\n| fill        | 用静态值填充数组                                             |      |\n| from        | 根据已有数组创建一个新的数组                                 |      |\n| keys        | 返回包含数组所有索引的@@interator                            |      |\n| of          | 根据传入的参数创建一个新数组                                 |      |\n| values      | 返回包含数组中所有值的@@interator                            |      |\n\n```js\nb=[1,2,3,4,5]\nb.copyWithin(0,3)//[4, 5, 3, 4, 5],b的值已改变\nb=[1,2,3,4,5]\nb.includes(3)//true\nb.find(v=>v<2)//1\nb.findIndex(v=>v<3)//0\n\nfor(let n in b){ n%2===0?\'even\':\'odd\'}//使用for in 迭代 \"odd\"\n\nlet iterator = b[Symbol.iterator]();\niterator.next().value//1\niterator.next().value//2\niterator.next().value//3\niterator.next().value//4\niterator.next().value//5\niterator.next().value//undefined\n\nlet aEntries=b.entries()\naEntries.next().value//[0, 1]\n...\naEntries.next().value//[4,5]\naEntries.next().value//undefined\n\nlet aKeys = b.keys()\naKeys.next()//{value: 0, done: false}\n...\naKeys.next()//{value: 4, done: false}\naKeys.next()//{value: undefined, done: true}\n\nlet aValues=b.values()\naValues.next()//{value: 1, done: false}\n...\naValues.next()//{value: undefined, done: true}\n\nlet c=Array.from(b)//[1,2,3,4,5]\nlet c=Array.from(b,v=>v>2)//\n\nlet d=Array.from(b,v=>v+2)//[3,4,5,6,7]\nArray.of(...b)//[1,2,3,4,5]\nk=[1,2]\nk.fill(0)//[0, 0]\nk.fill(1,3,5)//3-5的位置填为1\nlet ones = new Array(6).fill(1)//[1, 1, 1, 1, 1, 1]\nd.sort((a,b)=>a-b)\n(6)?[1, 3, 4, 6, 10, 23]\nd.sort((a,b)=>b-a)\n(6)?[23, 10, 6, 4, 3, 1]\nd.toString()\n\"23,10,6,4,3,1\"\nd.join(\'-\')\n\"23-10-6-4-3-1\"\n```\n\n\n\n## 栈\n\n栈是一种先进后出的数据结构。可以用数组来表示。\n\n```js\nfunction Stack(){ //栈类\n    let items = []\n    this.push = function (element){ //添加\n        items.push(element)\n    }\n    this.pop = function (){//删除\n        return items.pop()\n    }\n    this.peek = function(){//取得栈顶元素\n        return items[items.length-1]\n    }\n    this.isEmpty = function(){//判断是否为空\n        return items.length==0\n    }\n    this.size = function(){//计算栈的大小\n        return items.length\n    }\n    this.clear = function(){//清空栈\n        items = []\n    }\n    this.print = function{//打印\n        console.log(items.toString())\n    }\n}\n//使用\nlet stack = new Stack()\n```\n\n上面的语法创建了一个可以当作类来使用的Stack函数。js函数都有构造函数，可以用来模拟类的行为。我们声明了一个私有变量items，他只能被Stack函数/类访问。然而这个方法为每个类的实例都创建了一个items变量的副本。因此如果创建更多Stack实例，他就不太合适了。\n\n**ES6语法声明Stack类**（基于原型的类，比基于函数的类更节省内存，也更适合创建多个实例，但不能声明私有变量！！）\n\n```js\nclass Stack{\n    constructor(){\n        this.items=[]  //这里的items变量是公共的。\n    }\n    push(element){\n        this.items.push(element)\n    }\n    //其他方法\n}\n```\n\n**ES6限定作用域Symbol实现类**（创建伪私有属性，因为ES6的Object.getOwnPropertySymbols方法能取到类中声明的所有Symbols属性）\n\n```js\nlet _items = Symbol()\nclass Stack{\n    constructor(){\n        this[_items]=[]\n    }\n    //Stack方法\n}\n```\n\n**ES6的WeakMap实现类**\n\n```js\nconst items = new WeakMap()\nclass Stack(){\n    constructor(){\n        items.set[this,[]]\n    }\n    push(element){\n        let s = items.get(this)\n        s.push(element)\n    }\n    pop(){\n        let s = items.get(this)\n        let r = s.pop()\n        return r;\n    }\n    //其他\n}\n```\n\nitems在Stack类里面是真正的私有属性了。但items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们可以用一个闭包（外层函数）把Stack类包装。\n\n```js\nlet Stack = (function(){\n    const items = new WeakMap()\n    class Stack{\n        constructor(){\n            items.set(this,[])\n        }\n        push(e){\n            let s = items.get(this)\n            s.push(e)\n        }\n        //其他\n    }\n    return Stack\n})()\n```\n\n缺点：拓展类无法继承私有属性。\n\n**应用**\n\n十进制转任意进制。\n\n```js\nfunction bascConverter(decNumber, base){\n    var remStack = new Stack(),rem,baseStrig=\'\',digits=\'0123456789ABCDEF\';\n    while(decNumber{>0){\n        rem = Math.floor(decNumber%base)\n        remStack.push(rem)\n        decNumber=Math.floor(decNumber/base)\n    }\n    while(remStack.isEmpty()){\n        baseString+=digits[remStack.pop()]\n    }\n    return remStack\n}\n```\n\n\n\n## 队列\n\n### 队列表示\n\n```js\nfunction Queue(){\n    let items = []\n    this.enqueue=function(element){\n        items.push(element)\n    }\n    this.dequeue = function(){\n        return items.shift()\n    }\n    this.front=function(){//查看队列头元素，即最先被移除的元素\n        return items[0]\n    }\n    this.isEmpty=function(){\n        return items.length==0\n    }\n    this.size=function(){\n        return items.length\n    }\n    this.print = function(){\n        console.log(items.toString())\n    }\n}\n\nlet queue = new Queue();\n```\n\nES6实现\n\n```js\nlet Queue=(function(){\n	const items = new WeakMap()\n    class Queue{\n		constructor(){\n			items.set(this,[])\n        }\n        enqueue(element){\n            let q = items.get(this)\n            q.push(element)\n        }\n        dequeue(){\n            let q = items.get(this)\n            let r = q.shift()\n            return r\n        }\n        //其他方法\n    }\n})();\n```\n\n### 优先队列\n\n元素的添加和移除是基于优先级的。此例为最小优先队列。即优先值小的在前。\n\n```js\nfunction PriorityQueue(){\n	let items = []\n    function QueueElment(element, priority){\n        this.element = element\n        this.priority = priority\n    }\n    this.enqueue = function (element, priority){\n        let queueElement = new QueueElement(element, priority)\n        let added = false\n        for(let i = 0; i < items.length; i++){\n            if(queueElement.priotity<items[i].priority){\n                items.splice(i,0,queueElement)\n                added = true\n                break\n            }\n        }\n        if(!added){\n            items.push(queueElement)\n        }\n    }\n}\nlet priorityQueue = new PriorityQueue()\npriorityQueue.enqueue(\"aa\",1);\n```\n\n### 循环队列--击鼓传花\n\n```js\nfunction hotPotato(nameList, num){\n    let queue = new Queue();\n    for(let i = 0; i < nameList.length; i++){\n        queue.enqueue(nameList[i])\n    }\n    let eliminated = \'\'\n    while(queue.size()>1){\n        for(let i = 0; i < num; i++){\n            queue.enqueue(queue.dequeue())\n        }\n        eliminated = queue.dequeue()\n        console.log(eliminated+\"被淘汰\")\n    }\n    return queue.dequeue();\n}\n\nlet names = [\'zhang\',\'li\',\'wang\',\'liu\']\nlet  winnner = hotPotato(names, 7)\nconsole.log(winner)\n```\n\n\n\n## 链表\n\n> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。\n>\n> 相对传统数组，链表一个好处在于，添加和移动元素不需要移动其他元素。但链表需要用到指针。\n>\n> 数组可以直接访问任何位置的元素，而想访问链表中的一个元素需要从表头开始迭代列表知道找到所需的元素。\n\n### 创建链表\n\n```js\nfunction LinkedList(){\n    //需要一个Node辅助类，Node类表示要加入列表的项。包含一个element属性，即要添加到列表的值，以及一个next属性，即指向下一个节点项的指针。\n    let Node = function(element){\n        this.element = element;\n        this.next = null;\n    }\n    \n    let length = 0;//列表长度\n    let head = null;\n    //向列表尾部添加一个新的项\n    this.append = function(element){\n        let node = new Node(element);\n        let current;\n        if(head == null) head = node;\n        else{\n            current = head;\n            while(current.next){\n                current = current.next\n            }\n            current.next = node;\n        }\n        length++;\n    }\n    //向列表特定位置插入一个新的项\n    this.insert = function(position, element){\n        if(position>=0&&position <=length){\n            let node =new Node(element), current = head, pervious, index=0;\n            if(position == 0) {\n                node.next = current\n            	head = node\n            } else{\n                while(index++<position){\n                    pervious = current;\n                    current = current.next;\n                }\n                node.next = current\n                pervious.next = node\n            }\n            length++\n            return true\n        }else{\n            return false\n        }\n    }\n    //从列表中特定位置移除一项\n    this.removeAt = function(position){\n        if(position>-1&&position<length){\n            let previous, index = 0, current = head;\n          	if(position==0) head = current.next;\n            else{\n                while(index++<position){\n                    previous = current;\n                    current = current.next;\n                }\n                previous.next = current.next\n            }\n            length--;\n            return current.element;\n        }else{\n            return null;\n        }\n    }\n    //从列表中移除一项\n    this.remove = function(element){\n        let index = this.indexOf(element)\n        return this.removeAt(index)\n    }\n    //返回元素在列表中的索引\n    this.indexOf = function(element){\n        let current = head;\n        index = -1;\n        while(current){\n            if(element === current.element){\n                return index\n            }\n            index++;\n            current = current.next\n        }\n        return -1;\n    }\n    //如果链表不包含任何元素，返回true\n    this.isEmpty = function(){\n        return length === 0;\n    }\n    //返回链表包含的元素个数\n    this.size = function(){\n        return length;\n    }\n    this.getHead = function(){\n        return head;\n    }\n    //输出元素的值\n    this.toString = function(){\n        let current = head, string = \'\';\n        while(current){\n            string+=current.element+(current.next?\'n\':\'\');\n            current = current.next\n        }\n        return string\n    }\n    this.print = function(){}\n}\n```\n\n### 双向链表\n\n```js\nfunction DoublyLinkedList(){\n    let Node = function(element){\n        this.element = element\n        this.next = null\n        this.prev = null\n    }\n    let length = 0\n    let head = null\n    let tail = null //保存对列表最后一项的引用\n    \n    this.insert = function(position, element){\n        if(position>=0&&position<=length){\n            let node = new Node(element)\n        	let current = head , previous, index = 0;\n            if(position == 0) {\n                if(!head){//如果列表为空\n                    head = node;\n                    tail = node;\n                } else{\n                    node.next = current\n                    current.prev = node\n                    head = node\n                }\n            }else if(position == length){\n                current = tail\n                current.next = node\n                node.prev = current\n                tail=node\n            }else{\n                while(index++<position){\n                    previous = current\n                    current =current.next\n                }\n                node.next = current\n                previous.next = node\n                \n                current.prev = node\n                node.prev = previous\n            }\n            length++\n            return true\n        } else{\n            return false\n        }\n    }\n    \n    this.removeAt = function(element){\n        if(position>-1&&position<length){\n            let current = head,previous,index=0;\n            if(position ==0){\n                head = current.next\n                if(length==1){\n                    tail = null\n                }else{\n                    head.prev=null\n                }\n            }else if(position === length-1){\n                current = tail\n                tail = current.prev\n                tail.next = null\n            }else{\n                while(index++<position){\n                    previous = current\n                    current = current.next\n                }\n                previous.next = current.next\n                current.next.prev = previous\n            }\n            length--;\n            return current.element\n        }else{\n            return null\n        }\n    }\n}\n```\n\n\n\n## 集合\n\n**一种不允许重复的顺序数据结构。**\n\n### 集合的创建\n\n```js\nfunction Set(){\n    let items = {} //使用对象而不是数组来表示集合\n    //向集合添加一个新的项\n    this.add=function(value){\n        if(!this.has(value)){\n            items[value]=value\n            reutrn true\n        }\n        return false\n    }\n    //从集合移除一个值\n    this.delete=function(value){\n        if(this.has(value)){\n            delete items[value];\n            return true\n        }\n        return false\n    }\n    //如果值在集合中，返回true\n    this.has = function(value){\n        return value in items\n        //或者\n        //return items.hasOwnProperty(value) \n        //js对象都有这个方法，该方法返回一个表明对象是否具有特定属性的布尔值\n    }\n    //移除集合中所有项\n    this.clear(){\n        items={}\n    }\n    //返回集合所包含元素的数量\n    this.size=function(){\n        //Object类有一个keys方法，它返回一个包含给定对象所有属性的数组\n        return Object.keys(items).length\n    }\n    //另一种求size的方法\n    this.sizeLegacy = function(){\n        let count=0\n        for(let key in items){ \n            if(items.hasOwnProperty(key)) ++count  //避免重复计数\n        }\n        return count\n    }\n    //返回一个集合中所有值的数组\n    this.values=function(){\n        let values = []\n        for(let i = 0; keys = Object.keys(items);i<keys.length;i++){\n            values.push(items[keys[i]])\n        }\n        return values\n    }\n    //另一种方法实现values()方法\n    this.valuesLegacy = function(){\n        let values = []\n        for(let key in items){\n            if(items.hasOwnProperty(key)){\n                values.push(items[key])\n            }\n        }\n        return values\n    }\n}\n//使用\nlet set = new Set()\nset.add(1)\nset.values()//1\nset.has(1)//true\nset.size()//1\n```\n\n### 集合的操作\n\n#### A并B\n\n```js\nthis.union = function(otherSet){\n    let unionSet = new Set()\n    let values = this.values()\n    for(let i = 0; i < values.length; i++){\n        unionSet.add(values[i])\n    }\n    values = otherSet.values()\n    for(let i = 0; i < values.length; i++){\n        unionSet.add(values[i])\n    }\n    return unionSet\n}\n```\n\n#### A交B\n\n```js\nthis.intersection = function(otherSet){\n    let intersectionSet = new Set()\n    let values = this.values()\n    for(let i = 0; i < length; i++){\n        if(otherSet.has(values[i])){\n            itersectionSet.add(values[i])\n        }\n    }\n    return itersectionSet\n}\n```\n\n#### 差集A-B\n\n```js\nthis.difference = function(otherSet){\n    let differenceSet = new Set()\n    let values = this.values()\n    for(let i = 0; i < values.length; i++){\n        if(!otherSet.has(values[i])){\n            differenceSet.add(values[i])\n        }\n    }\n    return differenceSet\n}\n```\n\n#### 子集--A是B的子集\n\n```js\nthis.subset = function(otherSet){\n    if(this.size()>otherSet.size){\n        return false\n    }else{\n        let values = this.values()\n        for(let i = 0; i < values.length; i++){\n            if(!otherSet.has(values[i])){\n                return false\n            }\n        }\n        return true\n    }\n}\n```\n\n\n\n### ES6 — Set类\n\n与我们自定义的Set类不同，Es6的Set的values方法返回Iterator,而不是构成值的数组。ES6的Set有一个size属性，而我们实现的size是一个方法。\n\n#### 模拟并集操作\n\n```js\nlet unionAb = new Set()\nfor(let x of setA) unionAb.add(x)\nfor(let x of setB) unionAb.add(x)\n```\n\n#### 模拟交集操作\n\n```js\nlet intersection = function(setA, setB){\n    let intersectionSet = new Set()\n    for(let x of setA){\n        if(setB.has(x)){\n            intersectionSet.add(x)\n        }\n    }\n    return intersectionSet\n}\nlet intersectionAb = intersection(setA, setB)\n\n//或者\nintersectionAb = new Set([x for (x of setA) if(setB.has(x))])\n```\n\n#### 模拟差集操作\n\n```js\nthis.difference = function(setA, setB){\n    let differenceSet = new Set()\n    for(let x of setA){\n        if(!setB.has(x)){\n            differenceSet.add(x)\n        }\n    }\n    return differenceSet\n}\n\n//或者\nlet differenceAb = new Set([x for (x of setA) if(!setB.has(x))])\n```\n\n## 字典和散列表\n\n集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是值的本身，并把它当作主要元素。在字典中，我们用[键，值]对的形式来存储数据，散列表中也是如此，但实现方式略有不同。\n\n### 字典\n\n```js\nfunction Dictionary(){\n    var items = {}\n    //向字典中添加新元素\n    this.set = function(key, value){\n        items[key] = value\n    }\n    //通过键值来从字典中移除键值对应的数据值\n    this.delete = function(key){\n        if(this.has(key)){\n            delete items[key]\n            return true\n        }\n        return false\n    }\n    //如果某个键值存在于这个字典中，则返回true\n    this.has = function(key){\n        return key in items\n    }\n    //通过键值查找特定的数值并返回\n    this.get = function(key){\n        return this.has(key)?items[key]:undefined\n    }\n    //将字典中所有元素删除\n    this.clear = function(){\n        items = {}\n    }\n    //返回字典中包含元素的数量\n    this.size = function(){\n        return Object.keys(items).length\n    }\n    //将字典包含的所有键名以数组形式返回\n    this.keys = function(){\n        return Object.keys(items)\n    }\n    this.getItems = function(){\n        return items\n    }\n    //将字典包含的所有数值以数组形式返回\n    this.values = function(){\n        var values =[]\n        for(var k in items){\n            if(this.has(k)){\n                values.push(items[k])\n            }\n        }\n        return values;\n    }\n}\n```\n\n### 散列表\n\n> 散列算法的作用是尽可能快地在数据结构中找到一个值。前面的方法中获得一个值（get方法），需要遍历整个数据结构。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。\n\n#### 散列表的创建\n\n```js\nfunction HashTable(){\n    vat table = []\n    //在实现下列方法之前，要实现的第一个方法是散列函数，它是HashTable的一个私有方法\n    var loseloseHashCode = function(key){\n        var hash = 0;\n        for(var i = 0; i < key.length; i++){\n            hash+=key.charCodeAt(i)\n        }\n        return hash%37\n    }\n    //向散列表中增加一个新的项，也可以更新散列表\n    this.put = function(key,value){\n        var position = loseloseHashCode(key)\n        console.log(position+\'-\'+key)\n        table[position] = value\n    }\n    //根据键值从散列表中移除值\n    this.remove = function(key){\n        table[loseloseHashCode(key)] = undefined\n    }\n    //返回根据键值检索到的特定的值\n    this.get = function(key){\n        return table[loseloseHashCode(key)]\n    }\n}\n//使用\nvar hash = new HashTable()\nhash.put(\'Gandalf\', \'gandalf@email.com\') //19-Gandalf\nhash.get(\'Gandalf\') //gandalf@email.com\nhash.remove(\'Gandalf\')\n```\n\n#### 处理散列表的冲突\n\n##### 分离链接\n\n分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单方法，但需要更多的额外空间。\n\n```js\n//增加辅助类，在HashTable类内部定义\nvar ValuePair = function(key, value){\n    this.key = key\n    this.value = value\n    this.toString = function(){\n        return \'[\'+this.key+\'-\'+this.value+\']\'\n    }\n}\n//改写put方法\nthis.put=function(key,value){\n    var position = loseloseHashCode(key)\n    if(table[position]==undefined){\n        table[position] = new LinkedList()\n    }\n    table[position].append(new ValuePair(key,value))\n}\n//改写get方法\nthis.get=function(key){\n    var position = loseloseHashCode(key)\n    if(table[position]!==undefined){\n        var current = table[positon].getHead()\n        while(current.next){\n            if(current.element.key===key){\n                return current.element.value\n            }\n            current=current.next\n        }\n        if(current.element.key===key){\n            return current.element.key\n        }\n    }\n    return undefined\n}\n//改写remove方法\nthis.remove=function(key){\n    var  position = loseloseHashCode(key)\n    if(table[position]!==undefined){\n        var current = table[position].getHead()\n        while(current.next){\n            if(current.element.key===key){\n                table[positon].remove(current.element)\n                if(table[position].isEmpty()){\n                    table[position]=undefined\n                }\n                return true\n            }\n            current = current.next\n        }\n        if(current.element.key===key){\n            table[position].remove(current.element)\n            if(table[position].isEmpty()){\n                table[position]=undefined\n            }\n            return true\n        }\n    }\n    return false\n}\n\n```\n\n##### 线性探查\n\n```js\nthis.put = function(key,value){\n    var postion = loseloseHashCode(key)\n    if(table[position]==undefined){\n        table[position] = new ValuePair(key,value)\n    }else{\n        var index = ++position\n        while(table[index]!=undefined){\n            index++\n        }\n        table[index]=new ValuePair(key,value) \n    }\n}\nthis.get=function(key){\n    var position = loseloseHashCode(key)\n    if(table[position]!==undefined){\n        if(table[position].key===key){\n            return table[positon].value //1\n        }else{\n            var index = ++position\n     			while(table[index]===undefined||table[index].key!==key){\n            	index++\n        	}\n        	if(table[index].key===key){\n                return table[index].value //2\n            }\n        }\n    }\n}\n//this.remove和get方法基本相同，不同在于1,2,它们由table[index]=undefined代替\n```\n\n#### 创建更好的散列函数\n\n```js\nvar djb2HashCode = function(key){\n    var hash = 5381\n    for(var i = 0; i < key.length; i++){\n        hash = hash*33+key.charCodeAt(i)\n    }\n    return hash%1013\n}\n```\n\n\n\n### ES6---Map类\n\n与我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator，而不是值或键构成的数组。另一方面，我们实现的size方法返回字典中存储的值的个数，而Es6的Map类则有一个size属性。\n\n删除map中的元素可以用delete方法\n\n### ES6---WeakMap类和WeakSet类\n\n基本上，Map和Set与其弱化版本之间仅有的区别是：\n\n* WeakMap或WeakSet类没有entries、keys和values等方法\n* 只能用对象作为键\n\n创建和使用这两个类主要是为了性能。WeakMap或WeakSet是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。\n\n另外一个优点，必须用键才可以取出值。这些类没有entries、values、keys等迭代器方法，因此，除非你知道键，否则无法取出值。印证了栈那一节的做法，即使用WeakMap类封装ES6类的私有方法。\n\n## 树\n\n### 树的相关术语\n\n* 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部节点）以及0个或多个子节点。\n* 位于树顶部的节点叫作根节点。\n* 至少有一个子节点的节点称为内部节点。没有子元素的节点称为外部节点或叶节点。\n\n### 二叉树和二叉搜索树\n\n* 二叉搜索树（BST）是二叉树的一种，但是它只允许在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。\n\n#### 创建二叉搜索树\n\n```js\n//BinarySearchTree类\nfunction BinarySearchTree(){\n    //先声明其结构\n    var Node = function(key){\n        this.key=key;\n        this.left=null;\n        this.right=null;\n    }\n    var root = null;\n    //向树中插入一个新键\n    this.insert = function(key){\n        var newNode = new Node(key);\n        if(root===null){\n            root = newNode\n        }else{\n            insertNode(root,newNode);\n        }\n    }\n    //插入--辅助函数\n    this.insertNode = function(node,newNode){\n        if(newNode.key<node.key){\n            if(node.left===null){\n                node.left=newNode\n            }else{\n                insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right===null){\n                node.right=newNode\n            }else{\n                insertNode(node.right,newNode)\n            }\n        }\n    }\n}\n```\n\n#### 树的遍历\n\n##### 中序遍历\n\n```js\nthis.inOrderTraverse=function(callback){\n    inOrderTraverseNode(root,callback)\n}\nvar inOrderTraverseNode=function(node,callback){\n    if(node!==null){\n        inOrderTraverseNode(node.left,callback);\n        callback(node.key);\n        inOrderTraverseNode(node.right,callback)\n    }\n}\n```\n\n##### 先序遍历\n\n```js\nthis.preOrderTraverse=function(callback){\n    preOrderTraverseNode(root,callback)\n}\nvar preOrderTraverseNode = function(node,callback){\n    if(node!==null){\n        callback(node.key);\n        preOrderTraverseNode(node.left,callback);\n        preOrderTraverseNode(node.right,callback)\n    }\n}\n```\n\n#### 搜索树中的值\n\n```js\n//寻找树中最小键（最大键类似）\nthis.min = function(){\n    return minNode(root);\n}\nvar minNode=function(node){\n    if(node){\n        while(node&&node.left!==null){\n            node=node.left\n        }\n        return node.key\n    }\n    return null\n}\n//搜索一个特定值\nthis.search = function(key){\n    return searchNode(root,key);\n}\nvar search = function(node,key){\n    if(node===null) return false;\n    if(key<node.key){\n        return searchNode(node.left,key)\n    }else if(key>node.key){\n        return searchNode(node.right,key)\n    }else{\n        return true\n    }\n}\n```\n\n#### 移除一个节点\n\n```js\nthis.remove = function(key){\n    root = removeNode(root,key)\n}\nvar removeNode = function(node,key){\n    if(node === null) return null;\n    if(key<node.key){\n        node.left=removeNode(node.left,key)\n        return node\n    }else if(key>node.key){\n        node.right = removeNode(node.right,key);\n        return node\n    }else{\n        if(node.left===null&&node.right===null){\n            node=null;\n            return node;\n        }\n        if(node.left===null){\n            node=node.right;\n            return node;\n        }else if(node.right === null){\n            node =node.left\n            return node\n        }else{\n            var aux = findMinNode(node.right);\n            node.key=aux.key;\n            node.right=removeNode(node.right,aux.key);\n            return node;\n        }\n    }\n}\nvar findMinNode = function(node){\n    while(node&&node.left!==null){\n        node=node.left;\n    }\n    return node;\n}\n```\n\n### AVL树\n\n* AVL树是一种自平衡树。添加和移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1.添加或移除节点时，AVL树会尽可能尝试转换为完全树。\n\n#### \n\n## 排序和搜索算法\n\n### 排序算法\n\n#### 冒泡排序\n\n```js\nfunction bubbleSort(array){\n   for(var i = 0; i < array.length; i++){\n       for(var j = 0; j < array.length; j++){\n       //此处可改进，将array.length-->array.length-1-i\n           if(array[j]>array[j+1]){\n               [array[j],array[j+1]]=[array[j+1],array[j]]\n           }\n       }\n   }\n}\n```\n\n#### 选择排序\n\n```js\nfunction selectionSort(array){\n    var length = array.length, indexMin\n    for(var i = 0; i < length-1; i++){\n        indexMin = i;\n        for(var j = i; j < length; j++){\n            if(array[indexMin]>array[j]){\n                indexMin = j;\n            }\n        }\n        if(i!== indexMin){\n        	[array[i],array[indexMin]]=[array[indexMin],array[i]]\n    	}\n    }\n}\n```\n\n#### 插入排序\n\n```js\nfunction insertionSort(array){\n    var len = array.length, j, tmp;\n    for(var i = 1; i < len;i++){\n        j=i;\n        tmp=array[i];\n        while(j>0&&array[j-1]>tmp){\n            array[j]=array[j-1];\n            j--;\n        }\n        array[j]=tmp\n    }\n}\n```\n\n#### 归并排序\n\n```js\n//分治法，归并排序是递归的\nthis.mergeSort = function(){\n    array = mergeSortRec(array)\n}\nvar mergeSortRec = function(array){\n    var length = array.length\n    if(length===1) return array;\n    \n    var mid = Math.floor(length);\n    left = array.slice(0,mid);\n    right = array.slice(mid,length);\n    return merge(mergeSortRec(left),mergeSortRec(right));\n}\n\nvar merge=function(left,right){\n    var result = []\n    il = 0; ir=0;\n    while(il<left.length&&ir<right.length){\n        if(left[il]<right[ir]){\n            result.push(left[il++])\n        }else{\n            result.push(right(ir++))\n        }\n    }\n    while(il<left.length){\n        result.push(left[il++])\n    }\n    while(ir<right.length){\n        result.push(right[ir++])\n    }\n    return result;\n}\n```\n\n#### 快速排序\n\n```js\nthis.quickSort = function(){\n    quick(array,0,array.length-1);\n}\nvar quick = function(array,left,right){\n    var index;\n    if(array.length>1){\n        index=partition(array,left,right);\n        if(left<index-1){\n            quick(array,left,index-1)\n        }\n        if(right>index){\n            quick(array,index,right)\n        }\n    }\n}\nvar partition = function(array,left,right){\n    var pivot = array[Math.floor((right+left)/2)],\n        i= left, j=right;\n    while(i<=j){\n        while(array[i]<pivot){\n            i++;\n        }\n        while(array[j]>pivot){\n            j--;\n        }\n        if(i<=j){\n            swap(i,j)\n            i++;\n            j--;\n        }\n    }\n    return i;\n}\n```\n\n### 搜索算法\n\n#### 顺序搜索\n\n```js\nthis.sequentialSearch = function(item){\n    for(var i =0; i < array.length; i++){\n        if(item===array[i]){\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n#### 二分搜索\n\n```js\nthis.binarySearch = function(item){\n    this.quickSort()\n    var low = 0,high=array.length-1,mid,element;\n    while(low<=high){\n        mid=Math.floor((low+high)/2);\n        element = array[mid];\n        if(element<item){\n            low=mid+1;\n        }else if{\n            high=mid-1;\n        }else{\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n## 图\n\n### 图的相关术语\n\n### 图的表示\n\n#### 邻接矩阵\n\n#### 邻接表\n\n#### 关联矩阵\n\n### 创建Graph类\n\n### 图的遍历\n\n#### 广度优先搜索\n\n#### 深度优先搜索\n\n### 最短路径算法\n\n#### Dijkstra算法\n\n#### Floyd-Warshall算法\n\n### 最小生成树\n\n#### Prim算法\n\n#### Kruskal算法', 'Javascript算法与数据结构笔记', 1595260800, 33);
INSERT INTO `article` VALUES (3, 3, '利用egg.js连接数据库', '## 安装egg.js开发环境\n\n* 全局安装`egg.js`的脚手架工具`egg-init`：\n\n  ```javascript\n  npm i egg-init -g\n  ```\n\n* 脚手架自动生成\n\n  ```js\n  egg-init --type=simple\n  ```\n\n  一路回车即可。\n\n* 安装依赖包\n\n  ```js\n  npm install\n  ```\n\n* 启动服务器\n\n  ```js\n  npm run dev\n  ```\n\n## egg.js目录结构介绍\n\n- app文件夹:项目开发文件，程序员主要操作的文件，项目的大部分代码都会写在这里。\n  - controller文件夹：控制器，渲染和简单的业务逻辑都会写道这个文件里。配置路由时也会用到（路由配置需要的文件都要写在控制器里）。\n  - public文件夹：公用文件夹，把一些公用资源都放在这个文件夹下。\n  - router.js: 项目的路由配置文件，当用户访问服务的时候，在没有中间件的情况下，会先访问router.js文件。\n  - service文件夹：这个是当我们的业务逻辑比较复杂或和数据库打交道时，会把业务逻辑放到这个文件中。\n  - view文件夹：模板文件夹，相当于表现层的专属文件夹，这个项目，我们使用接口的形式，所以不需要建立view文件夹。\n  - extend文件：当我们需要写一些模板中使用的扩展方法时，我们会放到这个文件夹里。\n  - middleware：中间件文件夹，用来写中间件的，比如最常用的路由首位。\n- config文件夹：这个是整个项目的配置目录，项目和服务端的配置都在这里边进行设置。\n- logs文件夹：日志文件夹，正常情况下不用修改和查看里边内容。\n- node_modules:项目所需要的模块文件，这个前端应该都非常了解，不多作介绍。\n- run文件夹：运行项目时，生成的配置文件，基本不修改里边的文件。\n- test文件夹：测试使用的配合文件，这个在测试时会使用。\n- .autod.conf.js: egg.js自己生成的配置文件，不需要进行修改。\n- eslinttrc和eslintignore：代码格式化的配置文件。\n- gitgnore：git设置忽略管理的配置文件。\n- package.json： 包管理和命令配置文件，这个文件经常进行配置。\n\n**重点在于app文件和config文件**。\n\n## 默认模版示例\n\n* /app/controller/home.js\n\n  ```js\n  async list() {\n      const { ctx } = this;\n      ctx.body = \'hi egg\';\n    }\n  ```\n\n* /app/router.js\n\n  ```js\n  \'use strict\';\n  \n  /**\n   * @param {Egg.Application} app - egg application\n   */\n  module.exports = app => {\n    const { router, controller } = app;\n    router.get(\'/\', controller.home.index);\n  };\n  ```\n\n通常我们可以在controller文件下建立admin和default文件夹。然后建立一个router文件夹。\n\n## 连接数据库\n\n* `egg-mysql`模块安装\n\n  ```js\n  npm i egg-mysql --save \n  ```\n\n* 插件配置\n\n  * /server/config/plugin.js\n\n    ```js\n    exports.mysql = {\n        enable: true,\n        package: \'egg-mysql\'\n    }\n    ```\n\n  * /server/config/config.default.js\n\n    ```js\n    config.mysql = {\n        // database configuration\n        client: {\n          // host\n          host: \'localhost\',\n          // port\n          port: \'3306\',\n          // username\n          user: \'root\',\n          // password\n          password: \'12345678\',\n          // database\n          database: \'react_blog\',    \n        },\n        // load into app, default is open\n        app: true,\n        // load into agent, default is close\n        agent: false,\n      };\n    ```\n\n**当然，首先我们需要建立数据库。**\n\n参考：[技术胖](https://jspang.com/detailed?id=52#toc241)\n', '利用egg.js连接数据库', 1588003200, 31);
INSERT INTO `article` VALUES (4, 2, 'Shell使用', '# Shell\n\n## 入门\n\n> Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。*Shell 既是一种命令语言，又是一种程序设计语言。*\n>\n> Shell 是指一种应用程序，这个应用程序提供了一个界面，*用户通过这个界面访问操作系统内核的服务*。\n>\n> Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。\n\n[**Shell 在线工具**](https://www.runoob.com/try/showbash.php?filename=helloworld)\n\n\n\n### **shell脚本**\n\nShell 脚本（shell script），是一种为 shell 编写的脚本程序。\n\n业界所说的 shell 通常都是指 shell 脚本，但shell 和 shell script 是两个不同的概念。\n\n由于习惯的原因，简洁起见，本文出现的 \"shell编程\" 都是指 shell 脚本编程，不是指开发 shell 自身。\n\n\n\n### **Shell 环境**\n\nShell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的*文本编辑器*和一个能*解释执行的脚本解释器*就可以了。\n\nLinux 的 Shell 种类众多，常见的有：\n\n- Bourne Shell（/usr/bin/sh或/bin/sh）\n- Bourne Again Shell（/bin/bash）\n- C Shell（/usr/bin/csh）\n- K Shell（/usr/bin/ksh）\n- Shell for Root（/sbin/sh）\n- ……\n\n本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。\n\n在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 **#!/bin/sh**，它同样也可以改为 **#!/bin/bash**。\n\n**#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。**\n\necho 命令用于向窗口输出文本。\n\n\n\n### **运行 Shell 脚本有两种方法：**\n\n**1、作为可执行程序**\n\n将上面的代码保存为 test.sh，并 cd 到相应目录：\n\n```bash\nchmod +x ./test.sh  #使脚本具有执行权限\n./test.sh  #执行脚本\n```\n\n**2、作为解释器参数**\n\n这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：\n\n```bash\n/bin/sh test.sh\n/bin/php test.php\n```\n\n这种方式运行的脚本，不需要在第一行指定解释器信息。\n\n\n\n## Shell基础\n\n### Shell 变量\n\n定义变量时，**变量名不加美元符号**（$，PHP语言中变量需要），如：\n\n```bash\nyour_name=\"runoob.com\"\n```\n\n变量名和等号之间**不能有空格**变量名的命名须遵循如下规则：\n\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n- 中间不能有空格，可以使用下划线（_）。\n- 不能使用标点符号。\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n除了显式地直接赋值，还可以**用语句给变量赋值**，如：\n\n```bash\nfor file in `ls /etc`\n或\nfor file in $(ls /etc)\n```\n\n以上语句将 /etc 下目录的文件名循环出来。\n\n#### 使用变量\n\n使用一个定义过的变量，只要在变量名前面**加美元符号**即可，如：\n\n```bash\nyour_name=\"qinjx\"\necho $your_name\necho ${your_name}\n```\n\n变量名外面的**花括号是可选的**，加不加都行，加花括号是为了帮助解释器识别变量的边界。\n\n推荐给所有变量加上花括号，这是个好的编程习惯。\n\n已定义的变量，可以被重新定义，如：\n\n```bash\nyour_name=\"tom\"\necho $your_name\nyour_name=\"alibaba\"\necho $your_name\n```\n\n\n\n#### 只读变量\n\n使用 **readonly** 命令可以将变量定义为只读变量，只读变量的值不能被改变。\n\n下面的例子尝试更改只读变量，结果报错：\n\n```bash\n#!/bin/bash\nmyUrl=\"http://www.google.com\"\nreadonly myUrl\nmyUrl=\"http://www.runoob.com\"\n```\n\n运行脚本，结果如下：\n\n```bash\n/bin/sh: NAME: This variable is read only.\n```\n\n#### 删除变量\n\n使用 **unset** 命令可以删除变量。语法：\n\n```bash\nunset variable_name\n```\n\n**变量被删除后不能再次使用**。unset 命令不能删除只读变量。\n\n**实例**\n\n```bash\n#!/bin/sh\nmyUrl=\"http://www.runoob.com\"\nunset myUrl\necho $myUrl\n```\n\n以上实例执行将没有任何输出。\n\n#### 变量类型\n\n运行shell时，会同时存在三种变量：\n\n- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n### Shell 字符串\n\n字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。\n\n#### 单引号\n\n```bash\nstr=\'this is a string\'\n```\n\n单引号字符串的限制：\n\n- 单引号里的任何字符都会原样输出，**单引号字符串中的变量是无效的**；\n- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n\n#### 双引号\n\n```bash\nyour_name=\'runoob\'\nstr=\"Hello, I know you are \\\"$your_name\\\"! \\n\"\necho -e $str\n```\n\n输出结果为：\n\n```bash\nHello, I know you are \"runoob\"! \n```\n\n双引号的优点：\n\n- 双引号里可以有变量\n- 双引号里可以出现转义字符\n\n#### 拼接字符串\n\n```bash\nyour_name=\"runoob\"\n# 使用双引号拼接\ngreeting=\"hello, \"$your_name\" !\"\ngreeting_1=\"hello, ${your_name} !\"\necho $greeting  $greeting_1\n# 使用单引号拼接\ngreeting_2=\'hello, \'$your_name\' !\'\ngreeting_3=\'hello, ${your_name} !\'\necho $greeting_2  $greeting_3\n```\n\n输出结果为：\n\n```bash\nhello, runoob ! hello, runoob !\nhello, runoob ! hello, ${your_name} !\n```\n\n#### 获取字符串长度\n\n```bash\nstring=\"abcd\"\necho ${#string} #输出 4\n```\n\n#### 提取子字符串\n\n以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：\n\n```bash\nstring=\"runoob is a great site\"\necho ${string:1:4} # 输出 unoo\n```\n\n**注意**：第一个字符的索引值为 **0**。\n\n#### 查找子字符串\n\n查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)：\n\n```bash\nstring=\"runoob is a great site\"\necho `expr index \"$string\" io`  # 输出 4\n```\n\n**注意：** 以上脚本中 **`** 是反引号，而不是单引号 **\'**，不要看错了哦。\n\n\n\n### Shell 数组\n\nbash支持*一维数组*（不支持多维数组），并且没有限定数组的大小。\n\n类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。\n\n#### 定义数组\n\n在 Shell 中，用括号来表示数组，数组元素用\"空格\"符号分割开。定义数组的一般形式为：\n\n```bash\n数组名=(值1 值2 ... 值n)\n```\n\n例如：\n\n```bash\narray_name=(value0 value1 value2 value3)\n```\n\n或者\n\n```bash\narray_name=(\nvalue0\nvalue1\n)\n```\n\n还可以单独定义数组的各个分量：\n\n```bash\narray_name[0]=value0\narray_name[n]=valuen\n```\n\n可以不使用连续的下标，而且下标的范围没有限制。\n\n#### 读取数组\n\n读取数组元素值的一般格式是：\n\n```bash\n${数组名[下标]}\n```\n\n例如：\n\n```bash\nvaluen=${array_name[n]}\n```\n\n使用 **@** 符号可以获取数组中的所有元素，例如：\n\n```bash\necho ${array_name[@]}\n```\n\n#### 获取数组的长度\n\n获取数组长度的方法与获取字符串长度的方法相同，例如：\n\n```bash\n# 取得数组元素的个数\nlength=${#array_name[@]}\n# 或者\nlength=${#array_name[*]}\n# 取得数组单个元素的长度\nlengthn=${#array_name[n]}\n```\n\n------\n\n### Shell 注释\n\n以 **#** 开头的行就是注释，会被解释器忽略。\n\n通过每一行加一个 **#** 号设置多行注释，像这样：\n\n```bash\n# 这是一个注释\n```\n\n#### 多行注释\n\n多行注释还可以使用以下格式：\n\n```bash\n:<<EOF\n注释内容...\nEOF\n```\n\nEOF 也可以使用其他符号:\n\n```bash\n:<<\'\n注释内容...\n\'\n\n:<<!\n注释内容...\n!\n```\n\n## Shell 传递参数\n\n我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……\n\n**例子**\n\n以下实例我们向脚本传递三个参数，并分别输出，其中 **$0** 为执行的文件名：\n\n```bash\n#!/bin/bash\necho \"Shell 传递参数实例！\";\necho \"执行的文件名：$0\";\necho \"第一个参数为：$1\";\necho \"第二个参数为：$2\";\necho \"第三个参数为：$3\";\n```\n\n为脚本设置可执行权限，并执行脚本，输出结果如下所示：\n\n```bash\n$ chmod +x test.sh \n$ ./test.sh 1 2 3\nShell 传递参数实例！\n执行的文件名：./test.sh\n第一个参数为：1\n第二个参数为：2\n第三个参数为：3\n```\n\n另外，还有几个特殊字符用来处理参数：\n\n| 参数处理 | 说明                                                         |\n| :------- | :----------------------------------------------------------- |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数。 如\"`$*`\"用「\"」括起来的情况、以\"`$1 $2 … $n`\"的形式输出所有参数。 |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $@       | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。 如\"​`$@`\"用「\"」括起来的情况、以`\"$1\" \"$2\" … \"$n\"` 的形式输出所有参数。 |\n| $-       | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n```bash\n#!/bin/bash\necho \"Shell 传递参数实例！\";\necho \"第一个参数为：$1\";\necho \"参数个数为：$#\";\necho \"传递的参数作为一个字符串显示：$*\";\n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n$ chmod +x test.sh \n$ ./test.sh 1 2 3\nShell 传递参数实例！\n第一个参数为：1\n参数个数为：3\n传递的参数作为一个字符串显示：1 2 3\n```\n\n$* 与 $@ 区别：\n\n- 相同点：都是引用所有参数。\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n\n```bash\n#!/bin/bash\necho \"-- \\$* 演示 ---\"\nfor i in \"$*\"; do\n    echo $i\ndone\n\necho \"-- \\$@ 演示 ---\"\nfor i in \"$@\"; do\n    echo $i\ndone\n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n$ chmod +x test.sh \n$ ./test.sh 1 2 3\n-- $* 演示 ---\n1 2 3\n-- $@ 演示 ---\n1\n2\n3\n```\n\n## Shell 数组\n\n数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时*不需要定义数组大小*（与 PHP 类似）。\n\n与大部分编程语言类似，数组元素的下标由0开始。\n\nShell 数组用括号来表示，元素用\"空格\"符号分割开，语法格式如下：\n\n```bash\narray_name=(value1 ... valuen)\n```\n\n### 实例\n\n```bash\n#!/bin/bash\nmy_array=(A B \"C\" D)\n```\n\n我们也可以使用下标来定义数组:\n\n```bash\narray_name[0]=value0\narray_name[1]=value1\narray_name[2]=value2\n```\n\n### 读取数组\n\n读取数组元素值的一般格式是：\n\n```bash\n${array_name[index]}\n```\n\n### 实例\n\n```bash\n#!/bin/bash\nmy_array=(A B \"C\" D)\n\necho \"第一个元素为: ${my_array[0]}\"\necho \"第二个元素为: ${my_array[1]}\"\n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n$ chmod +x test.sh \n$ ./test.sh\n第一个元素为: A\n第二个元素为: B\n```\n\n### 获取数组中的所有元素\n\n使用@ 或 * 可以获取数组中的所有元素，例如：\n\n```bash\n#!/bin/bash\nmy_array[0]=A\nmy_array[1]=B\n\necho \"数组的元素为: ${my_array[*]}\"\necho \"数组的元素为: ${my_array[@]}\"\n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n$ chmod +x test.sh \n$ ./test.sh\n数组的元素为: A B\n数组的元素为: A B\n```\n\n### 获取数组的长度\n\n获取数组长度的方法与获取字符串长度的方法相同，例如：\n\n```bash\n#!/bin/bash\nmy_array[0]=A\nmy_array[1]=B\nmy_array[2]=C\nmy_array[3]=D\n\necho \"数组元素个数为: ${#my_array[*]}\"\necho \"数组元素个数为: ${#my_array[@]}\"\n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n$ chmod +x test.sh \n$ ./test.sh\n数组元素个数为: 4\n数组元素个数为: 4\n```\n\n## Shell 基本运算符\n\nShell 和其他编程语言一样，支持多种运算符，包括：\n\n- 算数运算符\n- 关系运算符\n- 布尔运算符\n- 字符串运算符\n- 文件测试运算符\n\n原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 *awk 和 expr*，expr 最常用。\n\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n\n例如，两个数相加(**注意使用的是反引号 ` 而不是单引号 \'**)：\n\n**例如：**\n\n```bash\n#!/bin/bash\n\nval=`expr 2 + 2`\necho \"两数之和为 : $val\" #4\n```\n\n两点注意：\n\n- 表达式和运算符之间**要有空格**，例如 2+2 是不对的，必须写成 2 + 2\n- 完整的表达式要被反引号（`）包含\n\n### 算术运算符\n\n下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n\n| 运算符 | 说明                                          | 举例                           |\n| :----- | :-------------------------------------------- | :----------------------------- |\n| +      | 加法                                          | `expr $a + $b` 结果为 30。     |\n| -      | 减法                                          | `expr $a - $b` 结果为 -10。    |\n| *      | 乘法                                          | `expr $a \\* $b` 结果为  200。  |\n| /      | 除法                                          | `expr $b / $a` 结果为 2。      |\n| %      | 取余                                          | `expr $b % $a` 结果为 0。      |\n| =      | 赋值                                          | `a=$b` 将把变量 b 的值赋给 a。 |\n| ==     | 相等。用于比较两个数字，相同则返回 true。     | `[ $a == $b ]` 返回 false。    |\n| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | `[ $a != $b ]` 返回 true。     |\n\n**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **`[$a==$b]`** 是错误的，必须写成 **`[ $a == $b ]`**。\n\n> **注意：**\n>\n> - 乘号(*)前边必须加反斜杠(`\\`)才能实现乘法运算；\n> - 在 MAC 中 shell 的 expr 语法是：**$((表达式))**，此处表达式中的 \"*\" 不需要转义符号 \"`\\`\" 。\n\n### 关系运算符\n\n关系运算符**只支持数字**，不支持字符串，除非字符串的值是数字。\n\n下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\n\n| 运算符 | 说明                                                      | 举例                         |\n| :----- | :-------------------------------------------------------- | :--------------------------- |\n| -eq    | 检测两个数是否**相等**，相等返回 true。                   | `[ $a -eq $b ] `返回 false。 |\n| -ne    | 检测两个数是否**不相等**，不相等返回 true。               | `[ $a -ne $b ] `返回 true。  |\n| -gt    | 检测左边的数是否**大于**右边的，如果是，则返回 true。     | `[ $a -gt $b ] `返回 false。 |\n| -lt    | 检测左边的数是否**小于**右边的，如果是，则返回 true。     | `[ $a -lt $b ]` 返回 true。  |\n| -ge    | 检测左边的数是否**大于等于右边**的，如果是，则返回 true。 | `[ $a -ge $b ]` 返回 false。 |\n| -le    | 检测左边的数是否**小于等于**右边的，如果是，则返回 true。 | `[ $a -le $b ]` 返回 true。  |\n\n### 布尔运算符\n\n下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：\n\n| 运算符 | 说明                                                | 举例                                       |\n| :----- | :-------------------------------------------------- | :----------------------------------------- |\n| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | `[ ! false ] `返回 true。                  |\n| -o     | 或运算，有一个表达式为 true 则返回 true。           | `[ $a -lt 20 -o $b -gt 100 ]` 返回 true。  |\n| -a     | 与运算，两个表达式都为 true 才返回 true。           | `[ $a -lt 20 -a $b -gt 100 ]` 返回 false。 |\n\n### 逻辑运算符\n\n以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:\n\n| 运算符 | 说明       | 举例                                        |\n| :----- | :--------- | :------------------------------------------ |\n| &&     | 逻辑的 AND | `[[ $a -lt 100 && $b -gt 100 ]]` 返回 false |\n| \\|\\|   | 逻辑的 OR  | `[[ $a -lt 100 || $b -gt 100 ]]` 返回 true  |\n\n### 字符串运算符\n\n下表列出了常用的字符串运算符，假定变量 a 为 \"abc\"，变量 b 为 \"efg\"：\n\n| 运算符 | 说明                                             | 举例                       |\n| :----- | :----------------------------------------------- | :------------------------- |\n| =      | 检测两个字符串是否**相等**，相等返回 true。      | `[ $a = $b ] `返回 false。 |\n| !=     | 检测两个字符串是否相等，**不相等**返回 true。    | `[ $a != $b ]` 返回 true。 |\n| -z     | 检测字符串**长度是否为0**，为0返回 true。        | `[ -z $a ] `返回 false。   |\n| -n     | 检测字符串**长度是否不为 0**，不为 0 返回 true。 | `[ -n \"$a\" ]` 返回 true。  |\n| $      | 检测**字符串是否为空**，不为空返回 true。        | `[ $a ] `返回 true。       |\n\n### 文件测试运算符\n\n文件测试运算符用于**检测 Unix 文件的各种属性**。\n\n属性检测描述如下：\n\n| 操作符  | 说明                                                         | 举例                        |\n| :------ | :----------------------------------------------------------- | :-------------------------- |\n| -b file | 检测文件是否是**块设备文件**，如果是，则返回 true。          | `[ -b $file ] `返回 false。 |\n| -c file | 检测文件是否是**字符设备文件**，如果是，则返回 true。        | `[ -c $file ] `返回 false。 |\n| -d file | 检测文件是否是**目录**，如果是，则返回 true。                | `[ -d $file ]` 返回 false。 |\n| -f file | 检测文件是否是**普通文件**（既不是目录，也不是设备文件），如果是，则返回 true。 | `[ -f $file ]` 返回 true。  |\n| -g file | 检测文件是否**设置了 SGID 位**，如果是，则返回 true。        | `[ -g $file ] `返回 false。 |\n| -k file | 检测文件是否**设置了粘着位**(Sticky Bit)，如果是，则返回 true。 | `[ -k $file ] `返回 false。 |\n| -p file | 检测文件是否是**有名管道**，如果是，则返回 true。            | `[ -p $file ]` 返回 false。 |\n| -u file | 检测文件是否设置了 **SUID 位**，如果是，则返回 true。        | `[ -u $file ] `返回 false。 |\n| -r file | 检测文件是否**可读**，如果是，则返回 true。                  | `[ -r $file ] `返回 true。  |\n| -w file | 检测文件是否**可写**，如果是，则返回 true。                  | `[ -w $file ]` 返回 true。  |\n| -x file | 检测文件是否**可执行**，如果是，则返回 true。                | `[ -x $file ] `返回 true。  |\n| -s file | 检测**文件是否为空**（文件大小是否大于0），不为空返回 true。 | `[ -s $file ] `返回 true。  |\n| -e file | 检测文件（包括目录）**是否存在**，如果是，则返回 true。      | `[ -e $file ] `返回 true。  |\n\n其他检查符：\n\n- **-S**: 判断某文件**是否 socket**。\n- **-L**: 检测文件是否存在并且是一个**符号链接**。\n\n## Shell echo命令\n\nShell 的 echo 指令与 PHP 的 echo 指令类似，都是用于**字符串的输出**。命令格式：\n\n```bash\necho string\n```\n\n您可以使用echo实现更复杂的输出格式控制。\n\n### 显示普通字符串:\n\n```bash\necho \"It is a test\" \n```\n\n这里的**双引号完全可以省略**，以下命令与上面实例效果一致：\n\n```bash\necho It is a test\n```\n\n### 显示转义字符\n\n```bash\necho \"\\\"It is a test\\\"\"\n```\n\n结果将是:\n\n```bash\n\"It is a test\"\n```\n\n同样，双引号也可以省略\n\n### 显示变量\n\n**read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量**\n\n```bash\n#!/bin/sh\nread name \necho \"$name It is a test\"\n```\n\n以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:\n\n```bash\n[root@www ~]# sh test.sh\nOK                     #标准输入\nOK It is a test        #输出\n```\n\n### 显示换行\n\n```bash\necho -e \"OK! \\n\" # -e 开启转义\necho \"It is a test\"\n```\n\n输出结果：\n\n```bash\nOK!\n\nIt is a test\n```\n\n### 显示不换行\n\n```bash\n#!/bin/sh\necho -e \"OK! \\c\" # -e 开启转义 \\c 不换行\necho \"It is a test\"\n```\n\n输出结果：\n\n```bash\nOK! It is a test\n```\n\n### 显示结果定向至文件\n\n```bash\necho \"It is a test\" > myfile\n```\n\n### 原样输出字符串，不进行转义或取变量(用单引号)\n\n```bash\necho \'$name\\\"\'\n```\n\n输出结果：\n\n```bash\n$name\\\"\n```\n\n### 显示命令执行结果\n\n```bash\necho `date`\n```\n\n**注意：** 这里使用的是**反引号** **`**, 而不是单引号 **\'**。\n\n结果将显示当前日期\n\n```bash\nThu Jul 24 10:08:46 CST 2014\n```\n\n## Shell printf 命令\n\n> printf 命令模仿 C 程序库（library）里的 printf() 程序。\n>\n> printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。\n>\n> printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n。\n\nprintf 命令的语法：\n\n```bash\nprintf  format-string  [arguments...]\n```\n\n**参数说明：**\n\n- **format-string:** 为格式控制字符串\n- **arguments:** 为参数列表。\n\n实例如下：\n\n```bash\n$ echo \"Hello, Shell\"\nHello, Shell\n$ printf \"Hello, Shell\\n\"\nHello, Shell\n```\n\n接下来,我来用一个脚本来体现printf的强大功能：\n\n```bash\n#!/bin/bash\nprintf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  \nprintf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 \n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n姓名     性别   体重kg\n郭靖     男      66.12\n```\n\n%s %c %d %f都是格式替代符\n\n%-10s 指一个宽度为10个字符（**-表示左对齐**，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。\n\n%-4.2f 指格式化为小数，其中.2指保留2位小数。\n\n更多实例：\n\n```bash\n#!/bin/bash\n# format-string为双引号\nprintf \"%d %s\\n\" 1 \"abc\"\n# 单引号与双引号效果一样 \nprintf \'%d %s\\n\' 1 \"abc\" \n# 没有引号也可以输出\nprintf %s abcdef\n# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用\nprintf %s abc def\nprintf \"%s\\n\" abc def\nprintf \"%s %s %s\\n\" a b c d e f g h i j\n# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替\nprintf \"%s and %d \\n\" \n```\n\n执行脚本，输出结果如下所示：\n\n```bash\n1 abc\n1 abc\nabcdefabcdefabc\ndef\na b c\nd e f\ng h i\nj  \n and 0\n```\n\n### printf的转义序列\n\n| 序列  | 说明                                                         |\n| :---- | :----------------------------------------------------------- |\n| \\a    | 警告字符，通常为ASCII的BEL字符                               |\n| \\b    | 后退                                                         |\n| \\c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |\n| \\f    | 换页（formfeed）                                             |\n| \\n    | 换行                                                         |\n| \\r    | 回车（Carriage return）                                      |\n| \\t    | 水平制表符                                                   |\n| \\v    | 垂直制表符                                                   |\n| \\\\    | 一个字面上的反斜杠字符                                       |\n| \\ddd  | 表示1到3位数八进制值的字符。仅在格式字符串中有效             |\n| \\0ddd | 表示1到3位的八进制值字符                                     |\n\n**实例**\n\n```bash\nprintf \"a string, no processing:<%s>\\n\" \"A\\nB\"\n#a string, no processing:<A\\nB>\n\nprintf \"a string, no processing:<%b>\\n\" \"A\\nB\"\na string, no processing:<A\nB>\n\nprintf \"www.runoob.com \\a\"\nwww.runoob.com                  #不换行\n```\n\n## Shell test 命令\n\nShell中的 test 命令用于**检查某个条件是否成立**，它可以进行数值、字符和文件三个方面的测试。\n\n### 数值测试\n\n| 参数 | 说明           |\n| :--- | :------------- |\n| -eq  | 等于则为真     |\n| -ne  | 不等于则为真   |\n| -gt  | 大于则为真     |\n| -ge  | 大于等于则为真 |\n| -lt  | 小于则为真     |\n| -le  | 小于等于则为真 |\n\n实例演示：\n\n```bash\nnum1=100\nnum2=100\nif test $[num1] -eq $[num2]\nthen\n    echo \'两个数相等！\'\nelse\n    echo \'两个数不相等！\'\nfi\n```\n\n输出结果：\n\n```bash\n两个数相等！\n```\n\n**代码中的 [] 执行基本的算数运算**，如：\n\n```bash\n#!/bin/bash\n\na=5\nb=6\n\nresult=$[a+b] # 注意等号两边不能有空格\necho \"result 为： $result\"\n```\n\n结果为:\n\n```\nresult 为： 11\n```\n\n### 字符串测试\n\n| 参数      | 说明                       |\n| :-------- | :------------------------- |\n| =         | 等于则为真                 |\n| !=        | 不相等则为真               |\n| -z 字符串 | 字符串的**长度为零**则为真 |\n| -n 字符串 | 字符串的长度不为零则为真   |\n\n实例演示：\n\n```bash\nnum1=\"ru1noob\"\nnum2=\"runoob\"\nif test $num1 = $num2\nthen\n    echo \'两个字符串相等!\'\nelse\n    echo \'两个字符串不相等!\'\nfi\n```\n\n输出结果：\n\n```bash\n两个字符串不相等!\n```\n\n### 文件测试\n\n| 参数      | 说明                                 |\n| :-------- | :----------------------------------- |\n| -e 文件名 | 如果文件存在则为真                   |\n| -r 文件名 | 如果文件存在且可读则为真             |\n| -w 文件名 | 如果文件存在且可写则为真             |\n| -x 文件名 | 如果文件存在且可执行则为真           |\n| -s 文件名 | 如果文件存在且至少有一个字符则为真   |\n| -d 文件名 | 如果文件存在且为目录则为真           |\n| -f 文件名 | 如果文件存在且为普通文件则为真       |\n| -c 文件名 | 如果文件存在且为字符型特殊文件则为真 |\n| -b 文件名 | 如果文件存在且为块特殊文件则为真     |\n\n实例演示：\n\n```bash\ncd /bin\nif test -e ./bash\nthen\n    echo \'文件已存在!\'\nelse\n    echo \'文件不存在!\'\nfi\n```\n\n输出结果：\n\n```bash\n文件已存在!\n```\n\n另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：\"!\"最高，\"-a\"次之，\"-o\"最低。例如：\n\n```bash\ncd /bin\nif test -e ./notFile -o -e ./bash\nthen\n    echo \'至少有一个文件存在!\'\nelse\n    echo \'两个文件都不存在\'\nfi\n```\n\n输出结果：\n\n```bash\n至少有一个文件存在!\n```\n\n## Shell 流程控制\n\n### if else\n\n#### if\n\nif 语句语法格式：\n\n```bash\nif condition\nthen\n    command1 \n    ...\n    commandN \nfi\n```\n\n写成一行（适用于终端命令提示符）：\n\n```bash\nif [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; then echo \"true\"; fi\n```\n\n末尾的fi就是if倒过来拼写，后面还会遇到类似的。\n\n#### if else\n\nif else 语法格式：\n\n```bash\nif condition\nthen\n    command1 \n    ...\n    commandN\nelse\n    command\nfi\n```\n\n#### if else-if else\n\nif else-if else 语法格式：\n\n```bash\nif condition1\nthen\n    command1\nelif condition2 \nthen \n    command2\nelse\n    commandN\nfi\n```\n\nif else语句经常与test命令结合使用，如下所示：\n\n```bash\nnum1=$[2*3]\nnum2=$[1+5]\nif test $[num1] -eq $[num2]\nthen\n    echo \'两个数字相等!\'\nelse\n    echo \'两个数字不相等!\'\nfi\n```\n\n输出结果：\n\n```bash\n两个数字相等!\n```\n\n### for 循环\n\n与其他编程语言类似，Shell支持for循环。\n\nfor循环一般格式为：\n\n```bash\nfor var in item1 item2 ... itemN\ndo\n    command1\n    ...\n    commandN\ndone\n```\n\n写成一行：\n\n```bash\nfor var in item1 item2 ... itemN; do command1; command2… done;\n```\n\n当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。\n\nin列表是可选的，如果不用它，for循环使用命令行的位置参数。\n\n例如，顺序输出当前列表中的数字：\n\n```bash\nfor loop in 1 2 3 4 5\ndo\n    echo \"The value is: $loop\"\ndone\n```\n\n输出结果：\n\n```bash\nThe value is: 1\nThe value is: 2\nThe value is: 3\nThe value is: 4\nThe value is: 5\n```\n\n顺序输出字符串中的字符：\n\n```bash\nfor str in \'This is a string\'\ndo\n    echo $str\ndone\n```\n\n输出结果：\n\n```bash\nThis is a string \n```\n\n### while 语句\n\nwhile循环用于**不断执行一系列命令**，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：\n\n```bash\nwhile condition\ndo\n    command\ndone\n```\n\n以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。\n\n```bash\n#!/bin/bash\nint=1\nwhile(( $int<=5 ))\ndo\n    echo $int\n    let \"int++\"\ndone\n```\n\n运行脚本，输出：\n\n```bash\n1\n2\n3\n4\n5\n```\n\n以上实例使用了 Bash **let 命令**，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：[Bash let 命令](https://www.runoob.com/linux/linux-comm-let.html)。\n\nwhile循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按``<Ctrl-D>``结束循环。\n\n```bash\necho \'按下 <CTRL-D> 退出\'\necho -n \'输入你最喜欢的网站名: \'\nwhile read FILM\ndo\n    echo \"是的！$FILM 是一个好网站\"\ndone\n```\n\n运行脚本，输出类似下面：\n\n```bash\n按下 <CTRL-D> 退出\n输入你最喜欢的网站名:菜鸟教程\n是的！菜鸟教程 是一个好网站\n```\n\n#### 无限循环\n\n无限循环语法格式：\n\n```bash\nwhile :\ndo\n    command\ndone\n```\n\n或者\n\n```bash\nwhile true\ndo\n    command\ndone\n```\n\n或者\n\n```bash\nfor (( ; ; ))\n```\n\n### until 循环\n\nuntil 循环执行一系列命令直至条件为 true 时停止。\n\nuntil 循环与 while 循环在处理方式上刚好相反。\n\n一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。\n\nuntil 语法格式:\n\n```bash\nuntil condition\ndo\n    command\ndone\n```\n\ncondition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。\n\n以下实例我们使用 until 命令来输出 0 ~ 9 的数字：\n\n```bash\n#!/bin/bash\n\na=0\n\nuntil [ ! $a -lt 5 ]\ndo\n   echo $a\n   a=`expr $a + 1`\ndone\n```\n\n运行结果：\n\n输出结果为：\n\n```bash\n0\n1\n2\n3\n4\n```\n\n### case\n\nShell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：\n\n```bash\ncase 值 in\n模式1)\n    command1\n    command2\n    ...\n    commandN\n    ;;\n模式2）\n    command1\n    command2\n    ...\n    commandN\n    ;;\nesac\n```\n\ncase工作方式如上所示。取值后面必须为单词in，每一模式必须以**右括号结束**。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 **;;**。\n\n取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用**星号 * 捕获该值**，再执行后面的命令。\n\n下面的脚本提示输入1到4，与每一种模式进行匹配：\n\n```bash\necho \'输入 1 到 4 之间的数字:\'\necho \'你输入的数字为:\'\nread aNum\ncase $aNum in\n    1)  echo \'你选择了 1\'\n    ;;\n    2)  echo \'你选择了 2\'\n    ;;\n    3)  echo \'你选择了 3\'\n    ;;\n    4)  echo \'你选择了 4\'\n    ;;\n    *)  echo \'你没有输入 1 到 4 之间的数字\'\n    ;;\nesac\n```\n\n输入不同的内容，会有不同的结果，例如：\n\n```bash\n输入 1 到 4 之间的数字:\n你输入的数字为:\n3\n你选择了 3\n```\n\n### 跳出循环\n\n在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。\n\n#### break命令\n\nbreak命令允许跳出所有循环（终止执行后面的所有循环）。\n\n下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。\n\n```bash\n#!/bin/bash\nwhile :\ndo\n    echo -n \"输入 1 到 5 之间的数字:\"\n    read aNum\n    case $aNum in\n        1|2|3|4|5) echo \"你输入的数字为 $aNum!\"\n        ;;\n        *) echo \"你输入的数字不是 1 到 5 之间的! 游戏结束\"\n            break\n        ;;\n    esac\ndone\n```\n\n执行以上代码，输出结果为：\n\n```bash\n输入 1 到 5 之间的数字:3\n你输入的数字为 3!\n输入 1 到 5 之间的数字:7\n你输入的数字不是 1 到 5 之间的! 游戏结束\n```\n\n#### continue\n\ncontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。\n\n对上面的例子进行修改：\n\n```bash\n#!/bin/bash\nwhile :\ndo\n    echo -n \"输入 1 到 5 之间的数字: \"\n    read aNum\n    case $aNum in\n        1|2|3|4|5) echo \"你输入的数字为 $aNum!\"\n        ;;\n        *) echo \"你输入的数字不是 1 到 5 之间的!\"\n            continue\n            echo \"游戏结束\"\n        ;;\n    esac\ndone\n```\n\n运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 **echo \"游戏结束\"** 永远不会被执行。\n\n### case ... esac\n\n**case ... esac** 与其他语言中的 switch ... case 语句类似，是一种**多分枝选择结构**，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。\n\ncase ... esac 语法格式如下：\n\n```bash\ncase 值 in\n模式1)\n    command1\n    command2\n    command3\n    ;;\n模式2）\n    command1\n    command2\n    command3\n    ;;\n*)\n    command1\n    command2\n    command3\n    ;;\nesac\n```\n\ncase 后为取值，值可以为变量或常数。\n\n值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。\n\n#### 实例\n\n```bash\n#!/bin/sh\n\nsite=\"runoob\"\n\ncase \"$site\" in\n   \"runoob\") echo \"菜鸟教程\"\n   ;;\n   \"google\") echo \"Google 搜索\"\n   ;;\n   \"taobao\") echo \"淘宝网\"\n   ;;\nesac\n```\n\n输出结果为：\n\n```bash\n菜鸟教程\n```\n\n## Shell 函数\n\nlinux shell 可以用户定义函数，然后在shell脚本中可以随便调用。\n\nshell中函数的定义格式如下：\n\n```bash\n[ function ] funname [()]\n{\n    action;\n    [return int;]\n}\n```\n\n说明：\n\n- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\n\n下面的例子定义了一个函数并进行调用：\n\n```bash\n#!/bin/bash\ndemoFun(){\n    echo \"这是我的第一个 shell 函数!\"\n}\necho \"-----函数开始执行-----\"\ndemoFun\necho \"-----函数执行完毕-----\"\n```\n\n输出结果：\n\n```bash\n-----函数开始执行-----\n这是我的第一个 shell 函数!\n-----函数执行完毕-----\n```\n\n下面定义一个带有return语句的函数：\n\n```bash\n#!/bin/bash\nfunWithReturn(){\n    echo \"这个函数会对输入的两个数字进行相加运算...\"\n    echo \"输入第一个数字: \"\n    read aNum\n    echo \"输入第二个数字: \"\n    read anotherNum\n    echo \"两个数字分别为 $aNum 和 $anotherNum !\"\n    return $(($aNum+$anotherNum))\n}\nfunWithReturn\necho \"输入的两个数字之和为 $? !\"\n```\n\n输出类似下面：\n\n```bash\n这个函数会对输入的两个数字进行相加运算...\n输入第一个数字: \n1\n输入第二个数字: \n2\n两个数字分别为 1 和 2 !\n输入的两个数字之和为 3 !\n```\n\n函数返回值在调用该函数后通过 `$? `来获得。\n\n注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。\n\n### 函数参数\n\n在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 `$n` 的形式来获取参数的值，例如，`$1`表示第一个参数，`$2`表示第二个参数...\n\n带参数的函数示例：\n\n```bash\n#!/bin/bash\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n```\n\n输出结果：\n\n```bash\n第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n```\n\n注意，`$10` 不能获取第十个参数，获取第十个参数需要``${10}``。当n>=10时，需要使用`${n}`来获取参数。\n\n另外，还有几个特殊字符用来处理参数：\n\n| 参数处理 | 说明                                                         |\n| :------- | :----------------------------------------------------------- |\n| $#       | 传递到脚本或函数的**参数个数**                               |\n| $*       | 以一个单字符串显示所有向脚本传递的参数                       |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n## Shell 输入/输出重定向\n\n> 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。\n\n重定向命令列表如下：\n\n| 命令            | 说明                                               |\n| :-------------- | :------------------------------------------------- |\n| command > file  | 将输出重定向到 file。                              |\n| command < file  | 将输入重定向到 file。                              |\n| command >> file | 将输出以追加的方式重定向到 file。                  |\n| n > file        | 将文件描述符为 n 的文件重定向到 file。             |\n| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |\n| n >& m          | 将输出文件 m 和 n 合并。                           |\n| n <& m          | 将输入文件 m 和 n 合并。                           |\n| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |\n\n> 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。\n\n### 输出重定向\n\n重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:\n\n```bash\ncommand1 > file1\n```\n\n上面这个命令执行command1然后将输出的内容存入file1。\n\n注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。\n\n#### 实例\n\n执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):\n\n```bash\n$ who > users\n```\n\n执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。\n\n你可以使用 cat 命令查看文件内容：\n\n```bash\n$ cat users\n_mbsetupuser console  Oct 31 17:35 \ntianqixin    console  Oct 31 17:35 \ntianqixin    ttys000  Dec  1 11:33 \n```\n\n输出重定向会覆盖文件内容，请看下面的例子：\n\n```bash\n$ echo \"菜鸟教程：www.runoob.com\" > users\n$ cat users\n菜鸟教程：www.runoob.com\n```\n\n如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：\n\n```bash\n$ echo \"菜鸟教程：www.runoob.com\" >> users\n$ cat users\n菜鸟教程：www.runoob.com\n菜鸟教程：www.runoob.com\n```\n\n### 输入重定向\n\n和输出重定向一样，Unix 命令也可以**从文件获取输入**，语法为：\n\n```bash\ncommand1 < file1\n```\n\n这样，本来需要从键盘获取输入的命令会转移到文件读取内容。\n\n注意：输出重定向是大于号(>)，输入重定向是小于号(<)。\n\n#### 实例\n\n接着以上实例，我们需要统计 users 文件的行数,执行以下命令：\n\n```bash\n$ wc -l users\n       2 users\n```\n\n也可以将输入重定向到 users 文件：\n\n```bash\n$  wc -l < users\n       2 \n```\n\n注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。\n\n```bash\ncommand1 < infile > outfile\n```\n\n同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。\n\n#### 重定向深入讲解\n\n一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n\n- **标准输入文件(stdin)**：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n- **标准输出文件(stdout)**：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n- **标准错误文件(stderr)：**stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。\n\n如果希望 stderr 重定向到 file，可以这样写：\n\n```bash\n$ command 2 > file\n```\n\n如果希望 stderr 追加到 file 文件末尾，可以这样写：\n\n```bash\n$ command 2 >> file\n```\n\n**2** 表示标准错误文件(stderr)。\n\n如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：\n\n```bash\n$ command > file 2>&1\n或者\n$ command >> file 2>&1\n```\n\n如果希望对 stdin 和 stdout 都重定向，可以这样写：\n\n```bash\n$ command < file1 >file2\n```\n\ncommand 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。\n\n### Here Document\n\nHere Document 是 Shell 中的一种**特殊的重定向方式**，用来将**输入重定向到一个交互式 Shell 脚本或程序。**\n\n它的基本的形式如下：\n\n```bash\ncommand << delimiter\n    document\ndelimiter\n```\n\n它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。\n\n> 注意：\n>\n> - 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。\n> - 开始的delimiter前后的空格会被忽略掉。\n\n#### 实例\n\n在命令行中通过 wc -l 命令计算 Here Document 的行数：\n\n```bash\n$ wc -l << EOF\n    欢迎来到\n    菜鸟教程\n    www.runoob.com\nEOF\n3          # 输出结果为 3 行\n```\n\n我们也可以将 Here Document 用在脚本中，例如：\n\n```bash\n#!/bin/bash\ncat << EOF\n欢迎来到\n菜鸟教程\nwww.runoob.com\nEOF\n```\n\n执行以上脚本，输出结果：\n\n```bash\n欢迎来到\n菜鸟教程\nwww.runoob.com\n```\n\n### /dev/null 文件\n\n如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：\n\n```bash\n$ command > /dev/null\n```\n\n/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到\"禁止输出\"的效果。\n\n如果希望屏蔽 stdout 和 stderr，可以这样写：\n\n```bash\n$ command > /dev/null 2>&1\n```\n\n> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。\n\n## Shell 文件包含\n\n和其他语言一样，Shell 也可以**包含外部脚本**。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n\nShell 文件包含的语法格式如下：\n\n```bash\n. filename   # 注意点号(.)和文件名中间有一空格\n或\nsource filename\n```\n\n#### 实例\n\n创建两个 shell 脚本文件。\n\ntest1.sh 代码如下：\n\n```bash\n#!/bin/bash\nurl=\"http://www.runoob.com\"\n```\n\ntest2.sh 代码如下：\n\n```bash\n#!/bin/bash\n#使用 . 号来引用test1.sh 文件\n. ./test1.sh\n\n# 或者使用以下包含文件代码\n# source ./test1.sh\n\necho \"菜鸟教程官网地址：$url\"\n```\n\n接下来，我们为 test2.sh 添加可执行权限并执行：\n\n```bash\n$ chmod +x test2.sh \n$ ./test2.sh \n菜鸟教程官网地址：http://www.runoob.com\n```\n\n> **注：**被包含的文件 test1.sh 不需要可执行权限。', 'Shell使用', 1592841600, 32);
INSERT INTO `article` VALUES (5, 2, 'next.js', '\n# Next.js\n\n>  Next.js 是一个轻量级的 React 服务端渲染应用框架。有了它我们可以简单轻松的实现React的**服务端渲染**，从而加快首屏打开速度，也可以作**SEO**（收索引擎优化了）。在没有Next.js的时候，用React开发需要配置很多繁琐的参数，如Webpack配置，Router配置和服务器端配置等....。如果需要作SEO，要考虑的事情就更多了，怎么样服务端渲染和客户端渲染保持一致就是一件非常麻烦的事情，需要引入很多第三方库。但有了Next.js，这些问题都解决了，使开发人员可以将精力放在业务逻辑上，从繁琐的配置中解放出来。 \n\n## 简介\n\n> Next.js 是一个轻量级的 React 服务端渲染应用框架。\n\n用一个框架，就要知道它的优点（或者是解决了我们什么问题）:\n\n- 完善的React项目架构，搭建轻松。比如：Webpack配置，服务器启动，路由配置，缓存能力，这些在它内部已经完善的为我们搭建完成了。\n- 自带数据同步策略，解决服务端渲染最大难点。把服务端渲染好的数据，拿到客户端重用，这个在没有框架的时候，是非常复杂和困难的。有了Next.js，它为我们提供了非常好的解决方法，让我们轻松的就可以实现这些步骤。\n- 丰富的插件帮开发人员增加各种功能。每个项目的需求都是不一样的，包罗万象。无所不有，它为我们提供了插件机制，让我们可以在使用的时候按需使用。你也可以自己写一个插件，让别人来使用。\n- 灵活的配置，让开发变的更简单。它提供很多灵活的配置项，可以根据项目要求的不同快速灵活的进行配置。\n\n目前Next.js是React服务端渲染的最佳解决方案，所以如果想使用React来开发需要SEO的应用，基本上就要使用Next.js。\n\n## create-next-app 快速创建Next.js项目\n\n**项目结构介绍**：\n\n- **components**文件夹:这里是专门放置自己写的组件的，这里的组件不包括页面，指公用的或者有专门用途的组件。\n- **node_modules**文件夹：Next项目的所有依赖包都在这里，一般我们不会修改和编辑这里的内容。\n- **pages**文件夹：这里是放置页面的，这里边的内容会自动生成路由，并在服务器端渲染，渲染好后进行数据同步。\n- **public**文件夹： 这个是静态文件夹，比如项目需要的图片、图标和静态资源都可以放到这里。\n- **.gitignore**文件： 这个主要是控制git提交和上传文件的，简称就是忽略提交。\n- **package.json**文件：定义了项目所需要的文件和项目的配置信息（名称、版本和许可证），最主要的是使用`npm install` 就可以下载项目所需要的所有包。\n\n## Page和Component的使用\n\n直接在**pages**文件夹下，新建一个`xxx.js`页面，写好相应的代码后，`Next`框架就自动做好了路由。如果要做更深的路由，在pages文件夹下再建相应的文件夹，然后在新的文件夹里面新建页面，以此类推即可。\n\npages里面的文件名和components文件夹里面的文件名可以相同，不会冲突。\n\n在components文件夹目录新建组件，在pages里面引入即可。\n\n## 路由-基础和基本跳转\n\n路由跳转两种形式：\n\n* **标签式导航**：利用标签`<Link>`\n\n  *引入*：`import Link from \'next/link\'`\n\n  *使用*：`<Link href=\"/\"><a>返回首页</a></Link>`\n\n  *注意*：不写`<a>`标签时不支持兄弟标签并列，使用`<a>`便可使用\n\n  ```react\n  <Link href=\"/jspangA\">\n    <a>\n      <span>去JspangA页面</span>\n      <span>前端博客</span>\n    </a>\n  </Link>\n  ```\n\n* **编程式跳转**：用js编程的方式进行跳转，也就是利用`Router`组件\n\n  *引入*：`import Router from \'next/router\'`\n\n  *使用：* `<button onClick={()=>{Router.push(\'/jspangA\')}}>去JspangA页面</button>`这种写法简单，但是耦合性太高，可以修改一下 ，把跳转放到一个方法里，然后调用方法。\n\n  ```js\n  function gotoA(){\n      Router.push(\'/jspangA\')\n  }\n  \n  <button onClick={gotoA}>去JspangA页面</button>\n  ```\n\n## 路由-跳转时用query传递和接收参数\n\n项目开发中一般需要**动态跳转**，动态跳转就是跳转时需要带一个参数或几个参数过去，然后在到达的页面接受这个传递的参数，并根据参数不同显示不同的内容。比如新闻列表，然后点击一个要看的新闻就会跳转到具体内容。这些类似这样的需求都都是通过传递参数实现的。\n\n**只能用query传递参数**：在`Next.js`中只能通过通过query（`?id=1`）来传递参数，而不能通过(`path:id`)的形式传递参数。\n\n**标签式导航传递参数：**\n\n​	`<Link href=\"/jpangA?name=技胖\"><a>技胖</a></Link>`\n\n​		或者（优雅的写法）：`<Link href={{pathname:\'/jpangA\',query:{name:\'技胖\'}}}><a>技胖</a></Link>`，这种写法有两个参数，一个是`pathname`，一个是`query`，`query`里面包含传递的参数\n\n**编程式跳转传递参数：**\n\n```js\nfunction gotojpang(){\n    Router.push(\'/jpangA?name=技胖\')\n}\n\n<div>\n  <button onClick={gotojpang}>技胖</button>\n</div>\n```\n\n​	或者：\n\n```js\n function gotojpang(){\n    Router.push({\n      pathname:\'/jpangA\',\n      query:{\n        name:\'技胖\'\n      }\n    })\n  }\n```\n\n**接受参数**：`withRouter`是Next.js框架的高级组件，用来处理路由用的\n\n```react\n//①引入withRouter\nimport {withRouter} from \'next/router\'\nimport Link from \'next/link\'\n\n//②这里要传入参数router\nconst Jspang = ({router})=>{\n    return (\n        <>\n        	//③通过这种形式获得参数\n            <div>{router.query.name}，他来了</div>\n            <Link href=\"/\"><a>返回首页</a></Link>\n        </>\n    )\n}\n\n//④导出要使用withRouter\nexport default withRouter(Jspang)\n\n```\n\n## 路由-六个钩子事件\n\n>  路由的钩子事件，也就是当路由发生变化时，可以监听到这些变化事件，执行对应的函数。利用钩子事件是可以作很多事情的，比如转换时的加载动画，关掉页面的一些资源计数器.....\n\n* `routerChangeStart`路由发生变化时\n\n  使用Router组件，然后用`on`方法来进行兼听\n\n* `routerChangeComplete`路由结束变化时\n\n* `beforeHistoryChange`浏览器history触发前\n\n  history就是HTMP中的API，`Next.js`路由变化默认都是通过history进行的，所以每次都会调用。 不适用history的话，也可以通过hash。\n\n  正确顺序为：①③②\n\n* `routeChangeError`路由跳转发生错误时\n\n  注意：404找不到路由页面不算错误\n\n**转变成hash路由模式**\n\n以下两种事件都是针对hash的。\n\n* `hashChangeStart`：hash跳转开始时执行\n* `hashChangeComplete`：hash跳转完成时执行\n\n```react\nimport React from \'react\'\nimport Link from \'next/link\'\nimport Router from \'next/router\'\n\nfunction gotojpang(){\n  Router.push(\'/jspang?name=技术胖\')\n}\n\n//使用Router组件，on方法进行兼听\nRouter.events.on(\'routeChangeStart\', (...args) => {\n  console.log(\'1.routeChangeStart->路由开始变化,参数为:\', ...args)\n})\n\nRouter.events.on(\'routeChangeComplete\', (...args) => {\n  console.log(\'2.routeChangeComplete->路由结束变化,参数为:\', ...args)\n})\n\nRouter.events.on(\'beforeHistoryChange\', (...args) => {\n  console.log(\'3,beforeHistoryChange->在改变浏览器 history之前触发,参数为:\', ...args)\n})\n\nRouter.events.on(\'routeChangeError\', (...args) => {\n  console.log(\'4,routeChangeError->跳转发生错误,参数为:\', ...args)\n})\n\nRouter.events.on(\'hashChangeStart\', (...args) => {\n  console.log(\'5,hashChangeStart->hash跳转开始时执行,参数为:\', ...args)\n})\n\nRouter.events.on(\'hashChangeComplete\', (...args) => {\n  console.log(\'6,hashChangeComplete->hash跳转完成时,参数为:\', ...args)\n})\nconst Home = () => (\n  \n  <>\n    <div>我是首页</div>\n    <div>\n      <Link href=\"/jspang?name=技胖\"><a>技胖</a></Link>\n      <Link href=\"/jspang?name=术胖\"><a>术胖</a></Link>\n    </div>\n    <div>\n      <button onClick={gotojpang}>技胖</button>\n    </div>\n\n    //hash模式\n    <div>\n      <Link href=\"#jspang\"><a>技术胖</a></Link>\n    </div>\n  </>\n)\n\nexport default Home\n\n```\n\n## 在getInitialProps中使用Axios获取远端数据\n\n在`Next.js`框架中提供了`getInitialProps`静态方法用来获取远端数据，这个是框架的约定，所以你也只能在这个方法里获取远端数据。不要在生命周期里面获得，虽然可以，但是不符合约定。\n\n*安装axios*: `yarn add axios`\n\n*引入*： `import axios from \'axios\'`\n\n获取数据例子：\n\n```react\n//使用getInitialProps远程获取数据\nJspang.getInitialProps = async ()=>{\n    const promise =new Promise((resolve)=>{\n            axios(\'https://www.easy-mock.com/xxx\').then(\n                (res)=>{\n                    console.log(\'远程数据结果：\',res)\n                    resolve(res.data.data)\n                }\n            )\n    })\n    return await promise\n}\n\n//获取数据之后，把得到的数据传递给页面组件，用{}显示出来就可以了。\n//res.data.data里面有一个list数组\nconst Jspang = ({router,list})=>{\n    return (\n        <>\n            <div>{router.query.name},来了 .<br/>{list}</div>//直接就可以使用\n            <Link href=\"/\"><a>返回首页</a></Link>\n        </>\n    )\n}\n```\n\n## 使用Style JSX编写页面的CSS样式\n\n在`Next.js`中引入一个CSS样式是不可以用的，如果想用，需要作额外的配置。因为框架为我们提供了一个`style jsx`特性，也就是把CSS用JSX的语法写出来。\n\n一个特性：**自动添加随机类名，不会污染全局css**—加入了`Style jsx`代码后，`Next.js`会自动加入一个随机类名，这样就防止了CSS的全局污染。比如我们把代码写成下面这样，然后在浏览器的控制台中进行查看，你会发现自动给我们加入了类名，类似`jsx-xxxxxxxx`\n\n例如：\n\n```react\nfunction Jspang(){\n    return (\n        <>\n            <div>技术胖免费前端教程</div>\n            <div className=\"jspang\">技术胖免费前端教程</div>\n		//使用这种形式些样式\n            <style jsx>\n                {`\n                    div { color:blue;}\n                    .jspang {color:red;}\n                `}\n            </style>\n        </>\n    )\n}\nexport default Jspang\n```\n\n**动态显示样式**：\n\n比如：\n\n```react\nimport React, {useState} from \'react\'\nfunction Jspang(){\n    const [color,setColor] = useState(\'blue\')\n    const changeColor=()=>{\n        setColor(color==\'blue\'?\'red\':\'blue\')\n    }\n    return (\n        <>\n            <div>技术胖免费前端教程</div>\n            <div><button onClick={changeColor}>改变颜色</button></div>\n            <style jsx>\n                {`\n                    div { color:${color};}\n                `}\n            </style>\n        </>\n    )\n}\nexport default Jspang\n```\n\n## Lazy Loading实现模块懒加载\n\n当项目越来越大的时候，模块的加载是需要管理的，如果不管理会出现首次打开过慢，页面长时间没有反应一系列问题。这时候可用`Next.js`提供的`LazyLoading`来解决这类问题。让模块和组件只有在用到的时候在进行加载，一般我把这种东西叫做“懒加载”.它一般分为两种情况，一种是**懒加载**（或者说是**异步加载**）**模块**，另一种是**异步加载组件**。\n\n> 当我们作的应用存在首页打开过慢和某个页面加载过慢时，就可以采用`Lazy Loading`的形式，用懒加载解决这些问题。\n\n**懒加载模块**：\n\n比如我们引入开发中常用的模块`Moment.js`,它是一个JavaScript日期处理类库。安装：`yarn add moment`。\n\n例如（未使用懒加载）：\n\n```react\nimport React, {useState} from \'react\'\nimport moment from \'moment\' //引入模块\n\nfunction Time(){\n\n    const [nowTime,setTime] = useState(Date.now())\n\n    const changeTime=()=>{\n        //使用\n        setTime(moment(Date.now()).format())\n    }\n    return (\n        <>\n            <div>显示时间为:{nowTime}</div>\n            <div><button onClick={changeTime}>改变时间格式</button></div>\n        </>\n    )\n}\nexport default Time\n```\n\n**这个看起来很简单和清晰的案例，缺存在着一个潜在的风险，就是如何有半数以上页面使用了这个`momnet`的库，那它就会以公共库的形式进行打包发布，就算项目第一个页面不使用`moment`也会进行加载，这就是资源浪费，对于我这样有代码洁癖的良好程序员是绝对不允许的。下面我们就通过`Lazy Loading`来进行改造代码。**\n\n改良（使用懒加载）：\n\n```react\nimport React, {useState} from \'react\'\n//删除import moment\nfunction Time(){\n    const [nowTime,setTime] = useState(Date.now())\n    \n    const changeTime= async ()=>{ //把方法变成异步模式\n        const moment = await import(\'moment\') //等待moment加载完成\n        setTime(moment.default(Date.now()).format()) //注意使用defalut\n    }\n    return (\n        <>\n            <div>显示时间为:{nowTime}</div>\n            <div><button onClick={changeTime}>改变时间格式</button></div>\n        </>\n    )\n}\nexport default Time\n```\n\n**懒加载自定义组件**\n\n首先要在懒加载这个组件的文件汇总引入`dynamic`，`import dynamic from \'next/dynamic\'`\n\n使用：\n\n```react\nimport dynamic from \'next/dynamic\' //引入dynamic\n//使用如下方式引入组件\nconst One = dynamic(import(\'../components/one\'))\nfunction Time(){\n    return (\n        <>//使用\n            <One/>\n        </>\n    )\n}\nexport default Time\n```\n\n写完代码后，可以看到自定义组件是懒加载的，只有在`jsx`里用到``时，才会被加载进来，如果不使用就不会被加载。\n\n## 自定义Head更加友好的SEO操作\n\n**定制`<Head>`标签**\n\n* 方法一：**在各个页面加上`<Head>`标签**(推荐)	\n\n  例如在pages中的某一个页面：\n\n  ```react\n  import Head from \'next/head\' //引入Head\n  function Header(){ \n      return (\n          <>\n          //使用Head\n              <Head>\n                  <title>技术胖是最胖的！</title>\n                  <meta charSet=\'utf-8\' />\n              </Head>\n              <div>JSPang.com</div>\n          </> \n      )\n  }\n  export default Header\n  ```\n\n* 方法二：**定义全局的`<Head>`**\n\n  这种方法相当于自定义了一个组件，然后把在组件里定义好，以后每个页面都使用这个组件,其实这种方法用处不大，也不灵活。因为`Next.js`已经把`<Head>`封装好了，本身就是一个组件，我们再次封装的意义不大。\n\n## Next.js框架下使用Ant Design UI\n\n**让Next.js支持CSS文件**：\n\n*安装*`@zeit/next-css`包，它的主要功能就是让`Next.js`可以加载CSS文件，有了这个包才可以进行配置：`yarn add @zeit/next-css`\n\n*配置：*建立一个`next.config.js`（建在最外面的那个目录）这个就是`Next.js`的总配置文件。\n\n```js\nconst withCss = require(\'@zeit/next-css\')\n\nif(typeof require !== \'undefined\'){\n    require.extensions[\'.css\']=file=>{}\n}\n\nmodule.exports = withCss({})\n```\n\n**按需加载Ant Design**\n\n加载`Ant Design`在我们打包的时候会把`Ant Design`的所有包都打包进来，这样就会产生性能问题，让项目加载变的非常慢。这肯定是不行的，现在的目的是只加载项目中用到的模块，这就需要我们用到一个**`babel-plugin-import`**文件。\n\n先安装`Ant Design`库：`yarn add antd`\n\n安装`babel-plugin-import`插件：`yarn add babel-plugin-import`\n\n配置`babel-plugin-import`插件：在项目根目录建立`.babelrc`文件，然后写入如下配置文件。\n\n```js\n{	//Next.js的总配置文件，相当于继承了它本身的所有配置\n    \"presets\":[\"next/babel\"], \n    \"plugins\":[     \n        //增加新的插件，这个插件就是让antd可以按需引入，包括CSS\n        [\n            \"import\",\n            {\n                \"libraryName\":\"antd\",\n                \"style\":\"css\"\n            }\n        ]\n    ]\n}\n```\n\n配置好了以后，`webpack`就不会默认把整个`Ant Design`的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。\n\n使用：\n\n```react\nimport {Button} from \'antc\'\nfunction Page(){\n    return(\n    	<>\n        <Button>我是按需引入的按钮</Button>\n        </>\n    )\n}\n```\n\n\n\n## Next.js生产环境打包\n\n其实Next.js大打包时非常简单的，只要一个命令就可以打包成功。但是当你使用了`Ant Desgin`后，在打包的时候会遇到一些坑。\n\n> 打包 ：next build\n\n> 运行：next start -p 80\n\n先把这两个命令配置到`package.json`文件里，比如配置成下面的样子。\n\n```js\n\"scripts\": {\n  \"dev\": \"next dev\",\n  \"build\": \"next build\",\n  \"start\": \"next start -p 80\"\n},\n```\n\n然后在终端里运行一下`yarn build`，如果这时候报错，其实是我们在加入`Ant Design`的样式时产生的，你可以改用**全局引入CSS**解决问题。\n\n在page目录下，新建一个`_app.js`文件，然后写入下面的代码。\n\n```js\nimport App from \'next/app\'\n\nimport \'antd/dist/antd.css\'\n\nexport default App\n```\n\n这样配置一下，就可以打包成功了，然后再运行`yarn start`来运行服务器，看一下我们的`header`页面，也是有样式的。说明打包已经成功了。', 'next.js', 1592841600, 25);
INSERT INTO `article` VALUES (6, 2, 'React Hooks', '# React Hooks\n\n## React Hooks 简介\n\n`React Hooks`就是用函数形式代替原来的继承类的形式，并且使用预函数的形式管理`state`,有Hooks可以不再使用类的形式定义组件了。原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。现在所有的组件都可以用函数来声明了。 \n\n Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。 \n\n原始写法：\n\n```js\nimport React, { Component } from \'react\';\n\nclass Example extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { count:0 }\n    }\n    render() { \n        return (\n            <div>\n                <p>You clicked {this.state.count} times</p>\n                <button onClick={this.addCount.bind(this)}>Chlick me</button>\n            </div>\n        );\n    }\n    addCount(){\n        this.setState({count:this.state.count+1})\n    }\n}\n\nexport default Example;\n```\n\nReact Hooks 写法：\n\n```js\nimport React, { useState } from \'react\';\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default Example;\n```\n\n## useState\n\n```js\nconst [ count , setCount ] = useState(0);\n```\n\ncount为定义的变量，为它赋予初始值0，setCount为其对应的方法；\n\n```js\n<p>You clicked {count} times</p>\n```\n\n读取它的值，只要使用`{count}`就可以了\n\n```js\n<button onClick={()=>{setCount(count+1)}}>click me</button>\n```\n\n 直接调用setCount函数，这个函数接收的参数是修改过的新状态值 。\n\n 接下来的事情就交给`React`,他会重新渲染组件。**`React`自动帮助我们记忆了组件的上一次状态值 。**\n\n **React Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序**。 \n\n## useEffect\n\n代替`componentDidMount`和`componentDidUpdate`\n\n```js\nimport React, { useState , useEffect } from \'react\';\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    \n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n    })\n    \n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default Example;\n```\n\n注意：\n\n1. React首次渲染和之后的 每次渲染都会调用一遍`useEffect`函数，而之前我们要用两个生命周期函数分别表示首次渲染(`componentDidMonut`)和更新导致的重新渲染(`componentDidUpdate`)。 \n2.  useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时**异步执行**的，而`componentDidMonut`和`componentDidUpdate`中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。 \n\n实现`componentWillUnmount`生命周期函数\n\n 在写React应用的时候，在组件中经常用到`componentWillUnmount`生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。 \n\n```js\nfunction Index() {\n    useEffect(()=>{\n        console.log(\'useEffect=>老弟你来了！Index页面\')\n        return ()=>{\n            console.log(\'老弟，你走了!Index页面\')\n        }\n    },[])\n    return <h2>JSPang.com</h2>;\n}\n```\n\nreturn用与解绑组件。\n\n `useEffect`的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当**状态值**发生变化时，我们才进行解绑。但是当传空数组`[]`时，就是当组件将被销毁时才进行解绑，这也就实现了`componentWillUnmount`的生命周期函数。 \n\n## useContext\n\n `useContext`，它可以帮助我们跨越组件层级直接传递变量，实现共享。 \n\n```js\nimport React, { useState , createContext } from \'react\';\n//===关键代码\nconst CountContext = createContext()\n\nfunction Example4(){\n    const [ count , setCount ] = useState(0);\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <CountContext.Provider value={count}>\n                <Counter />\n            </CountContext.Provider>\n\n        </div>\n    )\n}\n\n//子组件\nfunction Counter(){\n    const count = useContext(CountContext)  //一句话就可以得到count\n    return (<h2>{count}</h2>)\n}\n\nexport default Example4;\n```\n\n使用`const CountContext = createContext()`创建全局上下文；再使用`CountContext.Provider`实现共享，在子组件中使用`useContext()`接收值。\n\n## useReducer\n\n `reducer`其实就是一个函数，这个函数接收两个参数，一个是**状态**，一个用来**控制业务逻辑的判断参数** 。\n\n```js\nimport React, { useReducer } from \'react\';\n\nfunction ReducerDemo(){\n    const [ count , dispatch ] =useReducer((state,action)=>{\n        switch(action){\n            case \'add\':\n                return state+1\n            case \'sub\':\n                return state-1\n            default:\n                return state\n        }\n    },0)\n    return (\n       <div>\n           <h2>现在的分数是{count}</h2>\n           <button onClick={()=>dispatch(\'add\')}>Increment</button>\n           <button onClick={()=>dispatch(\'sub\')}>Decrement</button>\n       </div>\n    )\n}\nexport default ReducerDemo\n```\n\n## useMemo\n\n `useMemo`主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了`shouldCompnentUpdate`（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分`mount`和`update`两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。`useMemo`和`useCallback`都是解决上述性能问题的 。\n\n```js\nimport React , {useState,useMemo} from \'react\';\n\n//父组件\nfunction Example3(){\n    const [count1 , setCount1] = useState(0)\n    const [count2 , setCount2] = useState(100)\n    return (\n        <>\n            <button onClick={()=>{setCount1(count1+1)}}>count1加1</button>\n            <button onClick={()=>{setCount2(count2-1)}}>count2减1</button>\n            <ChildComponent name={count2}>{count1}</ChildComponent>\n        </>\n    )\n}\n\n//子组件\nfunction ChildComponent({name,children}){\n    function changeCount2(name){\n        console.log(\'count2减1了！！\')\n        return name\n    }\n    \n    const actionCount2 = useMemo(() => changeCount2(name), [name])\n    // const actionCount2 = changeCount2(name)\n    return (\n        <>\n            <div>count1:{children}</div>\n            <div>count2:{actionCount2}</div>\n        </>\n    )\n}\n```\n\n## 自定义Hooks函数\n\n 其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些`React Hooks`的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。 \n\n```js\nfunction useWinSize(){\n    const [ size , setSize] = useState({\n        width:document.documentElement.clientWidth,\n        height:document.documentElement.clientHeight\n    })\n\n    const onResize = useCallback(()=>{\n        setSize({\n            width: document.documentElement.clientWidth,\n            height: document.documentElement.clientHeight\n        })\n    },[]) \n    useEffect(()=>{\n        window.addEventListener(\'resize\',onResize)\n        return ()=>{\n            window.removeEventListener(\'resize\',onResize)\n        }\n    },[])\n\n    return size;\n}\n\nfunction Example9(){\n\n    const size = useWinSize()\n    return (\n        <div>页面Size:{size.width}x{size.height}</div>\n    )\n}\n\nexport default Example9 \n```', 'React Hooks', 1592841600, 47);
INSERT INTO `article` VALUES (7, 2, '利用react-router4的react-router-config做路由鉴权', '\n\n# 利用react-router4的react-router-config做路由鉴权\n\n文章来源：https://segmentfault.com/a/1190000015282620\n\n一、react-router-config 是一个帮助我们配置静态路由的小助手。\n其源码就是一个高阶函数 利用一个map函数生成静态路由\n\n```javascript\nimport React from \"react\";\nimport Switch from \"react-router/Switch\";\nimport Route from \"react-router/Route\";\nconst renderRoutes = (routes, extraProps = {}, switchProps = {}) =>\nroutes ? (\n    <Switch {...switchProps}>\n        {routes.map((route, i) => ( \n        <Route\n          key={route.key || i}\n          path={route.path}\n          exact={route.exact}\n          strict={route.strict}\n          render={props => (\n            <route.component {...props} {...extraProps} route={route} />\n          )}\n        />\n      ))}\n    </Switch>\n  ) : null;\n export default renderRoutes;\n```\n\n//router.js 假设这是我们设置的路由数组（这种写法和vue很相似是不是?)\n\n```javascript\nconst routes = [\n    { path: \'/\',\n        exact: true,\n        component: Home,\n    },\n    {\n        path: \'/login\',\n        component: Login,\n    },\n    {\n        path: \'/user\',\n        component: User,\n    },\n    {\n        path: \'*\',\n        component: NotFound\n    }\n]\n```\n\n//app.js 那么我们在app.js里这么使用就能帮我生成静态的路由了\n\n```javascript\nimport { renderRoutes } from \'react-router-config\'\nimport routes from \'./router.js\'\nconst App = () => (\n   <main>\n      <Switch>\n         {renderRoutes(routes)}\n      </Switch>\n   </main>\n)\n\nexport default App\n```\n\n扯了半天，要如何利用这个插件帮我们路由鉴权呢？\n用过vue的小朋友都知道，vue的router.js 里面添加 `meta: { requiresAuth: true }`\n然后利用`导航守卫`\n\n```javascript\nrouter.beforeEach((to, from, next) => {\n  // 在每次路由进入之前判断requiresAuth的值，如果是true的话呢就先判断是否已登陆\n})\n```\n\n二、**基于类似vue的路由鉴权想法，我们稍稍改造一下react-router-config**\n// utils/renderRoutes.js\n\n```javascript\nimport React from \'react\'\nimport { Route, Redirect, Switch } from \'react-router-dom\'\nconst renderRoutes = (routes, authed, authPath = \'/login\', extraProps = {}, switchProps = {}) => routes ? (\n  <Switch {...switchProps}>\n    {routes.map((route, i) => (\n      <Route\n        key={route.key || i}\n        path={route.path}\n        exact={route.exact}\n        strict={route.strict}\n        render={(props) => {\n          if (!route.requiresAuth || authed || route.path === authPath) {\n            return <route.component {...props} {...extraProps} route={route} />\n          }\n          return <Redirect to={{ pathname: authPath, state: { from: props.location } }} />\n        }}\n      />\n    ))}\n  </Switch>\n) : null\n\nexport default renderRoutes\n```\n\n修改后的源码增加了两个参数 authed 、 authPath 和一个属性 route.requiresAuth\n然后再来看一下最关键的一段代码\n\n```javascript\nif (!route.requiresAuth || authed || route.path === authPath) {\n    return <route.component {...props} {...extraProps} route={route} />\n    }\n    return <Redirect to={{ pathname: authPath, state: { from: props.location } }} />\n```\n\n很简单 如果 route.requiresAuth = false 或者 authed = true 或者 route.path === authPath（参数默认值\'/login\'）则渲染我们页面，否则就渲染我们设置的**authPath**页面，并记录从哪个页面跳转。\n\n相应的router.js也要稍微修改一下\n\n```javascript\nconst routes = [\n    { path: \'/\',\n        exact: true,\n        component: Home,\n        requiresAuth: false,\n    },\n    {\n        path: \'/login\',\n        component: Login,\n        requiresAuth: false,\n\n    },\n    {\n        path: \'/user\',\n        component: User,\n        requiresAuth: true, //需要登陆后才能跳转的页面\n\n    },\n    {\n        path: \'*\',\n        component: NotFound,\n        requiresAuth: false,\n    }\n]\n```\n\n//app.js\n\n```javascript\nimport React from \'react\'\nimport { Switch } from \'react-router-dom\'\n//import { renderRoutes } from \'react-router-config\'\nimport renderRoutes from \'./utils/renderRoutes\'\nimport routes from \'./router.js\'\n\nconst authed = false // 如果登陆之后可以利用redux修改该值(关于redux不在我们这篇文章的讨论范围之内）\nconst authPath = \'/login\' // 默认未登录的时候返回的页面，可以自行设置\n\nconst App = () => (\n   <main>\n      <Switch>\n         {renderRoutes(routes, authed, authPath)}\n      </Switch>\n   </main>\n)\nexport default App\n//登陆之后返回原先要去的页面login函数\nlogin(){\n    const { from } = this.props.location.state || { from: { pathname: \'/\' } }\n     // authed = true // 这部分逻辑自己写吧。。。\n    this.props.history.push(from.pathname)\n}\n```\n\n以上～修改了部分源码并完成了我们想要的效果。', '利用react-router4的react-router-config做路由鉴权', 1592841600, 23);
INSERT INTO `article` VALUES (8, 3, 'Niginx 基础', '\n# Nginx\n\n> Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。\n\n## 初识Nginx和环境准备\n\n**Nginx的优点**\n\n- 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。\n- 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。\n- 免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。\n- 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。\n\n* 反向代理功能，负载均衡功能等\n\n可以通过`https://w3techs.com/`这个网站看到nginx的热度。\n\n阿里云校园生态：`https://promotion.aliyun.com/ntms/act/campus2018.html`\n\n**用yum进行安装必要程序**\n\n```bash\nyum -y install gcc gcc-c++ autoconf pcre-devel make automake\nyum -y install wget httpd-tools vim\n```\n\n## Nginx的快速搭建\n\n**Nginx版本说明**\n\n- Mainline version ：开发版,主要是给广大Nginx爱好者，测试、研究和学习的，但是不建议使用于生产环境。\n- Stable version : 稳定版,也就是我们说的长期更新版本。这种版本一般比较成熟，经过长时间的更新测试，所以这种版本也是主流版本。\n- legacy version : 历史版本，如果你需要以前的版本，Nginx也是有提供的。\n\n**基于Yum的方式安装Nginx**\n\n* 检查yum是否存在：`yum list | grep nginx`\n\n* 若原来源版本过低，可以自行配置yum源：\n\n  ```bash\n  vim /etc/yum.repos.d/nginx.repo  #先进入到指定文件\n  #再添加如下代码\n  [nginx]\n  name=nginx repo\n  baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/     #这里OS换成centos,OSRELEASE换成7；视情况而定\n  gpgcheck=0\n  enabled=1\n  ```\n\n* 配置好yum源后，安装nginx：`yum install nginx`\n\n* 安装好后，检测Nginx版本：`nginx -v`\n\n## Nginx基本配置文件详解\n\n**查看Nginx的安装目录**\n\n`rpm -ql nginx`这条命令可以找到nginx的所有安装位置。\n\n**nginx.conf 文件解读**\n\n> nginx.conf 文件是Nginx*总配置文件*，在我们搭建服务器时经常调整的文件。\n\n进入etc/nginx目录，用vim打开nginx.conf\n\n```bash\n#运行用户，默认即是nginx，可以不进行设置\nuser  nginx;\n#Nginx进程，一般设置为和CPU核数一样\nworker_processes  1;   \n#错误日志存放目录\nerror_log  /var/log/nginx/error.log warn;\n#进程pid存放位置\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024; # 单个后台进程的最大并发数\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;   #文件扩展名与类型映射表\n    default_type  application/octet-stream;  #默认文件类型\n    #设置日志模式\n    log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n                      \'$status $body_bytes_sent \"$http_referer\" \'\n                      \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\n\n    access_log  /var/log/nginx/access.log  main;   #nginx访问日志存放位置\n\n    sendfile        on;   #开启高效传输模式\n    #tcp_nopush     on;    #减少网络报文段的数量\n\n    keepalive_timeout  65;  #保持连接的时间，也叫超时时间\n\n    #gzip  on;  #开启gzip压缩\n\n    include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件\n```\n\n**default.conf 配置项讲解** \n\n我们看到最后有一个子文件的配置项，那我们打开这个include子文件配置项看一下里边都有些什么内容。\n\n进入conf.d目录，然后使用`vim default.conf`进行查看。\n\n```bash\nserver {\n    listen       80;   #配置监听端口\n    server_name  localhost;  //配置域名\n\n    #charset koi8-r;     \n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;     #服务默认启动目录\n        index  index.html index.htm;    #默认访问文件\n    }\n\n    #error_page  404              /404.html;   # 配置404页面\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;   #错误状态码的显示页面，配置后需要重启\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache\'s document root\n    # concurs with nginx\'s one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n明白了这些配置项，我们知道我们的服务目录放在了`/usr/share/nginx/html`下，可以使用命令进入看一下目录下的文件。\n\n```bash\ncd /usr/share/nginx/html\nls \n```\n\n可以看到目录下面有两个文件，50x.html 和 index.html。我们可以使用vim进行编辑。\n\n**阿里云的安全组配置**\n\n如果你使用的是阿里云，记得到ECS实例一下打开端口。\n\n步骤如下：\n\n1. 进入阿里云控制台，并找到ECS实例。\n2. 点击实例后边的“更多”\n3. 点击“网络和安全组” ，再点击“安全组配置”\n4. 右上角添加“安全组配置”\n5. 进行80端口的设置。\n\n## Nginx服务启动、停止、重启\n\n**启动Nginx服务**\n\n* 直接启动：`nginx`\n* 使用systemctl命令启动：`systemctl start nginx.service`\n* 检查是否启动：`ps aux | grep nginx`\n\n**停止Nginx服务**\n\n* 立即停止：`nginx -s stop`，这种方法比较强硬，无论进程是否在工作，都直接停止进程。\n* 从容停止服务：`nginx -s quit`，这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。\n* killall 方法杀死进程：`killall nginx`，也是比较野蛮的方法，当上面方法没起作用的时候，可以用这种。\n* systemctl停止：`systemctl stop nginx.service`\n\n**重启Nginx服务**\n\n* 重启服务：`systemctl restart nginx.service`\n* 重新载入配置文件：`nginx -s reload`，在重新编写或者修改Nginx的配置文件后，都需要作一下重新载入。\n\n**查看端口号**\n\n在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用`netstat -tlnp`命令查看端口号的占用情况。\n\n## 自定义错误页\n\n> 真正好的网站会武装到牙齿，即便是不同种类的错误页面的显示\n\n**多错误指向一个页面**\n\n在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。\n\n```bash\nerror_page   500 502 503 504  /50x.html;\n```\n\nerror_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误代码，/50.html 用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。\n\n**单独为错误指定处理方式**\n\n有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下：\n\n```bash\nerror_page 404  /404.html;\n```\n\n然后到网站目录下新建一个404.html 文件，并写入一些信息。\n\n```html\n<html>\n<meta charset=\"UTF-8\">\n<body>\n<h1>404页面没有找到!</h1>\n</body>\n</html>\n```\n\n然后重启我们的服务，再进行访问，你会发现404页面发生了变化。\n\n**把错误码换成一个地址**\n\n处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。\n\n```bash\nerror_page  404 http://jspang.com;\n```\n\n我们使用了技术胖的博客地址作为404页面没有找到的提示，就形成了，没有找到文件，就直接跳到了技术胖的博客上了。\n\n## Nginx访问权限\n\n**简单实现访问控制**\n\n有时候我们的服务器*只允许特定主机访问*，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在`location`里进行配置。\n\n可以直接在default.conf里进行配置。\n\n```bash\n location / {\n        deny   123.9.51.42; #禁止这个ip地址访问\n        allow  45.76.202.231; #允许这个ip地址访问\n    }\n```\n\n配置完成后，重启一下服务器就可以实现限制和允许访问了。\n\n**指定优先级**\n\n我们先来看一下代码：\n\n```bash\n location / {\n        allow  45.76.202.231;\n        deny   all;\n    }\n```\n\n上面的配置表示只允许`45.76.202.231`进行访问，其他的IP是禁止访问的。但是如果我们把`deny all`指令，移动到 `allow 45.76.202.231`之前，会发生什么那？会发现所有的IP都不允许访问了。**这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）**。\n\n**复杂访问控制权限匹配**\n\n在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。\n\n上面的需求，配置代码如下：\n\n```basic\n    location =/img{\n        allow all;\n    }\n    location =/admin{\n        deny all;\n    }\n```\n\n`=`号代表精确匹配，使用了`=`后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全，一定要学会。\n\n**使用正则表达式设置访问权限**\n\n只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。\n\n代码如下：\n\n```basic\n location ~\\.php$ {\n        deny all;\n    }\n```\n\n这样我们再访问的时候就不能访问以php结尾的文件了。这样让网站变的安全很多了。\n\n## Nginx设置虚拟主机\n\n> 虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟主机就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上，而不必再为建立一个网站单独购买一台服务器，既解决了维护服务器技术的难题，同时又极大地节省了服务器硬件成本和相关的维护费用。\n\n我们可以用一台服务器，建立多个网站，为其划分不同端口即可。\n\n配置虚拟主机可以基于**端口号**、**基于IP**和**基于域名**。\n\n**基于端口号配置虚拟主机**\n\n> 原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。\n\n我们可以直接配置在主文件里`etc/nginx/nginx.conf`文件里， 也可以配置在子配置文件里`etc/nginx/conf.d/default.conf`。我这里为了配置方便，就配置在子文件里了。当然你也可以再新建一个文件，只要在conf.d文件夹下就可以了。\n\n修改配置文件中的server选项，这时候就会有两个server。\n\n```basic\nserver{\n        listen 8001;\n        server_name localhost;\n        root /usr/share/nginx/html/html8001;\n        index index.html;\n}\n```\n\n编在`usr/share/nginx/html/html8001/`目录下的index.html文件并查看结果。\n\n```html\n<h1>welcome port 8001</h1>\n```\n\n最后在浏览器中分别访问地址和带端口的地址。看到的结果是不同的。\n\n然后我们就可以在浏览器中访问`http://112.74.164.244:8001`了。\n\n**基于IP的虚拟主机**\n\n基于IP和基于端口的配置几乎一样，只是把`server_name`选项，配置成IP就可以了。\n\n比如上面的配置，我们可以修改为：\n\n```basic\nserver{\n        listen 80;\n        server_name 112.74.164.244;\n        root /usr/share/nginx/html/html8001;\n        index index.html;\n}\n```\n\n**基于域名配置虚拟主机**\n\n在真实的上线环境中，一个网站是需要域名和公网IP才可以访问的。\n\n先要对**域名进行解析**，这样域名才能正确定位到你需要的IP上。 我这里新建了两个解析，分别是:\n\n- nginx.jspang.com :这个域名映射到默认的Nginx首页位置。\n- nginx2.jspang.com : 这个域名映射到原来的8001端口的位置。\n\n我们修改`etc/nginx/conf.d`目录下的**default.conf** 文件，把原来的80端口虚拟主机改为以域名划分的虚拟主机。代码如下：\n\n```basic\nserver {\n    listen       80;\n    server_name  nginx.jspang.com;\n```\n\n我们再把同目录下的`8001.conf`文件进行修改，改成如下：\n\n```basic\nserver{\n        listen 80;\n        server_name nginx2.jspang.com;\n        location / {\n                root /usr/share/nginx/html/html8001;\n                index index.html index.htm;\n        }\n}\n```\n\n然后我们用平滑重启的方式，进行重启，这时候我们在浏览器中访问这两个网页。\n\n其实域名设置虚拟主机也非常简单，主要操作的是配置文件的server_name项，还需要域名解析的配合。\n\n## Nginx反向代理设置\n\n> 现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。\n\n**正向代理：**如果你觉的反向代理不好理解，那先来了解一下正向代理。比如翻墙工具（我这里说的不是物理梯子），它就是一个典型的正向代理工具。它会把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做proxy服务器，再转发给客户。\n\n![img](https://ask.qcloudimg.com/http-save/yehe-1010792/vr3pz3ovzh.png?imageView2/2/w/1620)简单来说就是你想访问目标服务器的权限，但是没有权限。这时候代理服务器有权限访问服务器，并且你有访问代理服务器的权限，这时候你就可以通过访问代理服务器，代理服务器访问真实服务器，把内容给你呈现出来。\n\n**反向代理**：反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。![img](https://ask.qcloudimg.com/http-save/yehe-1010792/md21eo1izs.png?imageView2/2/w/1620)\n\n通过图片的对比，应该看出一些区别，这里proxy服务器代理的并不是客户端，而是服务器,即向外部客户端提供了一个统一的代理入口，客户端的请求都要先经过这个proxy服务器。具体访问那个服务器server是由Nginx来控制的。再简单点来讲，一般代理指代理的客户端，反向代理是代理的服务器。\n\n**反向代理的好处和用途**\n\n- 安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。\n- 功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。\n\n**最简单的反向代理**\n\n现在我们要访问`http://nginx2.jspang.com`然后反向代理到`jspang.com`这个网站。我们直接到`etc/nginx/con.d/8001.conf`进行修改。\n\n修改后的配置文件如下：\n\n```basic\nserver{\n        listen 80;\n        server_name nginx2.jspang.com;\n        location / {\n        #使用proxy_pass指令\n               proxy_pass http://jspang.com;\n        }\n}\n```\n\n一般我们反向代理的都是一个IP，但是我这里代理了一个域名也是可以的。其实这时候我们反向代理就算成功了，我们可以在浏览器中打开`http://nginx2.jspang.com`来测试一下。\n\n**其它反向代理指令**\n\n- proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。\n- proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。\n- proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。\n- proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。\n- proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。\n\n## Nginx适配PC或移动端\n\n现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。\n\n这样的需求有人说拿自适应就可以搞定，比如我们常说的bootstrap和24格布局法，这些确实是非常好的方案，但是无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东......这些大型网站就都没有采用自适应，而是用**分开制作的方式**。\n\n那分开制作如何通过配置Nginx来识别出应该展示哪个页面呢？\n\n**$http_user_agent的使用：**\n\nNginx通过内置变量`$http_user_agent`，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。\n\n操作步骤如下：\n\n1. 在/usr/share/nginx/目录下新建两个文件夹，分别为：pc和mobile目录\n\n   ```basic\n   cd /usr/share/nginx\n   mkdir pc\n   mkdir mobile\n   ```\n\n2. 在pc和moblic目录下，新建两个index.html文件，文件里下面内容\n\n   ```html\n   <h1>I am pc!</h1>\n   ```\n\n   ```html\n   <h1>I am mobile!</h1>\n   ```\n\n3. 进入`etc/nginx/conf.d`目录下，修改8001.conf文件，改为下面的形式:\n\n   ```bash\n   server{\n        listen 80;\n        server_name nginx2.jspang.com;\n        location / {\n         root /usr/share/nginx/pc;\n         if ($http_user_agent ~* \'(Android|webOS|iPhone|iPod|BlackBerry)\') {\n            root /usr/share/nginx/mobile;\n         }\n         index index.html;\n        }\n   }\n   ```\n\n## Nginx的Gzip压缩配置\n\n> Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。\n\ngzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。\n\n**gzip的配置项**\n\nNginx提供了专门的gzip模块，并且模块中的指令非常丰富。\n\n- gzip : 该指令用于开启或 关闭gzip模块。\n- gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。\n- gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。\n- gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。\n- gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。\n- gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0.\n- gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。\n- gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。\n\n**gzip最简单的配置**\n\n```basic\nhttp {\n   .....\n    gzip on;\n    gzip_types text/plain application/javascript text/css;\n   .....\n}\n```\n\n`gzip on`是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。\n\n配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。\n\n如果你是windows操作系统，你可以按F12键打开开发者工具，单机当前的请求，在标签中选择Headers，查看HTTP响应头信息。你可以清楚的看见`Content-Encoding`为gzip类型。\n\n[网页GZIP压缩检测](https://tool.chinaz.com/gzips/)', 'Nginx基础', 1592928000, 24);
INSERT INTO `article` VALUES (9, 1, '现代操作系统', '# 现代操作系统\n\n1、导论\n====\n\n与用户交互的程序：\n\n*   基于文本的shell\n*   基于图标的图形化用户界面（GUI）\n\n操作系统所处的位置：\n\n![操作系统所处的位置](https://img-blog.csdn.net/20160228203257583)\n\n多数计算机有两种运行模式：\n\n*   内核态（管态），操作系统运行在此模式，能够执行任何指令。\n*   用户态，用户软件运行在此模式，使用机器指令中的子集。\n\n操作系统的功能：\n\n*   为用户程序提供抽象\n*   管理计算机资源\n\n抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分：\n\n*   有关抽象的定义和实现\n*   随时用这些抽象解决问题\n\n### 操作系统发展历史\n\n1.  1945~1955：真空管和穿孔卡片\n2.  1955~1965：晶体管和批处理系统\n3.  1965~1980：集成电路芯片和多道程序设计\n4.  1980~至今：个人计算机\n\n### 计算机硬件\n\n*   CPU\n*   存储器\n*   磁盘\n*   磁带\n*   I/O设备\n*   总线\n\n大型Pentium系统结构：\n\n![大型Pentium系统结构](https://img-blog.csdn.net/20160228203402468)\n\nPentium系统的启动过程：\n\n*   主板上有一个基本输入输出系统（BIOS），其中有底层I/O软件。\n*   计算机启动时，BIOS开始运行。\n*   首先检查安装RAM数量，键盘和其他基本设备是否已安装并正常相应。\n*   开始扫描ISA和PCI总线并找出连接在上面的所有设备，记录下来。\n*   如果现有设备和系统上一次启动时的设备不同，则配置新的设备。\n*   BISO通过存储在CMOS存储器中的设备清单决定启动设备。\n*   启动设备上的第一个扇区被读入内存并执行。\n*   启动扇面末尾的分区表检查的程序，确定哪个分区是活动的。\n*   从活动分区读入第二个启动装载模块，装在模块被读入操作系统。\n*   操作系统询问BIOS，以获得配置信息。\n*   系统检查每种设备驱动程序是否存在，有就将设备驱动程序调入内核。\n*   系统创建背景进程，在终端上启动登录程序或GUI。\n\n### 操作系统概念\n\n进程：\n\n进程本质是正在执行的一个程序。与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为进程表（数组或链表结构）。\n\n地址空间：\n\n现代操作系统通常使用虚拟内存技术。操作系统可以把部分地址空间装入主存，部分留在磁盘上，在需要时再交换它们。\n\n文件：\n\n大多数系统都有目录结构，目录项可以是文件或者目录，构成了一种层次结构（文件系统）。进程和文件层次都可以组织成树状结构，一般进程的树状结构层次不深，而且是暂时的；文件树的层次常常多达四层、五层或者更多层，存在时间可能达数年。\n\n输入/输出：\n\n所有计算机都有用来获取输入和产生输出的物理设备。包括键盘、显示器、打印机等。\n\n保护：\n\n例如UNIX系统中对文件实现保护，三个3位保护字段（rwxrwxrwx），分别表示所有者、所有者同组用户、其他用户的读、写、执行权限。\n\nshell：\n\nUNIX的命令解释器称为shell，不是操作系统的一部分。shell是终端用户与操作系统之间的界面，除非用户使用的是GUI界面。\n\n### 系统调用\n\n系统调用`read(fd, &buffer, nbytes)`函数的过程：\n\n1.  参数nbytes压栈\n2.  参数&buffer压栈\n3.  参数fd压栈\n4.  对库过程read进行实际调用\n5.  把系统调用的编号放在寄存器中\n6.  执行TRAP指令，切换到内核态，在内核中一个固定地址开始执行\n7.  内核代码检查系统调用编号，发出系统调用处理指令\n8.  系统调用句柄执行\n9.  控制返回给用户空间库过程\n10.  以通常的过程调用返回的方式，返回到用户程序\n11.  用户程序清除堆栈空间\n\n![完成系统调用read的11个步骤](https://img-blog.csdn.net/20160228203514522)\n\n### 操作系统结构\n\n*   单体系统\n*   层次式系统\n*   微内核\n*   客户机-服务器模式\n*   虚拟机\n*   外核\n\n### C语言\n\n编译C和头文件，构件可执行程序的过程：\n\n![C程序编译过程](https://img-blog.csdn.net/20160228203539194)\n\n* * *\n\n2、进程与线程\n=======\n\n### 进程\n\n#### 进程模型\n\n操作系统中最核心的概念是进程：这是对正在运行程序的一个抽象。  \n一个进程就是一个正在执行程序的实例、包括程序计数器、寄存器和变量的当前值。\n\n在多道程序设计中，一个CPU能在多个进程之间来回快速切换，达到（伪）并行效果。\n\n一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。  \n单个处理器可以被若干进程共享，它使用某种调度算法巨顶何时停止一个进程的工作，并转而为另一个进程提供服务。\n\n#### 创建进程\n\n4种主要事件导致进程的创建：\n\n1.  系统初始化\n2.  执行了正在运行的进程所调用的进程创建系统调用\n3.  用户请求创建一个新进程\n4.  一个批处理作业的初始化\n\n在UNIX系统中，只有一个系统调用可以用来创建新进程：`fork`。 \n这个系统调用会创建一个与调用进程相同的副本。 \n在调用`fork`后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样打开的文件。 \n通常子进程接着执行`execve`系统调用，以修改其存储映像并运行一个新的程序。\n\n在Windows系统中，一个Win32函数调用`CreateProcess`即处理进程的创建，也负责把正确的程序装入新的进程。\n\n在UNIX中，子进程的初始地址空间是父进程的一个副本，不可写的内存区是共享的，新进程有可能共享其创建者的其他资源。 \n在Windows中，从一开始父进程的地址空间和子进程的地址空间解释不同的。\n\n#### 进程的终止\n\n进程的终止通常由以下条件引起：\n\n1.  正常退出（自愿的）\n2.  出错退出（自愿的）\n3.  严重错误（非自愿）\n4.  被其他进程杀死（非自愿）\n\n#### 进程的层次结构\n\n在UNIX系统中，进程只有一个父进程，但可以有多个子进程。 \n进程和它的所有子女以及后裔共同组成一个进程组。\n\nWindows系统中没有进程层次的概念，所有的进程都是地位相同的。\n\n#### 进程的状态\n\n进程的三种状态：\n\n1.  运行态（该时刻进程实际占用CPU）\n2.  就绪态（可运行，但应为其他进程正在运行而暂时停止）\n3.  阻塞态（除非某种外部事件发生，否则进程不能运行）\n\n![进程状态转换图](https://img-blog.csdn.net/20160228220335382)\n\n1.  进程为等待输入而阻塞\n2.  调度程序选择另一个进程\n3.  调度程序选择这个程序\n4.  出现有效输入\n\n#### 进程的实现\n\n操作系统维护着一张表（一个结构数组），即进程表（process table）。 \n每个进程占用一个进程表项（又称进程控制块）。\n\n终端发生后操作系统最底层的工作步骤：\n\n1.  硬件压入堆栈程序计数器等。\n2.  硬件从中断向量装入新的程序计数器。\n3.  汇编语言过程保存寄存器值。\n4.  汇编语言过程设置新的堆栈。\n5.  C终端服务例程运行（典型地读和缓冲输入）。\n6.  调度程序决定下一个将运行的进程。\n7.  C过程返回至汇编代码。\n8.  汇编语言过程开始运行新的当前进程。\n\n### 2\\. 线程\n\n#### 线程的使用\n\n线程是一种轻量级的进程。\n\n*   多个线程拥有共享同一个地址空间和所有可用数据的能力。\n*   线程比进程更容易创建和销毁。\n*   在大量计算和大量I/O处理过程中，多个线程能够加快程序执行速度。\n\n#### 经典的线程模型\n\n进程模型基于两种对立的概念：资源分组处理与执行。  \n理解进程的一个角度是，用某种方法把相关的资源集中在一起。  \n另一个概念是，进程拥有一个执行的线程。  \n线程拥有自己的程序计数器、寄存器、堆栈。  \n进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。\n\n线程可以处于若干状态中的任何一个：运行、阻塞、就绪或终止。\n\n#### POSIX线程\n\n为实现可移植的线程程序，IEEE指定了线程的标准。  \n它定义的线程包叫做Pthread，大部分UNIX系统都支持该标准。\n\n所有Pthread线程都有某些特性。 \n每一个都含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。 \n这些属性包括堆栈大小、调度参数以及使用线程需要的其他项目。\n\n| 线程调用               | 描述                           |\n| ---------------------- | ------------------------------ |\n| `pthread_create`       | 创建一个新线程                 |\n| `pthread_exit`         | 结束调用的线程                 |\n| `pthread_join`         | 等待一个特定的线程退出         |\n| `pthread_yield`        | 释放CPU来运行另外一个线程      |\n| `pthread_attr_init`    | 创建并初始化一个线程的属性结构 |\n| `pthread_attr_destory` | 删除一个线程的属性结构         |\n\n#### 线程包的实现方式\n\n**在用户空间中实现**\n\n把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是单线程进程。  \n线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。  \n每个进程有其专用线程表（thread table）。\n\n> 优点：用户线程包可以在不支持线程的操作系统上实现。  \n> 不需要陷进，不需要上下文切换，不需要对内存高速缓存进行刷新，使得线程调度非常快。  \n> 允许每个进程有自己定制的调度算法。\n>\n> 问题：如何实现阻塞系统调用，使用阻塞调用会阻塞其他的线程。  \n> 页面故障问题，如果某个调用跳转到了一条不再内存的指令上，就会发生页面故障，内核由于不知道线程的存在，通常会把整个进程阻塞到I/O完成。  \n> 如果一个线程开始运行，那么该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。\n\n**在内核中实现线程**\n\n此时不需要运行时系统，内核中有用来记录系统中所有线程的线程表。  \n当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。\n\n> 优点：内核很容在线程阻塞时切换到另一个线程执行。  \n> 内核线程不需要任何新的、非阻塞系统调用。\n>\n> 问题：在内核中创建或销毁线程的代价比较大。  \n> 进程创建问题，一个多线程进程创建新线程出现的问题。  \n> 当信号到达时，应该有哪一个线程处理。\n\n**混合实现**\n\n使用内核线程，然后将用户级线程与某些或者全部内核线程多路复用起来。 \n内核只识别内核线程，并对其进行调度。一些内核线程会被多个用户级线程多路复用。\n\n> 这一模型能够带来最大的灵活度。\n\n#### 调度程序激活机制\n\n当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，并且在堆栈中以参数的形式传递有问题的线程的编号和所发生事件的一个描述。 \n内核通过在一个已知的起始地址启动运行时系统，从而发出通知，这是对UNIX中信号的一种粗略模拟。 \n这个机制称为上行调用（upcall）。\n\n调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层系统内在结构的概念。\n\n### 进程间通信\n\n进程间通信（Inter Process Communication，IPC）简要的说有三个问题：\n\n1.  一个进程如何把信息传递给另一个。\n2.  确保两个或更多的进程在关键活动中不会出现交叉。\n3.  保证进程以正确的顺序执行。\n\n#### 竞争条件\n\n在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区。 \n两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件（race condition）。\n\n#### 临界区\n\n阻止多个进程同时读写共享的数据可以通过互斥（mutual exclusion）。 \n确保党一个进程在使用一个共享数据时，其他进程不能做同样的操作。 \n我们把对共享内存进行访问的程序片段称作临界区（critical section）。\n\n一个好的解决方案，需要满足一下4个条件：\n\n1.  任何两个进程不能同时处于临界区。\n2.  不应对CPU的速度和数量做任何假设。\n3.  临界区外运行的程序不得阻塞其他进程。\n4.  不得使进程无限期等待进入临界区。\n\n#### 忙等待的互斥\n\n**屏蔽中断**\n\n每个进程在刚刚进入临界区后立即屏蔽所用中断，并在就要离开之前再打开中断。\n\n适用于单核操作系统，对操作系统本身而言很有用，单对于用户进程则不是一种合适的互斥机制。\n\n**锁变量**\n\n共享锁变量，初始为0。当进程想进入临界区时，首先测试这把锁。 \n如果锁为0，则进程将所设置为1并进入临界区。  \n如果锁为1，则进程将等待其值变为0。\n\n这种方式同样存在竞争条件。\n\n**严格轮换法**\n\n连续测试一个变量直到某个值出现为止，称为忙等待。  \n这种方式浪费CPU时间，通常应该避免。  \n只有在有理由认为等待时间是非常短的情形下，才使用忙等待。  \n用于忙等待的锁，称为自旋锁（spin lock）。\n\n**Peterson解法**\n\n```c\n#define FALSE   0\n#define TRUE    1\n#define N       2                       /* 进程数量 */\n\nint turn;                               /* 现在轮到谁? */\nint interested[N];                      /* 所有值初始化为0(FALSE) */\n\nvoid enter_region(int process)          /* 进程是0或1 */\n{\n    int other;                          /* 其他进程号 */\n\n    other = 1 - process;                /* 另一方进程 */\n    interested[process] = TRUE;         /* 表明所感兴趣的 */\n    turn = process;                     /* 设置标志 */\n    while (turn == process && interested[other] == TRUE);   /* 空语句 */\n}\n\nvoid leave_region(int process)          /* 进程：谁离开? */\n{\n    interested[process] = FALSE;        /* 表示离开临界区 */\n}\n```\n\n**TSL指令**\n\n需要硬件支持的一种方案。 \n某些计算机中，特别是那些设计为多处理器的计算机。 \n都有指令`TSL RX, LOCK`。 \n称为测试并加锁（Test and Set Lock），他将一个内存字lock读到寄存器RX中，然后再该内存地址上存一个非零值。 \n读字和写字操作保证是不可分割的。\n\n一个可替代TSL的指令时XCHG，它原子性的交换两个位置的内容。\n\n#### 睡眠与唤醒\n\nPeterson解法和TSL或XCHG解法都有忙等待的缺点。 \n这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。\n\n生产者-消费者问题。两个进程共享一个公共的固定大小的缓冲区。 \n其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。\n\n#### 信号量\n\n信号量（semaphore）是Dijkstra在1965年提出的一种方法，使用一个整型变量来累计唤醒次数。\n\n两种操作：down和up。 \n对一信号量执行down操作，则是检查其值是否大于0。 \n若大于0，则将其值减1并继续；若为0，则进程将睡眠，此时down操作并未结束。 \nup操作对信号量的值增1。 \n如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则有系统选择其中一个允许进程完成它的down操作。\n\n信号量可以用来实现同步（synchronization）。\n\n#### 互斥量\n\n如果不需要信号量的技术能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）。 \n互斥量是一个可以处于两态之一的变量：解锁和加锁。\n\n一些与互斥量相关的pthread调用：\n\n| 线程调用                | 描述                   |\n| ----------------------- | ---------------------- |\n| `pthread_mutex_init`    | 创建一个互斥量         |\n| `pthread_mutex_destroy` | 撤销一个已存在的互斥量 |\n| `pthread_mutex_lock`    | 获得一个锁或阻塞       |\n| `pthread_mutex_trylock` | 获得一个锁或失败       |\n| `pthread_mutex_unlock`  | 释放一个锁             |\n\n一些与条件变量相关的pthread调用：\n\n| 线程调用                 | 描述                             |\n| ------------------------ | -------------------------------- |\n| `pthread_cond_init`      | 创建一个条件变量                 |\n| `pthread_cond_destroy`   | 撤销一个条件变量                 |\n| `pthread_cond_wait`      | 阻塞以等待一个信号               |\n| `pthread_cond_signal`    | 向另一个线程发信号来唤醒它       |\n| `pthread_cond_broadcast` | 向多个线程发信号来让他们全部唤醒 |\n\n#### 管程\n\n一个管程（monitor）是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。  \n进程可在任何需要的时候调用管程中的过程，但他们不能在管程之外声明的过程中直接访问管程内部的数据结构。  \n管程是一种语言概念，C语言不支持。\n\n#### 消息传递\n\n消息传递（message passing）面临许多问题和设计难点，特别是位于网络中不同机器上的通信进程的情况。  \n消息系统还需要解决进程命名问题。身份认证（authentication）也是一个问题。  \n消息从一个进程复制到另一个进程通常比信号量操作和进入管程要慢。\n\n#### 屏障\n\n屏障是用于进程组而不是用于双进程的生产者-消费者情形的。  \n某些应用中划分了若干阶段，除非所有的进程都准备着手下一个阶段，否则任何进程都不能进入下一个阶段。  \n可以通过在每个阶段的结尾安置屏障（barrier）来实现。\n\n### 调度\n\n多道程序设计系统中，多个线程或进程同时竞争CPU，当只有一个CPU可用时，那么久必须选择下一个要运行的进程。  \n完成选择工作的这一部分称为调度程序（scheduler），该程序使用的算法称为调度算法（scheduling algoritgm）。\n\n**进程行为**\n\n几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。  \nCPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。  \n在完成系统调用之后，CPU又开始计算，直到它需要读取更多的数据或写更多的数据为止。\n\n![CPU的突发使用和等待I/O的时期交替出现](https://img-blog.csdn.net/20160228220737903)\n\n某些进程花费了绝大多数时间在计算上，而其他进程则在等待I/O上花费了绝大多数时间。  \n前者称为计算密集型（computer-bound），后者称为I/O密集型（I/O-bound）。\n\n**何时调度**\n\n需要处理各种情形：\n\n1.  在创建一个新进程后，需要决定是运行父进程还是运行子进程。\n2.  在一个进程退出时必须做出调度决策。\n3.  当一个进程阻塞在I/O和信号量上或者由于其他原因阻塞时，必须选择另一个进程运行。\n4.  在一个I/O中断发生时，必须做出调度决策。\n\n非抢占式调度算法：挑选一个进程，然后让该进程运行直至被阻塞，或者直到进程自动释放CPU。\n\n抢占式调度算法：选择一个进程，让该进程运行某个固定时段的最大值。  \n如果时段结束进程任在运行则被挂起，调度程序选择另外一个进程运行。\n\n**调度算法分类**\n\n三种环境\n\n1.  批处理。非抢占式，或长时间周期的抢占式算法\n2.  交互式。抢占式算法\n3.  实时。抢占有时是不需要的。\n\n**调度算法的目标**\n\n*   所有系统  \n    *   公平——给每个进程公平的CPU份额\n    *   策略强制执行——看到锁宣布的策略执行\n    *   平衡——保持系统的所有部分都忙碌\n*   批处理系统  \n    *   吞吐量——每小时最大作业数\n    *   周转时间——从提交到终止间的最小时间\n    *   CPU利用率——保持CPU时钟忙碌\n*   交互式系统  \n    *   响应时间——快速响应请求\n    *   均衡性——满足用户的期望\n*   实时系统  \n    *   满足截止时间——避免丢失数据\n    *   可预测性——在多媒体系统中避免品质降低\n\n#### 批处理系统中的调度\n\n*   先来先服务\n*   最短作业优先\n*   最短剩余时间优先\n\n#### 交互式系统中的调度\n\n*   轮转调度\n*   优先级调度\n*   多级队列\n*   最短进程优先\n*   保证调度\n*   彩票调度\n*   公平分享调度\n\n#### 实时系统中的调度\n\n实时系统的调度算法可以是静态的或动态的。  \n前者在系统开始运行之前做出调度决策；后者在运行过程中进程调度决策。\n\n* * *\n\n3、存储管理\n======\n\n现代操作系统使用分层存储器体系（memory hierarchy）。操作系统中管理分层存储器体系的部分称为存储管理器（memory manager），即记录那些内存是正在使用的，那些内存是空闲的；在进程需要时为其分配内存，在进程是用完后释放内存。\n\n### 无存储抽象\n\n最简单的存储器抽象就是根本没有抽象。早期计算机没有存储器抽象，每个程序都直接访问物理内存。想要在内存中同时运行两个程序是很困难的。\n\n### 一种存储器抽象：地址空间\n\n暴露物理内存给进程的问题：\n\n1.  如果用户程序可以寻址内存中的每个字节，它能很容易破坏操作系统。\n2.  使用这种模型想同时运行多个城市是很困难的。\n\n#### 地址空间的概念\n\n保证多个应用程序同时处于内存中并且不互相影响，需要解决两个问题：保护和重定位。\n\n地址空间为程序创造了一种抽象的内存。每个进程都有自己的地址空间，并且这个地址空间独立于其他进程的地址空间。\n\n**基址寄存器与界限寄存器**\n\n动态重定位，简单地把每个进程的地址空间映射到物理内存的不同部分。程序装在到内存期间无须重定位，程序的起始物理地址装在到基址寄存器中，程序的长度装在到界限寄存器中。\n\n缺点：每次访问内存都需要进行加法和比较运行。\n\n#### 交换技术\n\n两种处理内存超载的方法：交换（swapping）技术，虚拟内存（virtual memory）。\n\n![内存分配情况随着进程进出而变化](https://img-blog.csdn.net/20160229130312924)\n\n如果大部分进程在运行时都要增长，可以在换入或移动进程时为它多分配一些额外的内存，例如数据段与堆栈段。\n\n#### 空闲内存管理\n\n两种跟踪内存使用情况的方法：位图，空闲链表。\n\n![空闲内存管理方式](https://img-blog.csdn.net/20160229130345613)\n\n查找位图中指定长度的连续0串是耗时操作，这是位图的缺点。\n\n链表管理法适配方式：\n\n*   首次适配（first fit）：存储管理器沿着链表进行搜索，直到找到一个足够大的空闲区。\n*   下次适配（next fit）：每次找到合适的空闲区都记录，以便下次从此开始搜索。\n*   最佳适配（best fit）：搜索整个表，找出能够容纳进程的最小空闲区。\n*   最差适配（worst fit）：总是分配最大的可用空闲区，使新的空闲区比较大。\n*   快速适配（quick fit）：为那些常用大小的空闲区维护单独的链表。\n\n### 虚拟内存\n\n基本思想：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面（page）。每一页有连续的地址范围。这些页被映射到物理内存，但并不是多有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间使，由硬件立刻执行必要的映射。放程序引用到一部分不再物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。\n\n#### 分页\n\n由程序产生的地址称为虚拟地址（virtual address），它们构成了一个虚拟地址空间（virtual address space）。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。\n\n![MMU的位置和功能](https://img-blog.csdn.net/20160229130427723)\n\n虚拟地址空间按照固定大小划分成页面（page）的若干单元。在物理内存中对应的单元称为页框（page frame）。页面和页框的大小通常是一样的。\n\n当MMU注意到某页面没有被映射，于是使CPU陷入到操作系统，这个陷进称为缺页中断（page fault）。操作系统找到一个很少使用的页框且把它的内容写入磁盘。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷进的指令。\n\n#### 页表\n\n简单的，虚拟地址被分成虚拟页号（高位部分）和偏移量（低位部分）。虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。\n\n**页表项的结构**\n\n![一个典型的页表项](https://img-blog.csdn.net/20160229130456849)\n\n*   页框号\n*   “在/不在”位：对应的虚拟页面在不在内存中\n*   保护位：三位，表示读写执行\n*   修改位\n*   访问位\n*   高速缓存禁止位\n\n#### 加速分页过程\n\n在任何分页式系统中，都需要考虑两个主要问题：\n\n1.  虚拟地址到物理地址的映射必须非常快。\n2.  如果虚拟地址空间很大，页表也会很大。\n\n解决方式：\n\n*   转换检测缓冲区（Translation Lookaside Buffer，TLB）。大多数程序总是对少量的页面进行多次访问。\n*   软件TLB管理\n\n#### 针对大内存的页表\n\n*   多级页表：避免把全部页表一直保存在内存中。\n*   倒排页表：在实际内存中每一个页框有一个表项，而不是每一个虚拟页面有一个表项。\n\n### 页面置换算法\n\n当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存。如果要换出的页面在内存驻留期间已被修改，就必须写回磁盘；如果没有修改直接被覆盖就可以了。\n\n*   最优页面置换算法：置换最久将要被访问的页面。此算法无法实现。\n*   最近未使用页面置换算法（Not Recently Used，NRU）：随机地从类编号最小的非空类中挑选一个页面淘汰之。  \n    1.  没有被访问，没有被修改\n    2.  没有被访问，已被修改\n    3.  已被访问，没有被修改\n    4.  已被访问，已被修改\n*   先进先出页面置换算法（First-In，First-Out，FIFO）：每次置换链表的表头。\n*   第二次机会页面置换算法：检查最老页面的访问位。如果是0则立刻置换，如果是1则修改为0并把该页面放到链表尾端。\n*   时钟页面置换算法：环形链表，有一个表针指向最老页面。首先检查表针，如果R位是0就淘汰页面，插入页面后表针前移一个位置。如果R位是1就清除R并把表针前移一个位置，直到找到R为0的页面。\n*   最近最少使用页面置换算法（Least Recently Used，LRU）：置换未使用时间最长的页面。\n*   工作集页面置换算法：进程当前正在使用的页面的集合称为它的工作集（working set）。缺页中断时淘汰一个不再工作集中的页面。\n*   工作集时钟页面置换算法\n\n**页面置换算法小结**\n\n| 算法                    | 注释                   |\n| ----------------------- | ---------------------- |\n| 最优算法                | 不可实现，但可用作基准 |\n| NRU（最近未使用）算法   | LRU的很粗糙的近似      |\n| FIFO（先进先出）算法    | 可能抛弃重要的页面     |\n| 第二次机会算法          | 比FIFO有大的改善       |\n| 时钟算法                | 现实的                 |\n| LRU（最近最少使用）算法 | 很优秀，但很难实现     |\n| NFU（最不常用）算法     | LRU的相对粗略的近似    |\n| 老化算法                | 非常近似LRU的有效算法  |\n| 工作集算法              | 实现起来开销很大       |\n| 工作集时钟算法          | 好的有效算法           |\n\n### 分页系统中的设计问题\n\n*   局部分配策略与全局分配策略：当发生缺页中断时，页面置换算法在寻找最近最少使用的页面时，只考虑分配给该进程的页面，称为局部页面置换算法；考虑所有在内存中的页面，称为全局页面置换算法。\n*   负载控制\n*   页面大小：确定最佳页面大小。\n*   分离的指令空间和数据空间：为指令和数据设置分离的地址空间\n*   共享页面：UNIX系统中进行`fork`系统调用后，父子进程共享程序文本和数据。这些进程拥有自己的页表，但都指向同一个页面集合。只要有一个进程要求更新数据，就会触发只读保护，引发操作系统陷进，生成该页的一个副本。这种方式称为写时复制。\n*   共享库：如果其他程序已经装载了某个共享库，另一个程序就没必要再次装载了。编译共享库时，使用-fPIC产生位置无关代码。\n*   内存映射文件：进程可以通过发起一个系统调用，将一个文件映射到虚拟地址空间的一部分。在访问页面时每次一页的读入。多个进程可以通过映射同一个文件来通信。\n*   清除策略：如果发生缺页中断时系统中有大量的空闲页框，此时分页系统工作在最佳状态。一种实现清除策略的方法就是使用一个双指针时钟。\n*   虚拟内存接口\n\n### 有关实现的问题\n\n*   与分页有关的工作：操纵系统要在四段时间里做与分页相关的工作。进程创建时，进程执行时，缺页中断时，进程终止时。\n*   缺页中断处理  \n    1.  硬件陷入内核，在堆栈中保存程序计数器。\n    2.  启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破环。\n    3.  当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。\n    4.  一旦知道发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。\n    5.  如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。\n    6.  一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。\n    7.  当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反应它的位置，页框也被标记为正常状态。\n    8.  恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。\n    9.  调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。\n    10.  该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。\n*   指令备份：使用一个隐藏的内部寄存器。在每条指令执行之前，把程序计数器的内容复制到该寄存器中。\n*   锁定内存中的页面：保证正在做I/O操作的页面不会被移出内存。\n*   后备存储\n*   策略和机制的分离\n\n### 分段\n\n分页和分段的比较\n\n| 考察点                                   | 分页                                               | 分段                                                         |\n| ---------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |\n| 需要程序员了解正在使用这种技术吗？       | 否                                                 | 是                                                           |\n| 存在多少线性地址空间？                   | 1                                                  | 许多                                                         |\n| 整个地址空间可以超出物理存储器的大小吗？ | 是                                                 | 是                                                           |\n| 过程和数据可以内区分并分别被保护吗？     | 否                                                 | 是                                                           |\n| 其大小浮动的表可以很容易提供吗？         | 否                                                 | 是                                                           |\n| 用户间过程的共享方便吗？                 | 否                                                 | 是                                                           |\n| 为什么发明这种技术？                     | 为了得到大的线性地址空间而不必购买更大的物理存储器 | 为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护 |\n\n* * *\n\n4、文件系统\n======\n\n### 文件\n\n*   文件命名：在具体系统中规则不一，UNIX文件系统区分大小写，MS-DOS文件系统不区分大小写。\n*   文件结构：字节序列、记录序列、树。所有UNIX、MS-DO、Windows系统都把文件看成无结构字节序列。\n*   文件类型：ASCII文件和二进制文件。\n*   文件存取：顺序存取和随机存取。\n*   文件属性：文件的附加信息，称为属性（attribute）或元数据（matedata）。\n*   文件操作：常用系统调用  \n    *   `create`：创建不包含任何数据的文件。\n    *   `detele`：删除文件释放磁盘空间。\n    *   `open`：打开文件，把文件属性和磁盘地址表装入内存，便于后续调用。\n    *   `close`：关闭文件释放内部表空间。\n    *   `read`：在文件中读取数据。\n    *   `write`：向文件中写数据。\n    *   `append`：在文件末尾添加数据。\n    *   `seek`：对于随机存取文件，指定从何处开始取数据。\n    *   `get attribute`：读取文件属性。\n    *   `set attribute`：某些属性可由用户设置。\n    *   `rename`：改变已有文件的名字。\n\n### 目录\n\n*   一级目录系统：一个目录中包含所有文件，称为根目录。能快速定位文件。\n*   层次目录系统：层次化的目录树结构，几乎所有现代文件系统都采用。\n*   路径名：绝对路径与相对路径。\n*   目录操作：常用基本系统调用。  \n    *   `create`：创建目录，处理目录项.和..外，目录内容为空。\n    *   `delete`：删除目录。\n    *   `opendir`：打开目录以备读取。\n    *   `closedir`：关闭目录释放内部表空间。\n    *   `readdir`：读取目录返回目录下一个目录项。\n    *   `rename`：更改目录名称。\n    *   `link`：连接技术允许在多个目录中出现同一个文件。\n    *   `unlink`：删除目录项。\n\n### 文件系统的实现\n\n#### 文件系统布局\n\n文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。磁盘的0号扇区称为主引导记录（Master Boot Record，MBR），用来引导计算机。在MBR的结尾是分区表。该表给出了每个分区的起始地址和结束地址。表中的一个分区被标记为活动分区。在计算几被引导时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一个块，称为引导块（boot block），并执行之。引导块中的程序将装在该分区中的操作系统。\n\n一种可能的文件系统布局：\n\n![一种可能的文件系统布局](https://img-blog.csdn.net/20160229162300011)\n\n*   超级块（superblock）：包含文件系统的所有关键参数。\n*   空闲空间管理：空闲块的信息，可以用位图或指针表形式给出。\n*   i节点：数据结构数组，每个文件一个，说明文件的方方面面。\n*   根目录：目录树的根部。\n*   目录和文件：存放其他所有目录和文件\n\n#### 文件的实现\n\n*   连续分配：把每个文件作为一连串连续数据块存储在磁盘上。易产生零碎空间。\n*   链表分配：为每个文件构造磁盘块链表。随机存取缓慢。指针占去了一些空间。\n*   在内存中采用表的链表分配：取出每个磁盘块的指针字，把它放在内存的一个表中。称为文件分配表（File Allocation Table，FAT）。对于大磁盘而言占用内存太多。\n*   i节点：给每个文件赋予一个称为i节点（index-node）的数据结构，其中列出了文件属性和文件块的磁盘地址。\n\n#### 目录的实现\n\n1.  目录中有一个固定大小的目录项列表，每个文件对应一项，其中包含一个文件名、一个文件属性结构以及泳衣说明磁盘块位置的一个或多个磁盘地址。\n2.  采用i节点的系统，把文件属性存放在i节点中，目录项更短：只有文件名和i节点号。\n\n两种处理目录项中长文件名的方式：\n\n![两种处理目录项中长文件名的方式](https://img-blog.csdn.net/20160229162323857)\n\n#### 共享文件\n\n1.  磁盘块不列入目录中，而是列入一个与问价本身关联的小型数据结构（i节点中）中。目录将指向这个小型数据结构。\n2.  建立一个类型为link的新文件，使其与另一个文件存在连接。新文件中指包含了它所连接的文件的路径名。称为符号连接（symbolic linking）。\n\n#### 日志文件系统\n\n基本思想是将整个磁盘结构化为一个日志。每隔一段时间，或是有特殊需要时，被缓冲在内存中的所有未决的血操作都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。\n\n保存一个用于记录系统下一步将要做什么的日志。这样当系统在完成它们即将完成的任务钱崩溃时，重新启动之后，可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。这样的文件系统称为日志文件系统。\n\n为了增加可信性，一个文件系统可以引入数据库中原子事务（atomic transaction）的概念。\n\n#### 虚拟文件系统\n\n大多数UNIX操作系统都使用虚拟文件系统概念尝试将多种文件系统统一成一个有序的框架。  \n关键思想解释抽象出所有文件系统的共有部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据。\n\n虚拟文件系统的位置：\n\n![虚拟文件系统的位置](https://img-blog.csdn.net/20160229162346824)\n\n### 文件系统管理和优化\n\n*   磁盘空间管理  \n    *   块大小\n    *   记录空闲块\n    *   磁盘配额\n*   文件系统备份\n*   文件系统的一致性\n*   文件系统的性能  \n    *   高速缓存\n    *   块提前读\n    *   减少磁盘臂运动\n*   磁盘碎片整理\n\n\n5、输入输出\n======\n\n### I/O硬件原理\n\nI/O设备大致分为两类：\n\n*   块设备（blocl device）：所有传输以一个或多个完整的（连续的）块为单位。\n*   字符设备（character device）：以字符为单位发送或接受一个字符流。\n\nI/O设备一般由机械部件和电子部件两部分组成，电子部件称作设备控制器（device controller）或适配器（adapter）。\n\n内存映射I/O的优点：\n\n1.  对于内存映射I/O，设备控制寄存器只是内存中的变量，在C语言中可以和任何其他变量一样寻址。\n2.  对于内存映射I/O，不需要特殊的保护机制来阻止用户进程执行I/O操作。\n3.  对于内存映射I/O，可以引用内存的每一条指令也可以引用控制寄存器。\n\n### I/O软件原理\n\n在设计I/O软件时一个关键的概念是**设备独立性**（device independence）。\n\nI/O软件的几个问题：\n\n*   统一命名：不应该依赖于设备。\n*   错误处理：尽可能在接近硬件的层面得到处理。\n*   同步和异步传输。\n*   缓冲：数据离开设备之后不能直接存放到最终目的地。\n*   共享设备的独占问题。\n\nI/O的最简单形式是让CPU做全部工作，这一方法称为程序控制I/O。\n\n使CPU在等待打印机变为就绪的同时做某些其他事情的方式就是使用中断驱动I/O。缺点是中断发生在每个字符上，浪费时间。\n\n由DMA控制器处理全部的I/O工作，使CPU可以在I/O期间做其他工作。\n\n### I/O软件层次\n\nI/O软件通常组织成四个层次：\n\n![I/O软件系统的层次](https://img-blog.csdn.net/20160301124207916)\n\n*   中断处理程序\n*   设备驱动程序\n*   与设备无关的I/O软件\n*   用户空间的I/O软件\n\n### 盘\n\n*   磁盘\n*   RAID\n*   CD-ROM\n*   可刻录CD\n*   可重写CD\n*   DVD\n\n影响磁盘块读写速度的因素\n\n1.  寻道时间（将磁盘臂移动到适当的柱面上所需的时间）\n2.  旋转时间（等待适当扇区旋转到磁头下所需的时间）\n3.  实际数据传输时间。\n\n### 时钟\n\n*   时钟硬件：晶体振荡器、计数器和存储寄存器。\n*   时钟软件\n*   软定时器\n\n### 用户界面：键盘、鼠标和显示器\n\n*   输入软件  \n    *   键盘软件\n    *   鼠标软件\n*   输出软件  \n    *   文本窗口\n    *   X窗口系统\n    *   图形用户界面\n    *   位图\n    *   字体\n\n\n6、死锁\n====\n\n### 资源\n\n所有需要排他性使用的对象都可以称作资源（resource）。资源可以分为两类：\n\n*   可抢占资源。可以从拥有它的进程中抢占而不会产生任何副作用，例如存储器。\n*   不可抢占资源。在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。\n\n### 死锁概述\n\n死锁的规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。\n\n资源死锁的4个条件：\n\n1.  互斥条件。\n2.  占有和等待条件。\n3.  不可抢占条件。\n4.  环路等待条件。\n\n四种处理死锁的策略：\n\n1.  忽略该问题。\n2.  检测死锁并恢复。\n3.  仔细对资源进行分配，动态的避免死锁。\n4.  通过破坏引起死锁的四个必要条件之一，防止死锁的产生。\n\n### 鸵鸟算法\n\n鸵鸟算法：把头埋到沙子里，假装根本没有问题发生。\n\n### 死锁检测和死锁恢复\n\n*   每种类型一个资源的死锁检测。检测是否存在有向图环路。\n*   每种类型多个资源的死锁检测。基于矩阵的算法。\n*   从死锁中恢复  \n    *   利用抢占恢复\n    *   利用回滚恢复\n    *   通过杀死进程恢复\n\n### 死锁避免\n\n*   资源轨迹图\n*   安全状态和不安全状态\n*   单个资源的银行家算法\n*   多个资源的银行家算法\n\n### 死锁预防\n\n*   破环互斥条件\n*   破坏占有和等待条件\n*   破坏不可抢占条件\n*   破坏环路等待条件\n\n### 其他问题\n\n*   两阶段加锁\n*   通信死锁\n*   活锁\n*   饥饿\n\n\n7、多媒体操作系统\n=========\n\n### 多媒体简介\n\n多媒体的两个关键特征：\n\n1.  多媒体使用极高的数据率。\n2.  多媒体要求实时回放。\n\n### 多媒体文件\n\n#### 视频编码\n\n基于人眼的特性：当一幅图像闪现在视网膜上时，在它衰退之前将保持几毫秒时间。如果一个图像序列以每秒50或更多张图像闪现，眼界就不会注意到它看到的是不连续的图像。\n\n为了将二维图像表示作为时间函数的一维电压，摄像机用一个电子束对图像进行横向扫描并缓慢地向下移动，记录下电子束经过处光的强度。在扫描的终点处，电子束折回。称为一帧（frame）。\n\n彩色视频采用与单色视频相同的扫描模式，只不过使用了三个同时运动的电子束来显示图像。红、绿、蓝（RGB）三原色。\n\n数字视频最简单的表示方法是帧的序列，每一帧由呈矩形栅格的图像要素即像素（pixel）组成。每个像素RGB三色中的每种颜色用8个二进制位来表示。\n\n#### 音频编码\n\n音频波可以通过模数转换器（Analog Digital Converter，ADC）转换成数字形式。ADC以电压作为输入，并且生成二进制数作为输出。\n\n由于每一样本的位数有限而引入的误差称为量化噪声（quantizatuin）。\n\n电话系统使用的实时脉冲编码调制（pulse code modulation），脉冲编码调制以每秒7位或8位对声音采样8000次，故这一系统的数据率为56000bps或64000bps。由于每秒只有8000个样本，所以4kHz以上的频率就丢失了。\n\n音频CD是以每秒44100个样本的采样率进行数字化的，足以捕获高达22050Hz的频率。\n\n### 视频压缩\n\n所有的压缩系统都需要两个算法：一个用于在源端进行数据压缩，另一个用于在目的端对数据进行解压缩。分别为编码算法和解码算法。\n\n编码与解码具有某些不对称性。视频信号经过编码和解码之后与原始信号存在轻微差异时，系统被称为是有损的（lossy）。\n\n#### JPEG标准\n\n用于压缩连续色调静止图像的JPEG（Joint Photographic Experts Group，联合摄影专家组）。用于压缩运动图像的MPEG不过是分别对每一帧进行JPEG编码，再加上某些帧间压缩和运动补偿等额外的特征。\n\n#### MPEG标准\n\nMPEG（Motion Picture Experts Group，运行图像专家组）标准是用于压缩视频的主要算法。\n\nMPEG的两个版本均利用了在电影中存在的两类冗余：空间冗余和时间冗余。MPEG-2输出有三种不同的帧组成：\n\n1.  I帧：自包含的JPEG编码静止图像\n2.  P帧：与上一帧逐块的差。\n3.  B帧：与上一帧和下一帧的差。\n\n### 音频压缩\n\n最流行的是MP3（MPEG音频层3），属于MPEG视频压缩标准里的音频部分。\n\n音频压缩可由两种方法完成。波形编码技术和感知编码。\n\n### 多媒体进程调度\n\n*   调度同质进程\n*   一般实时调度\n*   速率单调调度\n*   最早最终时优先调度\n\n### 多媒体文件系统范型\n\n*   VCR控制功能\n*   近似视频点播\n*   具有VCR功能的近似视频点播\n\n### 文件存放\n\n多媒体文件非常庞大、通常只写一次而读许多次，并且倾向于被顺序访问。\n\n*   在单个磁盘上存放文件\n*   两个替代的文件组织策略\n*   近似视频点播的文件存放\n*   在单个磁盘上存放多个文件\n*   在多个磁盘上存放文件\n\n### 高速缓存\n\n*   块高速缓存\n*   文件高速缓存\n\n### 多媒体磁盘调度\n\n*   静态磁盘调度\n*   动态磁盘调度\n\n* * *\n\n8、多处理机系统\n========\n\n### 多处理机\n\n共享存储器多处理机（multiprocessor）是这样一种计算机系统，其两个或更多的CPU全部共享访问一个公用的RAM。\n\n*   UMA（Uniform Memory Access，统一存储器访问）\n*   NUMA（Nonuniform Memory Access，非统一存储器访问）\n\n多处理机硬件：\n\n*   基于总线的UMA多处理机体系结构\n*   使用交叉开关的UMA多处理机\n*   使用多级交换的UMA多处理机\n*   NUMA多处理机\n*   多核芯片\n\n多处理机操作系统类型：\n\n*   每个CPU有自己的操作系统\n*   主从多处理机\n*   对称多处理机\n\n多处理机调度\n\n*   分时\n*   空间共享\n*   群调度\n\n### 多计算机\n\n多处理机硬件\n\n*   互连技术\n*   网络接口\n\n底层通信软件\n\n用户层通信软件\n\n*   发送和接收\n*   阻塞调用和非阻塞调用\n\n分布式共享存储器\n\n*   复制\n*   伪共享\n*   实现顺序一致性\n\n负载平衡\n\n*   图论确定算法\n*   发送者发起的分布式启发算法\n*   接收者发起的分布式启发算法\n\n### 虚拟化\n\n### 分布式系统\n\n网络硬件\n\n*   以太网\n*   因特网\n\n网络服务协议\n\n*   网络服务\n*   网络协议\n\n基于文档的中间件\n\n基于文件系统的中间件\n\n*   传输模式\n*   目录层次\n*   命名透明性\n*   文件共享的语义\n\n基于对象的中间件\n\n基于协作的中间件\n\n*   Linda\n*   发布/订阅\n*   Jini\n\n网络\n\n* * *\n\n9、安全\n====\n\n### 环境安全\n\n*   威胁  \n    *   计算机系统主要安全目标  \n        1.  数据机密性\n        2.  数据完整性\n        3.  数据可用性\n        4.  排外性\n    *   计算机系统主要安全威胁  \n        1.  数据暴露\n        2.  数据篡改\n        3.  拒绝服务\n        4.  系统被病毒控制\n*   入侵者  \n    *   入侵者表现形式  \n        *   被动入侵\n        *   主动入侵\n    *   入侵者种类  \n        1.  非专业用户的随意浏览\n        2.  内部人员的窥视\n        3.  为获取利益而尝试\n        4.  商业或军事间谍\n*   数据意外遗失  \n    *   天灾\n    *   软硬件错误\n    *   认为过失\n\n### 密码学原理\n\n明文与密文之间的关系：\n\n![明文与密文之间的关系](https://img-blog.csdn.net/20160301171804548)\n\n*   私钥加密技术。对称加密，安全性取决于对密钥的管理\n*   公钥加密技术。每个人都有公钥和私钥，公开其中的公钥，用公钥加密，只能用对应私钥解密。\n*   单向函数。散列函数\n*   数字签名\n*   可信平台模块（Trusted Platform Modules，TPM）。是一种加密处理器，使用内部的非易失性存储介质来保存密钥。\n\n### 保护机制\n\n*   保护域\n*   访问控制表\n*   权能\n*   可信系统\n*   可信计算基\n*   安全系统的形式化模型\n*   多级安全\n*   隐蔽信道\n\n### 认证\n\n*   使用口令认证\n*   使用实际物体的认证方式\n*   使用生物识别的验证方式\n\n### 内部攻击\n\n*   逻辑炸弹\n*   后门陷阱\n*   登录欺骗\n\n### 利用代码漏洞\n\n*   缓冲区溢出攻击\n*   格式化字符串攻击\n*   返回libc攻击\n*   整数溢出攻击\n*   代码注入攻击\n*   权限提升攻击\n\n### 恶意软件\n\n*   特洛伊木马\n*   病毒\n*   蠕虫\n*   间谍软件\n*   rootkit\n\n### 防御\n\n*   防火墙\n*   反病毒和抑制病毒技术\n*   代码签名\n*   囚禁\n*   基于模型的入侵检测\n*   封装移动代码\n*   Java安全性\n\n---\n\n# 一些问题\n- **1. 什么是操作系统？**\n  操作系统是用于管理计算机资源，合理组织安排计算机工作流程，方便用户使用的计算机程序的集合\n- **2. 操作系统分类？**\n  批处理操作系统：计算机成批的，自动的，依次处理用户的作业，用户提交后只能等待这批作业全部处理完之后才能得到输出结果\n  分时系统：操作系统将时间分为若干时间片，依次轮流的为每个作业处理\n  实时系统:\n  个人计算机操作系统\n  网络操作系统\n  分布式操作系统\n  嵌入式操作系统\n  ...\n- **3. 用户态与内核态？**\n  用户态：执行用户程序\n  内核态：运行操作系统程序，与硬件相关的操作都必须陷入内核态执行\n  特权指令：只能操作系统使用，用户程序不能使用的指令\n  非特权指令：用户程序可以使用的指令\n  用户态 -> 内核态：中断 / 异常 / 陷入\n  内核心 -> 用户态：设置程序状态字PSW\n- **4. 中断与异常？**\n  相同点：\n  CPU对系统发生的某件事件做出的一种反应，CPU暂停正在执行的程序，保留现场，转而自动执行相应事件的处理程序，处理完毕后，回到断点处恢复现场，继续处理之前被打断的程序\n  不同点：\n  中断是被外部时间所引发的，引入中断是为了支持CPU与设备之间的并行操作\n  异常是由正在执行的指令所引发的，引入异常是为了处理CPU执行指令时本身可能会出现的问题，如除零\n- **5. 系统调用？**\n  系统调用是用户在编程时可以调用的操作系统功能\n  是操作系统提供给编程人员的唯一接口\n  使CPU从用户态陷入内核态\n  系统调用主要包括进程控制，进程通信，文件使用，目录控制，设备管理等等\n- **6. 并发与并行？**\n  并发：一段时间内，多个进程同时运行，如多道程序设计，允许多个进程同时存在内存，允许多个进程处于已经开始执行但是尚未执行完毕的状态\n  并行：某一时刻，有多个进程在同时运行，实现并行只能是多个处理器，因为一个CPU某时刻只能一个进程正在运行\n- **7. 进程？**\n  定义：进程是具有独立功能的程序，关于某个特定数据集的一次运行活动，是系统进行资源分配和调度的基本单位。\n\n**进程的三状态模型：**\n就绪态（ready）：进程准备好了，随时可以被系统调度进CPU执行\n运行态（running）：进程正在CPU中执行时的状态\n阻塞态（waiting）：进程被中断，比如等待IO时间输入，处于阻塞状态，除非某种事件发生，否则进程不能运行\n进程的其他状态：\n创建（new）：已完成创建，但是因为资源有限，系统尚未打算执行该进程\n终止（terminated）：进程执行完毕后，进入该状态，完成一些数据统计与资源回收\n挂起（suspend）：用于调节负载，进程被放入磁盘，不占用内存空间\n\n**进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成**\n主要有进程创建原语，进程撤销原语，阻塞原语，唤醒原语，挂起原语，激活原语，改变进程优先级等等\n**进程的创建**：unix（fork/exec），windows（CreateProcess）\n给新进程分配唯一标识PID与进程控制块PCB\n为进程分配地址空间\n初始化进程控制块\n设置相应的队列指针（把新进程加入到进程就绪队列链表中）\n**进程的撤销**：unix（exit），windows（TerminateProcess）\n收回进程所占用的资源（收回分配的内存，关闭打开的文件等）\n撤销该进程的PCB\n**进程阻塞**\n处于运行状态的进程，由于期待某事件的发生（如IO输入，等待其他进程发送的消息等），当此事件尚未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态\n**UNIX中几个基本的进程控制操作**\nfork()：通过复制调用进程来建立新的进程，是最基本的进程建立操作，对父进程返回子进程的pid，对子进程返回0\nexec()：包括一系列的系统调用，通过用一段新的程序代码，覆盖原来的空间，实现进程执行代码的转换\nwait()：提供初级进程同步操作，使一个进程等待另外一个进程的结束\nexit()：终止一个进程的运行\n\n- **8. 进程控制块PCB？**\n  PCB：Process Control Block，进程控制块，又称为进程描述符\n  操作系统用于管理进程的一个专门的数据结构\n  记录进程的各种属性，描述进程的动态变化过程\n  PCB是系统感知进程存在的唯一标志，PCB与进程为一一对应的\n  进程表：是所有进程的PCB集合\n  PCB里面应该包括进程的那些信息呢？\n  进程描述信息（进程标识符PID，进程名，用户标识符，进程组关系）\n  进程控制信息（当前状态，优先级，代码执行入口，程序磁盘地址等等）\n  所拥有的资源和使用情况（虚拟地址空间，打开文件列表）\n  CPU现场（寄存器值，指向该进程页表的指针）\n- **9. 原语，原子操作？**\n  原语：系统提供的完成某种特定功能的一段程序，由机器指令编写，执行过程不可中断\n  原子操作：在多线程操作系统中不能被其他线程打断的操作叫做原子操作。当该次操作无法完成时，必须回到操作之前的状态，原子操作不可分割。\n- **10. 进程与程序的区别？**\n  进程是程序在特定数据集上的一次执行过程，是动态的；程序是存储在某个空间的静态文件\n  进程是有生命周期的；而程序是相对持久的\n  进程能更准确的刻画并发；程序不能\n  一个程序可对应多个进程\n  进程具有创建其他进程的功能\n- **11. 线程？**\n  **为什么有了进程还需要引入线程？**\n  应用程序的需要：某些应用程序需要同时发生多种活动，比如字符处理软件，当输入文字时，排版也在同时进行，自动保存也在进行。如果用线程来描述这样的活动的话，编程模型就会变得更简单，因为同一进程的所有线程都处于同一地址空间，拥有相同的资源\n  开销上考虑：线程更加轻量级，相对进程而言，线程的相关信息较少，它更容易创建，也更容易撤销。当有大量线程需要创建和修改时，这会节省大量的开销；线程之间的切换比进程之间的切换要快的多，因为切换线程不需要考虑地址空间，只需要保存维护程序计数器，寄存器，堆栈等少量信息；线程之间的通信也比进程之间的通信要简单，无需调用内核，直接通过共享变量即可\n  **线程的概念**\n  线程是进程中的一个运行实体，是CPU的调度单位\n  进程有两个属性，一个是资源的拥有者，另一个是CPU的调度单位\n  引入线程之后，进程还是资源的拥有者，而线程继承了CPU的调度单位这一属性，而同一进程的所有线程共享进程的所有资源\n  **线程的属性**\n  线程标识符ID\n  有状态及状态转换，即线程切换\n  切换线程时需要保存上下文：包括程序计数器，寄存器，堆栈等\n  线程有自己的堆栈\n  同一进程的所有线程共享进程的地址空间和其他资源\n  一个线程可以创建也撤销另一个线程\n  **线程机制的实现**\n  **用户级线程**\n  在用户空间建立线程库，提供一组管理线程的过程\n  由运行时系统来完成线程的管理工作\n  内核管理的还是进程，内核不知道线程的存在\n  线程切换不需要陷入内核\n  典型如Linux，Unix\n  优点：\n  切换速度快\n  调度算法可以由应用程序设定\n  用户级线程可以运行在任何操作系统，包括不支持线程操作系统\n  缺点：\n  同一进程的所有线程只能运行在一个处理器上\n  若一个进程的某个线程调用了阻塞的系统调用，那么该进程的所有线程也将会被阻塞，页面失效也会有同样的问题\n  **内核级线程**\n  内核管理所有的线程管理，创建，撤销与调度，并向应用程序提供API\n  内核维护进程和线程上下文\n  线程的切换需要内核支持\n  以线程为基础进行调度\n  优点：\n  由内核调度，当有多个处理器时，一个进程的多个线程可以在多个处理器上同时执行\n  一个进程的某个线程阻塞不会引起其他线程的阻塞，页面失效同理\n  缺点：\n  由内核进行创建，撤销，调度，系统开销更大\n  典型如Windows\n  **混合实现**\n  线程创建在用户空间\n  线程调度在内核\n- **12. 进程与线程的区别与联系**\n  **定义的角度**\n  进程是具有特定功能的程序关于某个数据集的一次运行活动\n  线程是进程的一个一个运行实体\n  **角色的角度**\n  进程是CPU资源分配的基本单位，线程是CPU调度的基本单位\n  **资源共享的角度**\n  进程之间一般不能共享资源，两个进程间通信需要进行系统调用；\n  而同一进程的所有线程共享该进程的地址空间和其他资源，线程之间的通信可直接通过共享内存来进行\n  **独立性角度**\n  进程与进程之间一般是独立的，每个进程都有自己独立的地址空间\n  而线程没有自己的地址空间，它是依赖于进程而存在的\n- **13. 进程间通信**\n  **竞争条件**\n  两个或多个进程读写某些共享数据，其最终的运行结果取决于进程间的精确运行时序\n  **临界区**\n  共享内存进行访问的片段\n  **进程互斥**\n  当一个进程正在访问临界区时，其他进程不能对临界区进行访问\n  **互斥的原则**\n  两个进程不能同时处于临界区\n  当没有进程处于临界区的时候，想进入临界区的进程可以进入\n  临界区外的进程不得阻塞其他进程进入临界区\n  不能使想进入临界区的进程无限等待\n  **进程同步**\n  系统中多个进程完成某些任务存在某种时序关系，需要相互合作，共同完成\n- **14. 互斥锁mutex**\n  适用于管理一小段代码或共享资源\n  一般有两种状态**lock**, **unlock**\n  当某个进程向进入临界区时，调用 mutex_lock，这样其他想进入临界区的进程就无法进入\n  离开临界区时，调用 mutex_unlock，离开之后，其他想进入临界区的进程就可以进入了\n  值得注意的是，lock与unlock只能是同一进程调用\n  **mutex的底层实现**\n  **mutex_lock:**\n  TSL, REGISTER, MUTEX（将互斥信号复制到寄存器，并将内存中的互斥信号置为１）\n  CMP REGISTER, #0（比较刚才复制进来的那个信号等于０吗？）\n  JZE ok（如果是０，那么表示可以进入）\n  CALL thread_yield（如果不是０，表示不能进入，此时线程调用yield，放弃CPU，稍后再试。避免一直循环等待，一直占有CPU，而正在临界区线程没有机会运行，肯定也就没有机会退出临界区，释放锁，而线程就会一直等待下去）\n  JMP mutex_lock（稍后再试）\n  ok: RET（如果是0，即ok，返回调用者，并进入临界区）\n  **mutex_unlock**\n  MOVE MUTEX, #0（将互斥信号置为０）\n  RET（返回调用者）\n  **mutex为什么能锁住临界区？**\n  因为TSL或者XCHG是原子性的，即不可打断的。\n  如果用另外一个共享变量ｘ而不是mutex来锁住临界区的话，那么共享变量也是一个临界区。如果进程１读取ｘ后被打断，另一个进程也读入ｘ后发现能进，并改变ｘ，后切换回进程１，则进程１发现先前读入的ｘ值也能进取，所有最后有两个进程进入临界区了。\n  mutex的关键之处就在于，用TSL或XCHG指令可以原子性的将mutex的值读入寄存器，并将值置为１，不可打断。所以当执行了这条语句之后，即使被打断，其他进程来判断mutex的值，也是１，所以不会进入，所以绝对不会出现两个进程在统一临界区的情况。\n- **15. 信号量semaphore**\n  一个特殊的变量，用于进程间传递信息的一个整数值\n  主要用于临界区互斥与进程间同步（进程的运行保持某种特定的时序）\n  mutex有时也称为二元信号量\n  定义：\n\n```\nstruct semaphore\n{\n	int value;\n	struct process * list;    // 当value<0时，将进程阻塞至此队列\n};\n```\n\n对信号量可以实施的操作：wait(), signal()或者P, V PV操作均为原语操作\n\n```\nwait(semaphore s)\n{\n	s->value--;　// 将value的值减一\n	if (s->value < 0)　//若value的值小于０\n	{\n		add this process to s->list;　//则将此进程的信息加入list队列\n		block();    // 并将此进程阻塞\n	}\n}\n\nsignal(semaphore s)\n{\n	s->value++;　　// 将value值加一\n	if (s->value <= 0)　　// 如果value的值小于等于０时，说明在value值加一之前，value的值是负数，即有进程阻塞在list中，此时应该将其中一个进程唤醒\n	{\n		remove a process p from s->list;　　// 将进程p从list移除\n		wakeup(p);　　// 并将进程p唤醒\n	}\n	// 如果value的值是正数的话，就说明之前的值至少是大于等于０的，即在list中没有进程阻塞，所以只需将value的值加一，表示可用的资源又多了一个，而不需要其他操作\n}\n```\n\n- **16. 生产者消费者问题**\n  一个生产者的进程与一个消费者的进程，两个进程共享一段缓存区\n  生产者生产了一个产品，就往缓存区里放，当缓存区满了，则进入睡眠，当消费者取出了一个产品后再将生产者唤醒\n  消费者消费了一个产品，就从缓存区中取出，当缓存区空了，即进入睡眠，当生产者生产了一个产品后，再将其唤醒\n\n```\n// 存在严重竞争条件的生产者消费者模型\n#define N 100           // 缓存区的最大值\nint count = 0;　　　// 定义的共享变量，用于记录缓存区中产品的个数\nint item;　\nvoid producer()\n{\n	item = produce_iter();		　// 生产一个产品\n	if (count == N) 	sleep();	     // 如果缓存区满了，则生产者sleep\n	count++;                                          // 如果没满或者被唤醒了，则继续执行，先count加一\n	insert_item(item);　　　　　// 将产品放入缓存区\n	if (count == 1) 	wakeup(consumer);　// 如果此时count等于１，就说明之前缓存区空的，即此时消费者应该在sleep，因为此时缓存区有产品了，应该将其唤醒\n}\nvoid', '现代操作系统', 1591632000, 28);
INSERT INTO `article` VALUES (10, 1, '操作系统', '# 操作系统\n\n<a name=\"b191bacb\"></a>\n## 第一章 操作系统概述\n\n\n<a name=\"3f281da8\"></a>\n### 1.1 操作系统初步认识\n桌面常见四大操作系统:Windows、Linux、Mac、Unix\n\n- Windows之Windows 1.0：①微软首先在PC上尝试图形界面，1985年发行。②基于MS-DOS。\n- Windows之WIN XP：①发行于2001年8月25日；②家庭版和专业版。\n- Mac操作系统：①基于Unix内核的图形化操作系统；②苹果产品专属操作系统。\n- Linux之RedHat小红帽：RedHat以GNU/Linux为核心。\n\n\n<br />**没有安装操作系统的计算机依然能够运行程序。**<br />\n<br />**操作系统的基本功能**：\n\n- 提供操作界面（操作界面、可视化）、控制程序运行（控制多个程序并发运行）、管理系统资源、配置系统参数（系统设置、配置）、监控系统状态、工具软件集合（提供工具、管理软件）\n\n\n<br />**讨论**：<br />①常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？<br />\n\n- 从OS的定义来看，虚拟机软件不算OS。因为我们定义OS的功能之一是为应用程序（application）提供CPU调度，内管管理等服务的。尽管虚拟机软件能管理内存，但是。不要忘了，我们只有安装OS之后，才能安装虚拟机软件。所以，虚拟机软件本质上讲还是应用程序。VM软件通过内含的驱动程序，确实可以操作包括内存在内的硬件，虚拟一个新的硬件环境，但是我们还是要继续在其中安装一个 OS才能使用。所以，本质上VM是应用程序，但是，它是一个功能特别底层的APP。\n\n\n\n<a name=\"aa6cdf5d\"></a>\n### 1.2 操作系统的功能和定义\n**（1）功能**：\n\n- **进程管理（CUP管理）**\n   - 进程**控制**：创建、暂停、唤醒、撤销；进程**调度**：调度策略、优先级；进程**通信**：进程间通信。\n- **内存管理**\n   - 内存分配、内存共享、内存保护、虚拟内存\n- **设备管理**\n   - 设备的分配和调度、设备无关性、设备传输控制、设备驱动\n- **文件管理**\n   - 存储空间管理、文件的操作、目录的操作、文件和目录的存取权限管理\n\n\n<br />**（2）定义**：**操作系统是一个大型系统程序**。\n\n- 提供用户**接口**，方便用户控制计算机\n- 负责为应用程序**分配和调度软硬件资源**，并控制与协调应用程序并发活动，帮助用户存取和保护信息。\n\n\n<br />**（3）操作系统的地位**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468616508-eadca064-1bae-4ffd-80c5-72219a1e1416.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&name=image.png&originHeight=389&originWidth=971&size=218429&status=done&style=none&width=485.5)<br />\n<br />操作系统与普通软件之间最核心的差别就是**进程管理**和**内存管理**。<br />\n\n<a name=\"9bf64a8e\"></a>\n### 1.3 操作系统发展历史\n\n\n> 发展的两大动力：**用户需求提升** 和 **硬件技术进步**（操作系统需要更好发挥硬件的性能）\n> 第一台数字电子计算机---ENIAC\n> 1955年， IBM 推出第一台晶体管计算机：典型机型7094\n\n\n<br />**计算机硬件**发展的四个典型阶段（速度、容量、稳定性、可靠性都得到逐步提高）：<br />\n\n- **电子管时代**【1946-1955】<br />_结构特点：_\n   - 硬件：电子管、接线面板（按钮、开关、接线柱）\n   - 程序：二进制程序，打孔：纸带和卡片（记录0101二进制代码表示程序）\n\n\n_使用特点：_\n\n   - 程序准备/启动/结束：手工处理，繁琐耗时\n\n\n_缺点：_\n\n   - 效率低：CUP有效运行时间极低\n   - 用户独占\n   - 缺少交互\n- **晶体管时代**【1955-1965】\n   - 1995年，IBM推出第一台晶体管计算机：典型机型7094\n- **集成电路时代**【1965-1980】\n- **大规模集成电路时代**【1980-至今】\n\n\n<br />**操作系统**发展的四个典型阶段：<br />\n\n- **手工操作（无操作系统）** 50年代早期\n   - 电子管时代\n- **单道批处理系统**  50年代\n   - 晶体管时代\n\n\n_工作流程：_\n\n   - 管理员事先将多个作业输入到磁盘形成作业队列\n   - 操作系统依次自动处理队列中的每个作业（装入——运行——撤出…）\n   - 程序的装入和撤出：自动完成，效率高\n   - 运行完毕，通知用户取结果\n\n\n_工作特点：_\n\n   - 批量：作业队列\n   - 自动：识别作业，装入和撤出\n   - 单道：依次、串行\n   - ![image-20200223214927714.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468664044-76500346-06f8-4645-936e-274c1769c767.png#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&name=image-20200223214927714.png&originHeight=419&originWidth=651&size=76217&status=done&style=none&width=400)\n   - 结论：外设与CPU交替空闲和忙碌，CPU和外设利用率低\n- **多道批处理系统**  60年代初\n   - **定义**：在**内存**中存放多道程序，当某道程序因为某种原因（例如执行I/O操作时）不能继续运行而放弃CPU时，操作系统遍调度另一程序投入运行。这样可以使CPU尽量忙碌，提高系统效率。\n   - 提高系统CPU利用率。\n   - 提高系统吞吐量。\n   - ![image-20200223215547931.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468688809-18660055-935a-4431-b471-56bb8149ab2f.png#align=left&display=inline&height=247&margin=%5Bobject%20Object%5D&name=image-20200223215547931.png&originHeight=454&originWidth=779&size=96394&status=done&style=none&width=424)\n   - A, B两道程序相互穿插运行，使CPU和外设都尽量忙碌。\n   - **特点：**多道（内存同时存放多道程序）、并行（宏观上）、串行（微观上）\n   - **缺点：**作业处理时间长、交互能力差、运行过程不确定。\n- **分时系统**  60年代中\n\n\n<br />**讨论**：在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？<br />\n\n- 在多道批处理中，多道程序相互穿插运行，在宏观上是并行，在微观上是串行。<br />由于是串行运行，随着程序数量的增加，系统运算资源会趋于饱和，在饱和之后额外增加的程序将被迫处于等待状态。<br />同时，不断增多的程序也在同时增加了系统用于调度、分配、管理的开销，真正用于用户程序的处理并没有增加多少。<br />所有，在多道批处理中尝试不断增加程序的数量，系统的效率并不会持续增加。\n\n\n\n<a name=\"d0cd5c2e\"></a>\n### 1.4 分时技术与分时操作系统\n\n<br />**60年代硬件的两个重大发展**<br />\n\n- **中断技术**：CPU收到外部信号（**中断信号**）后，停止当前工作，转去处理该**外部事件**，处理完毕后回到原来工作的中断处（**断点**）继续原来的工作。\n- **通道技术**：专门处理**外设**与**内存**之间的**数据传输**的**处理机**。\n\n\n<br />**分时操作系统的背景**<br />\n\n- 事务性任务的涌现（交互性高、响应快速）\n- 要求支持多任务/多用户\n- 多终端计算机\n   - 高性能主机+多个终端（主机：运算，CPU+内存；终端：输入和显示）\n   - 主机采用**分时技术**轮流为每个终端服务，每个终端都感觉到“**独占**”主机\n   - ![image-20200223220956896.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468713271-c5539f5f-d6a9-4623-a312-e6fe248a89d1.png#align=left&display=inline&height=232&margin=%5Bobject%20Object%5D&name=image-20200223220956896.png&originHeight=368&originWidth=419&size=57733&status=done&style=none&width=264)\n\n\n<br />**分时技术**<br />\n<br />**概念：**①主机以**很短**的“**时间片**”为单位，把CPU轮流分配给每个终端使用，直到全部作业被运行完。②由于时间片很短，在终端数量不多的情况下，每个终端都能很快重新获得CPU使得每个终端都能得到及时响应。③等待周期：时间片*终端数量<br />\n<br />**分时系统的特点：**①**多路**调制性（多用户联机使用同一台计算机）②**独占**性（用户感觉独占计算机）③**交互**性（及时响应用户的请求）<br />\n<br />**Unix**<br />\n\n- 第一个实用化的分时操作系统（第一个真正体现操作系统领域各种先进概念和技术的操作系统）\n- 革新和创新（①实现了操作系统的可移植性 ②实现了硬件无关性 ③引进了“特殊文件”的概念（把外设看作文件，实现对外设统一管理））\n- ![image-20200223222226963.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468729093-09da068d-37b0-4b15-9c0a-ce75129c70b4.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image-20200223222226963.png&originHeight=348&originWidth=404&size=50877&status=done&style=none&width=263)\n\n\n<br />**讨论**：分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？<br />\n\n- 时间片设置大了，若是程序较多，等待周期会变长，与用户的交换性变差<br />设置小了，每个程序的运行时间都变少了，程序之间频繁切换，浪费了CPU资源，系统的执行效率下降，<br />总而言之，时间片的设置要根据实际情况（运行的程序数量，程序的复杂程度）来进行合适的调整。<br />要考虑CPU为用户应用程序工作的有效时间！\n\n\n\n<a name=\"4354c8b8\"></a>\n### 1.5 典型操作系统类型\n\n<br />**操作系统的进一步发展（分时操作系统的衍化）**<br />\n\n- **微机操作系统**\n   - 背景：随着大规模集成电路发展，进入个人计算机（PC机）时代。1973年：CP/M操作系统（良好的层次：_BIOS把操作系统和硬件分隔；易学易用_）\n   - 苹果Mac OS和Macintosh(1976年)：Mac OS是运行Macintosh系列电脑上的操作系统，是首个配有图形界面和鼠标的操作系统。\n   - 微软的MS DOS（80年代）：磁盘操作系统、单用户任务、MS DOS 预装在IBM PC上。\n   - 微软Windows操作系统：1985年11月，Windows1.0正式上市；1992年4月，发表Windows 3.1；1993年5月，发表Windows NT；Windows 95，CE, 98, 2K, XP, Win 7,WIN10···\n- **多处理机操作系统**\n- **网络操作系统**\n   - 普通操作系统+网络通信+网络服务\n   - UNIX/LINUX/WINDOW\n   - 功能：透明存取、存取控制\n- **实时操作系统**\n   - **背景**：实时事务：军事，工业控制，智能仪器等；要求：某些任务要**优先紧急**处理\n   - **特点**：强调作业完成的时限\n   - **硬实时系统**：时限要求严格（火炮控制系统、航空航天、制导系统、工业控制、汽车电子系统……）\n   - **软实时系统**：时限要求不是太严格，尽量快（网络视频、互动网游、广播、通讯……）\n- **嵌入式操作系统**\n   - 嵌入式操作系统 ≈ 实时操作系统\n   - **嵌入式系统**： 软硬件可以裁剪，软硬件一体化的系统。不是所有的嵌入式系统里面都有嵌入式操作系统。\n   - **典型嵌入式操作系统**：Andriod、Linux、ucOS、UCLinux、vxWorks、WinCE\n\n\n<br />适合学习的小型开源操作系统：Minix OS<br />\n<br />适合学习的大型开源操作系统：Linux<br />\n\n<a name=\"e7881333\"></a>\n## 第二章 操作系统逻辑结构\n\n\n<a name=\"09ce9472\"></a>\n### 2.1 操作系统逻辑结构\n\n\n> 逻辑结构：OS的设计和实现思路\n\n\n<br />逻辑结构的种类：**整体式结构**、**层次式结构**、**微内核结构**（客户/服务器结构，Client/Server）<br />\n\n<a name=\"064c48ea\"></a>\n#### 整体式结构\n\n<br />以**模块**为基本单位构建（**Linux**）<br />![image-20200225163110191.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468748552-644ce9da-d5c4-4760-b4f8-e721f068d167.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&name=image-20200225163110191.png&originHeight=412&originWidth=436&size=100281&status=done&style=none&width=264)<br />\n<br />**特点**：模块设计、编码和调试独立；模块调用自由、模块通信多以**全局变量**形式完成<br />\n<br />**缺点**：信息传递随意，维护和更新困难<br />\n\n<a name=\"ab1e90aa\"></a>\n#### 层次结构**\n![image-20200225163324107.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468764694-415424bb-6cf1-467a-885a-636571a33798.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image-20200225163324107.png&originHeight=473&originWidth=620&size=122502&status=done&style=none&width=311)<br />**分层结构的操作系统**<br />![image-20200225163430213.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468790266-88a7f6e3-0bb1-4dda-b35d-9a1b27b43c1c.png#align=left&display=inline&height=180&margin=%5Bobject%20Object%5D&name=image-20200225163430213.png&originHeight=201&originWidth=401&size=34929&status=done&style=none&width=360)<br />\n\n- 所有功能模块按照**调用次序**排成若干层，相邻层间只有**单向**依赖或**单向**调用\n- 分层原则\n   - 硬件相关---最底层\n   - 外部特性 --- 最外层\n   - 中间层 --- 调用次序或消息传递顺序\n   - 共性的服务 --- 较低层\n   - 活跃功能 --- 较低层\n\n\n<br />**优点**：<br />\n\n- 结构清晰，避免循环调用；整体问题局部化，系统的正确性容易保证；有利于操作系统的维护、扩充、移植。\n\n\n\n<a name=\"3a948474\"></a>\n#### 微内核结构\n\n\n> 操作系统 = 微内核 + 核外服务器\n> Minix OS\n\n\n<br />**微内核**：足够小，提供OS最基本的核心功能和服务<br />\n\n- 实现与硬件紧密相关的处理\n- 实现一些较基本的功能\n- 负责客户和服务器间的通信\n\n\n<br />**核外服务器**：完成OS的绝大部分服务功能，等待_应用程序_提出要求。<br />\n\n- 由**若干**服务器或进程共同构成\n   - 例如：进程/线程服务器，虚存服务器，设备管理服务器等，以进程形式运行在用户态。\n\n\n<br />效率可能比不过单一内核结构。<br />\n<br />**讨论**：操作系统的微内核结构的优点，对我们设计应用程序有什么启示？<br />\n\n- 微内核结构的操作系统是微内核+核外服务器的结构，微内核只负责提供OS最基本的核心服务，较为大部分的工作由核外服务器搞定。优点：可以方便扩充操作系统的功能，即添加一个应用进程就可以增加一个功能。所以启示：大型应用程序应保持简洁，采用一种将核心功能和边界应用分离的策略，微内核打造基础功能，其他应用程序添加到核外服务器进行添加多个应用功能。\n\n\n<br />**讨论2**： Tanenbaum对话Linus，认为Linux采用的体系结构过时了，为什么Linux还得到了广泛应用呢？<br />\n\n- Ack：开源、遵循了UNIX设计思想；采用单一内核体系结构具有高效性，但不易扩展，维护困难；为此，Linux利用模块机制弥补了扩展性的不足，既保证的系统高效性，又具了有灵活的扩展性。\n- 在服务器、集群、路由器都有广泛部署应用；\n\n\n\n<a name=\"f6370aba\"></a>\n### 2.2 CPU的态\n\n\n> 支持操作系统的**最基本**硬件结构：CPU、内存、中断、时钟\n\n\n\n<a name=\"CPU\"></a>\n#### CPU\n\n<br />**CPU态（Mode）**：（CPU的工作状态，对_资源_和**_指令_**使用权限的描述）<br />\n\n> CPU: 进行运算，对指令进行解码和执行。\n\n\n<br />比如CPU中的一些特权指令：<br />\n\n```shell\nLGDT/LIDT: 装载特殊寄存器\nCLTS:清楚任务开关标志\nSTI/CTI:允许和禁止中断\nHALT:停止CPU的工作\nIN/OUT:执行I/O操作\n从核态转回用户态\n……\n```\n\n<br />只有CPU工作在某一种权限很高的态上面，才能使用这些指令。<br />\n<br />**态的作用**：由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。<br />\n<br />**态的分类**：<br />\n\n- **核态**（Kernel mode）：能够访问**所有**资源和执行所有指令；管理程序/OS内核。（权限最高）\n- **用户态**（User mode, 目态）：仅能访问**部分**资源，其它资源受限；用户程序\n- **管态**：介于核态和用户态之间\n\n\n<br />**用户态和核态之间的转换**：<br />\n\n- **用户态向核态转换**：用户请求OS提供服务；发生中断；用户进程产生错误（内部中断）；用户态企图执行特权指令\n- **核态向用户态转换**的情形：一般是执行中断返回：IRET\n\n\n<br />**硬件和OS对CPU的观察**：<br />\n\n- 硬件按“**态**”来区分CPU的状态；\n- OS按“**进程**”来区分CPU的状态\n\n\n<br />不同类型CPU上态的定义不同。。<br />![image-20200227164026505.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468811609-6f037704-fda2-41d0-9c89-4dea0bc51fb2.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image-20200227164026505.png&originHeight=331&originWidth=550&size=114012&status=done&style=none&width=378)<br />\n\n<a name=\"cd80f6b1\"></a>\n#### 存储器\n\n<br />**存储程序和数据的部件**<br />\n\n- **分类**：\n   - 按存储器（半导体存储器）读写工作方式：RAM，ROM\n   - 按存储元的材料：半导体存储器（常作主存），磁存储器（磁带，磁盘），光存储器（光盘）\n   - 按与CPU的联系：主存（直接与CPU交换信息），辅存（不能直接和CPU交换信息）\n\n\n<br />**存储体系**<br />\n\n- 理想存储体系：速度快，容量大，成本低\n- 实际存储器：寄存器，高速缓存（CACHE），主存，辅存\n- ![image-20200225174258209.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468857900-e29c4f5b-854e-428b-b71b-9598e1501342.png#align=left&display=inline&height=187&margin=%5Bobject%20Object%5D&name=image-20200225174258209.png&originHeight=258&originWidth=506&size=68085&status=done&style=none&width=367)\n\n\n<br />**分级存储系统的工作原理**<br />\n\n- CPU读取指令或数据时的访问顺序：①访问缓存（命中，HIT）②访问内存（没有命中，MISS）③访问辅存（缺页，PAGE_FAULT)\n- ![image-20200225174427541.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468874366-d89eba6f-c56e-452e-b6b4-5445af1f24c7.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image-20200225174427541.png&originHeight=173&originWidth=590&size=56576&status=done&style=none&width=422)\n\n\n<br />**讨论**：用户态向内核态转有多种情形，本质上就是一种情形，即通过中断。<br />\n\n- 用户态向内核态转换的多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令）在具体到实现方式上，都需要主机干预，都需要机器停止正在进行的程序并转入处理新情况，在处理完毕后都需要返回原被暂停的程序继续进行。也就是说，转换的多种情形都是通过中断机制来实现的，所以说本质上是一种情形，即通过中断。\n\n\n\n<a name=\"220d552f\"></a>\n### 2.3 中断机制\n\n<br />**中断定义**：①指CPU对突发的外部事件的反应过程或机制。②CPU收到**外部信号**（中断信号）后，停止当前工作，转去处理该**外部事件**，处理完毕后回到原来工作的**中断处**（断点）继续原来的工作。<br />\n<br />**引入中断目的**：①实现并发活动②实现实时处理③故障自动处理<br />![image-20200225174951768.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468892686-3e63db6e-f267-4c62-81b0-207ff81597fa.png#align=left&display=inline&height=137&margin=%5Bobject%20Object%5D&name=image-20200225174951768.png&originHeight=241&originWidth=377&size=71092&status=done&style=none&width=215)<br />\n<br />**中断的一些概念**：<br />\n\n- **中断源和中断类型**：<br />①引起系统中断的事件称为**中断源**；<br />②中断**类型**：\n   - **强迫性中断**（程序没有预期，例：I/O、外部中断）和**自愿中断**（程序有预期，例如：执行访管指令）\n   - **外中断**（中断，由CPU外部事件引起，例如：I/O，外部事件）和**内中断**（俘获，由CPU内部事件引起，例如：访管中断、程序中断）\n   - 外中断：**不可屏蔽中断**（中断的原因很紧要，CPU必须响应）和**可屏蔽中断**（中断原因不很重要，CPU可以不响应）\n\n\n③**断点**：程序中断的地方，将要执行的下一条指令的地址（CS:IP)<br />④**现场（上下文）**：程序正确运行所依赖的信息集合（相关寄存器）<br />⑤现场的两个处理过程：\n\n   - **现场的保护**：进入中断服务程序之前，栈\n   - **现场的恢复**：退出中断服务程序之后，栈\n\n\n⑥**中断响应过程**\n\n   - （1）识别中断源\n   - （2）保护断点和现场\n   - （3）装入**中断服务程序**的入口（CS:IP) （硬件自动完成）\n   - （4）进入中断服务程序\n   - （5）恢复现场和断点\n   - （6）中断返回：IRET\n\n\n⑦**中断响应的实质**\n\n   - 交换指令执行地址（由原来主程序里面的地址变到了中断服务程序的入口地址）\n   - 交换CPU的态（主程序在用户态交换了CPU的态，中断响应过程在核态进行）\n   - 工作：现场保护和恢复；参数传递（通信）\n\n\n\n<a name=\"5bfcc87c\"></a>\n## 第三章 操作系统用户界面\n\n\n<a name=\"9a81e668\"></a>\n### 3.1 操作系统启动过程\n\n\n<a name=\"01730675\"></a>\n#### 3.1.1 BIOS和主引导记录MBR\n\n<br />**计算机的两种工作模式**:<br />\n\n- **实模式**（实地址模式，REAL MODE) 刚刚加电启动过程中\n   - 程序按照8086寻址方法访问0h--FFFFFh(1MB)空间\n      - **实模式存储的1M空间**\n         - 前面的640K【00000 -- 9FFFF】: 基本内存\n         - 中间的128K【A0000-- BFFFF】: 显卡显存\n         - 末尾的256K【C0000-- FFFFF】: **BIOS**\n            - C0000 – C7FFF： 显卡BIOS\n            - C8000 – CBFFF：IDE控制器BIOS\n            - F0000 – FFFFF：最后64K，**系统BIOS**\n   - 寻址方式：物理地址**（20位）**=段地址(16位)：偏移地址(16位)\n   - CPU单任务运行\n- **保护模式**（内存保护模式，PROTECT MODE）操作系统启动以后，接管计算机以后\n   - 寻址方式：段（32位）和偏移量（32位），寻址4GB空间\n      - **段的属性**：起始地址，存取属性，权限级别，……\n   - _段页式_寻址机制（段，页）\n   - 虚拟地址，进程，封闭空间\n   - 应用程序和操作系统的运行环境都被_保护_\n   - CPU支持多任务\n\n\n<br />**系统BIOS**<br />\n\n- Bsic I/O System(Firmware ，**固件**：以硬件方式存在的程序或软件 )：  **基本输入/输出系统**；位置：**F0000 — FFFFF**\n- 功能：\n   - 系统启动配置；（CMOS设置）\n   - 基本的设备I/O服务（采用中断的方式来呈现）； ![image-20200303164744204.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592468922592-66d0d25c-5907-4b68-98bb-978c4d3034ce.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image-20200303164744204.png&originHeight=320&originWidth=649&size=108708&status=done&style=none&width=384)<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469048081-e1c939ef-3372-4136-9de8-97ae87f249a0.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=604&size=121034&status=done&style=none&width=394)<br />比如：13号中断的02号子功能能帮助用户读扇区。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469091444-78229c31-5333-4a1c-af65-e785d365df52.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=856&size=202091&status=done&style=none&width=372)\n\n   - 系统的加电自检POST和启动\n      - 初始化基本硬件(CPU,内存，显卡……)，自检正常不提示，错误则通过喇叭提示\n      - 按下PowerOn或者Reset键执行第一条指令（执行**FFFF0**处的指令：JUMP POST；POST位于系统BIOS内部）\n      - **POST之后……**：①查找显卡BIOS，调用显卡BIOS；②依次查找其他设备执行相应设备的BIOS③显示启动画面（BIOS信息，芯片组型号，主板信息等）④从硬盘/软盘/光驱/U盘读入OS⑤OS启动后，由OS接管计算机\n      - BIOS加电自检自举过程中会去读硬盘或软盘上存放的OS，读硬盘过程中会首先读其中一个特殊扇区-- 首扇区，首扇区存放的内容---MBR（**主启动记录MBR**）\n         - 存放在硬盘/软盘的首扇区\n         - 存放和OS驱动的相关信息（Main Boot Record）\n         - 512 BYTES （512个字节）\n         - 结束：oxAA55h(最后两个字节)\n         - ![image-20200303170201868.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469132395-22fcf5bb-92bd-441e-a25f-a7b7346fbe22.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image-20200303170201868.png&originHeight=263&originWidth=385&size=67196&status=done&style=none&width=332)\n      - **BOIS和MBR程序运行过程**：①POST-->CMOS设置（硬盘启动）--> 读取MBR-->控制权交给MBR②MBR读取分区表，找到其中的活动分区，并确认其他的分区都不是活动分区。MBR读取活动分区的第一个分区（分区引导记录PBR），并把它加载到内存中去。③PBR继续控制后面的引导过程。\n\n\n\n<a name=\"88469967\"></a>\n#### 3.1.2 操作系统启动过程\n\n<br />**启动过程**<br />\n\n- 从**加电**到**用户工作环境**准备好的过程\n   - **初始引导**：把**OS核心**装入内存并使之开始工作接管计算机系统\n      - **过程**：①加电，JUMP POST②…BIOS中的**启动程序**运行③启动程序（读取0面0道第1扇区内容(MBR)，加载MBR中的**引导程序**）④引导程序【常见的引导程序：ntldr,**GRUB**,bootmgr,LILO】（根据相关参数，读取硬盘指定位置的文件到内存；加载硬盘上**OS内核**，并初始化基本参数）⑤OS内核：逐步加载**OS**剩余部分，最后完全控制计算机\n   - **核心初始化**：OS内核初始化系统的核心数据\n      - 典型工作：各种寄存器的初始化、存储系统和页表初始化、核心进程构建……\n   - **系统初始化**：为用户使用系统做准备，使系统处于**待命状态**\n      - 主要工作：初始化文件系统、初始化网络系统、初始化控制台、初始化图形界面……\n\n\n\n<a name=\"929f2702\"></a>\n### 3.3.1 操作系统用户界面\n\n<br />**用户界面的定义**：OS提供给用户控制计算机的机制，又称用户接口<br />\n<br />**用户界面的分类**：操作界面；系统调用（System Call,系统功能调用，程序界面）<br />\n<br />**操作界面**：<br />\n\n- _图形用户接口_（GUI）：窗口，图标，菜单，按钮，鼠标（消息，事件）\n- _键盘命令_（COMMAND)：在控制台环境下接收键盘输入的命令；类型：**普通命令，批处理命令，shell**\n- 普通命令\n\n![image-20200303172339785.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469172163-105a7139-200e-4317-8dcc-3e0ddb2862fc.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image-20200303172339785.png&originHeight=393&originWidth=546&size=155198&status=done&style=none&width=304)\n\n- Linux典型命令\n\n![image-20200303172418068.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469192302-1287f4e2-a119-4663-94f8-345de5e84755.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&name=image-20200303172418068.png&originHeight=302&originWidth=588&size=88875&status=done&style=none&width=373)\n\n- **批处理**：①普通命令的集合，批执行，由command解释执行②支持变量替换、条件、转移、循环、注释等简单语法③*.BAT④例子：累计1-100，输出和5050\n- ![image-20200303172605132.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469228275-2f5d091d-2721-4cec-83e1-9f991d2a3fce.png#align=left&display=inline&height=101&margin=%5Bobject%20Object%5D&name=image-20200303172605132.png&originHeight=225&originWidth=472&size=57650&status=done&style=none&width=211)\n\n格式：for  /参数  %%变量  in  (集)  do 命令<br />		/l: 表示参数是一个序列（l是字母L的小写）<br />		Set: 设置变量\n\n- **Shell**：shell是操作系统与用户交互的界面；shell表现为通过控制台执行用户命令的方式；shell本身不执行命令，仅仅是_组织和管理_命令\n\n![image-20200303172914078.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469263704-4ec60077-6ad1-4353-b521-8228faafc4f2.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image-20200303172914078.png&originHeight=188&originWidth=306&size=32676&status=done&style=none&width=265)\n\n   - shell分类与发展\n\n        ![image-20200303172950113.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469275082-543c33a0-29cb-4595-aa85-64147d8d710c.png#align=left&display=inline&height=122&margin=%5Bobject%20Object%5D&name=image-20200303172950113.png&originHeight=319&originWidth=785&size=147070&status=done&style=none&width=300)\n\n      - bash的主要功能\n         - 命令行编辑功能\n         - ![image-20200303173340524.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469305907-a8d82fda-b47e-48c5-945b-0ede3cb30b11.png#align=left&display=inline&height=126&margin=%5Bobject%20Object%5D&name=image-20200303173340524.png&originHeight=358&originWidth=753&size=202991&status=done&style=none&width=264)\n         - 命令和文件名补全功能（TAB键）\n         - 命令历史功能（使用：上下箭头，查看：$history）\n         - 命令别名功能\n         - 提供作业控制功能\n         - 管道与重定向功能：标准输入输出，重定向操作，管道操作\n         - 具有将命令序列定义为功能键的功能\n         - shell脚本编程\n\n\n\n<a name=\"bf33b235\"></a>\n### 3.4 系统调用\n\n<br />**定义**：操作系统**内核**为应用程序提供的**服务/函数**（底层进行）<br />\n<br />比如：21h(09)，printf()，exit()<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469372695-e5128424-c278-4294-b448-e236dad47670.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=344&size=47003&status=done&style=none&width=172)<br />\n<br />**特点**：一般涉及核心资源和硬件的操作；运行于**核态**；每个系统调用具有唯一的编号：ID；调用过程会产生中断：自愿中断；<br />\n<br />**系统调用的中断过程**：<br />![image-20200303174555885.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469386768-d4f3499a-7e38-4fb0-80e3-8236d31e6ef0.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image-20200303174555885.png&originHeight=302&originWidth=446&size=73408&status=done&style=none&width=281)<br />\n\n- DOS利用**INT 21h**中断实现系统调用\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469447597-1632ed09-d3cb-4e66-9915-17bb78f5e354.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=213&originWidth=502&size=54893&status=done&style=none&width=251)\n\n- Linux利用**INT 80h**中断实现系统调用\n\n        ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469480276-fca15ce0-41ee-465d-9709-abdf29ede7d8.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&name=image.png&originHeight=235&originWidth=294&size=70358&status=done&style=none&width=147)<br />**隐式系统调用**<br />![image-20200606164018081.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469501194-60310251-26b2-4027-b8f6-e21162617063.png#align=left&display=inline&height=103&margin=%5Bobject%20Object%5D&name=image-20200606164018081.png&originHeight=173&originWidth=345&size=35260&status=done&style=none&width=206)<br />![image-20200606164122301.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469503906-e60de54d-8e2c-4e60-a4d2-59a2ed810253.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image-20200606164122301.png&originHeight=371&originWidth=299&size=101060&status=done&style=none&width=200)\n\n- 特点：类似API函数；在高级语言中使用；包含有‘INT 80h’中断指令，执行相应的系统调用。\n\n\n\n<a name=\"d2af8d8e\"></a>\n## 第四章 进程管理\n\n\n<a name=\"608f1e69\"></a>\n### 4.1 进程概念、进程状态及进程控制块PCB\n![image-20200606164514649.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469551146-f1cfd948-27e9-456b-999d-d21f63665017.png#align=left&display=inline&height=277&margin=%5Bobject%20Object%5D&name=image-20200606164514649.png&originHeight=395&originWidth=577&size=176957&status=done&style=none&width=405)<br />**程序运行在并发环境中的问题**：运行过程不确定，结果不可再现（程序运行被干扰），解决方案：对运行过程施加相互制约<br />\n<br />**新的概念：进程**：描述和管理程序的“运行过程”<br />\n<br />**进程定义：**①进程是程序在某个**数据集合**上的**一次**运行**活动**。②数据集合：软/硬件环境，多个进程共存/共享的环境。<br />\n<br />**进程的特征**：<br />\n\n- 动态性：进程是程序的一次执行过程，动态产生/消亡\n- 并发性：进程同其他进程一起向前推进\n- 异步性：进程按各自速度向前推进\n- 独立性：进程是系统分配资源和调度CPU的单位\n- 结构：（逻辑结构）\n\n\n<br />**进程和程序的区别**：<br />\n\n- 动态与静态：①进程是动态的：程序的一次执行过程②程序是静态的：一组指令的有序集合\n- 暂存与长存：①进程是暂存的：在内存驻留②程序是长存的：在介质上长期保存\n- 程序和进程的对应：一个程序可能有多个进程\n- 进程可以并发，而程序则没有\n- 进程是资源竞争的基本单位\n\n\n<br />**进程的层次结构（进程树）**<br />\n\n- 系统中除根程序外，每个程序都有且只有一个父进程\n- 每个子进程均由它的父进程创建\n- 一个父进程可以有多个子进程\n\n\n<br />**进程的类型**：<br />\n\n- 按**使用资源**的权限\n   - 系统进程：指系统内核相关的进程\n   - 用户进程：运行于用户态的进程\n- 按对**CPU的依赖性**\n   - 偏CPU进程：计算型进程\n   - 偏I/O进程：侧重于I/O的进程\n- 其他标准：……\n\n\n<br />**进程的状态**<br />\n\n> 对于每一个进程来说，它们都是断断续续地在CPU上运行\n\n\n\n- 运行状态（Running）：进程已经占有CPU，在CPU上运行。正在使用CPU。\n- 就绪状态（Ready）：具有运行条件但由于无CPU，暂时不能运行。指获取了除CPU之外的所有资源的进程状态。\n- 阻塞状态（Block，等待（Wait）状态)：因为等待某项服务完成或信号不能运行的状态，如等待：系统调用，I/O服务，合作进程信号……不可运行，且只能由其它外部事件发生而唤醒的状态。\n\n\n<br />**进程状态的变迁**：进程的状态可以依据一定的条件相互转化。<br />![image-20200312163205425.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469593711-ac6dd22a-6d9b-4522-9b85-4dd2eaa0a9a0.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image-20200312163205425.png&originHeight=226&originWidth=645&size=129848&status=done&style=none&width=427)<br />\n<br />**具有新建（new）和终止（terminate）状态的进程状态**<br />![image-20200312163259689.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469597601-6f14f551-b890-4145-a8e2-4110bdd9eb40.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&name=image-20200312163259689.png&originHeight=327&originWidth=820&size=166299&status=done&style=none&width=372)<br />\n<br />**Linux进程的状态**<br />\n\n- **可运行态**\n   - 就绪：TASK_RUNNING，在就绪队列中等待调度。\n   - 运行：正在运行\n- **阻塞（等待）态**\n   - 浅度阻塞：TASKK_INTERRUPTIBLE(可中断)，能被其他进程的信号或时钟唤醒。\n   - 深度阻塞：TASK_UNINTERRUPTIBLE(不可中断)，不能被其他进程的信号或时钟唤醒。【请求文件，IO，系统等服务】\n- **僵死态**：TASK_ZOMBIE，进程终止执行，释放大部分资源\n- **挂起态**：TASK_STOPPED，进程被挂起【调试一个进程】\n\n![image-20200312163657211.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469615250-7863cb26-edd2-4784-8e9e-2d3b701403d0.png#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&name=image-20200312163657211.png&originHeight=413&originWidth=835&size=216973&status=done&style=none&width=408)<br />\n<br />**进程控制块（Process Control Block, PCB）**<br />\n\n> 为了方便OS管理进程，OS定义了一个数据结构—PCB。\n> OS在建立一个进程的时候，就会自动建立起这样一个数据结构，所以OS感知进程就是通过PCB来感知的，PCB是进程的标识，OS管理进程就是通过PCB来完成\n\n\n\n- 描述进程状态、资源和与相关进程关系的数据数据结构\n   - 描述信息：进程名（标识号），用户名（标识号），家族链\n   - 控制信息：状态，优先级，内存始址，计时，通信信息\n   - 资源管理信息：内存、设备等信息\n   - CPU现场保护机构：寄存器\n- PCB是进程的标志\n- 创建进程时创建PCB;进程撤销后PCB同时撤销\n\n\n<br />**进程 = 程序 + PCB**<br />![image-20200312165222479.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469629999-e1267556-0d85-4eaf-83fd-c034e82ed71b.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&name=image-20200312165222479.png&originHeight=351&originWidth=511&size=84804&status=done&style=none&width=254)<br />\n<br />**PCB的数据结构**<br />\n\n- PCB中的基本成员\n\n![image-20200606170320737.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469681265-d3c708d6-e592-4498-8d5b-511c4d8f4279.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&name=image-20200606170320737.png&originHeight=264&originWidth=416&size=116519&status=done&style=none&width=268)<br />**Linux的进程控制块PCB：task_struck**<br />![image-20200606170350692.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469668331-a327fc40-d0cf-41c1-b68a-b2a5ccbcbfa5.png#align=left&display=inline&height=166&margin=%5Bobject%20Object%5D&name=image-20200606170350692.png&originHeight=338&originWidth=498&size=98010&status=done&style=none&width=245)<br />\n<br />**和进程相关的成员变量**<br />\n\n- LINUX进程的标识\n   - PID\n   - PPID：父进程ID\n   - PGID：进程组ID\n- LINUX进程的用户标识\n   - UID：用户ID\n   - GID： 用户组ID\n\n\n<br />**进程的切换**<br />\n\n- 进程的上下文：Context，进程运行环境，CPU环境。【CPU各个寄存器的值组成了进程的上下文，当然还包括一些其他的。】\n- 进程切换过程\n   - 换入进程的上下文进入CPU（从栈上来）\n   - 换出进程的上下文离开CPU（到栈上去）\n\n\n\n<a name=\"f29c1c56\"></a>\n### 4.2 进程控制\n\n<br />**进程控制的概念**：<br />\n\n- 在进程生存全期间，对其全部行为的控制\n- 四个典型的控制行为：创建进程、撤销进程、阻塞进程、唤醒进程\n\n\n<br />**进程创建**<br />\n\n- 功能：创建一个具有指定标识（ID）的进程\n- 参数：进程标识、优先级、进程起始地址、CPU初始状态、资源清单等。\n- 创建进程的过程\n   - 创建一个空白PCB\n   - 获得并赋予进程标识符ID【唯一】\n   - 为进程分配空间\n   - 初始化PCB：默认值\n   - 插入相应的进程队列：新进程插入就绪队列\n- 进程创建的伪代码（原语）\n\n    ![image-20200312170714616.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469716885-21787b1f-b4ca-4059-8399-50e025e4b7ec.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image-20200312170714616.png&originHeight=380&originWidth=598&size=256218&status=done&style=none&width=370)<br />\n<br />**进程撤销**<br />\n\n- 功能：①撤销一个指定的进程②收回进程所占有的资源，撤销该进程的PCB\n- 进程撤销的时机/事件：正常结束、异常结束、外界干预\n- 参数：被撤销的进程名（ID）\n- 进程撤销的实现\n   - 在PCB队列中检索出该PCB\n   - 获取该进程的状态\n   - 若该进程处于运行态，立即终止该进程：【递归】检查是否有子进程，先“撤销”子进程\n   - 释放进程占有的资源\n   - 将进程从PCB队列中移除\n\n\n<br />**进程阻塞**<br />\n\n- 功能：停止进程的执行，变为阻塞\n- 阻塞的时机/事件\n   - 请求系统服务：（由于某种原因，OS不能立即满足进程的要求）\n   - 启动某种操作：（进程启动某操作，阻塞等待该操作完成）\n   - 新数据尚未到达：（A进程要获得B进程的中间结果，A进程等待）\n   - 无新工作可作：（进程完成任务后，自我阻塞，等待新任务到达）\n- 参数：阻塞原因、**不同原因构建有不同的阻塞队列**\n- 进程阻塞的实现\n   - 停止运行\n   - 将PCB ”运行态“该”阻塞态“\n   - 插入相应原因的阻塞队列\n   - 转调度程序\n\n\n<br />**进程唤醒**<br />\n\n- 功能：唤醒处于阻塞队列当中的某个进程\n- 引起唤醒的时机/事件\n   - 系统服务由不满足到满足\n   - I/O完成\n   - 新数据到达\n   - 进程提出新请求（服务）\n- 参数：被唤醒进程的标识\n\n\n<br />**进程控制原语**<br />\n\n- **原语**（a single, indivisible atomic action 系统态下执行的某些具有特定功能的程序段）：①由若干指令构成的具有特定功能的**函数**②具有**原子性**，其操作不可分割【这个函数必须一气呵成，中途不能中断，要么执行成功，要么执行失败】\n   - 机器指令级：不允许中断\n   - 功能级：不允许并发执行\n- 进程创建的原语：\n\n![image-20200312172439547.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469788740-f62699d3-8bd0-41ef-af3d-0b583cf7daf6.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&name=image-20200312172439547.png&originHeight=367&originWidth=599&size=244140&status=done&style=none&width=313)\n\n- 进程控制原语：\n   - 创建原语\n   - 撤销原语\n   - 阻塞原语\n   - 唤醒原语\n\n\n\n<a name=\"ebd2fc76\"></a>\n### 4.3 线程\n\n<br />**线程（Thread）的概念**<br />\n\n1. 线程是可由CPU直接运行的实体；线程是CPU调度单位，线程是程序内部一个执行路径。\n2. 一个进程可以创建多个线程；\n3. 多个线程共享CPU可以实现**并发**运行。\n\n\n<br />**CreateThread()**<br />![image-20200606172421002.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469811940-d532ffa9-0557-4592-9ab4-70ba02a72c72.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image-20200606172421002.png&originHeight=317&originWidth=651&size=150972&status=done&style=none&width=364)<br />\n<br />**单线程和多线程程序**<br />\n\n- 单线程程序：整个进程只有一个线程。Windows程序缺省只有一个线程（主线程，main线程）；\n- 多线程程序：整个进程至少有2个进程。主线程和至少一个用户线程。\n\n\n<br />**线程技术典型适用场景**<br />\n\n- 程序的多个功能需要并发运行【并发画圆画方、在线看电影（视频解码，音频解码，网络接收）】：每个功能都创建为一个线程，从而实现多功能并发。\n- 提高窗口程序的交互性\n- 需要改善程序结构的地方\n- 多核CPU上的应用，充分发挥多核作用\n\n\n<br />**线程创建的补充**<br />**![image-20200606173653714.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469885439-82d25a9f-48ac-453c-a2e0-c234d1bded5f.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image-20200606173653714.png&originHeight=197&originWidth=679&size=150093&status=done&style=none&width=309)**<br />![image-20200606173731199.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469860545-fc5c8efc-9013-423b-b21e-209dfcdee59d.png#align=left&display=inline&height=164&margin=%5Bobject%20Object%5D&name=image-20200606173731199.png&originHeight=324&originWidth=611&size=153717&status=done&style=none&width=309)<br />\n<br />**使用线程的麻烦**<br />\n\n- 程序难以调试\n- 并发过程难以控制\n- 线程安全问题\n\n\n\n<a name=\"695a16be\"></a>\n### 4.4 临界区和锁\n\n<br />**并发执行的进程间相互制约关系：**<br />\n\n- **间接制约：**诸进程对共享资源的使用通过系统来协调，使得进程间执行速度相互影响（进程间互斥）\n- **直接制约：**诸进程自行使用共享资源或由进程合作引起，某一进程直接通过某机制发消息给其他进程，从而直接影响其他进程的执行。（进程间同步）\n\n\n<br />**临界资源[Critical Resource]**：一次只允许一个进程独占访问（使用）的资源。例如共享变量。<br />\n<br />**临界区[Critical Section]**：进程中访问临界资源的程序段。<br />\n<br />**临界区和临界资源的访问特点**：①具有排他性②并发进程不能同时进入临界区。<br />\n<br />**设计临界区访问机制的四个原则**<br />\n\n- 忙则等待：当临界区忙时，其他进程必须在临界区外等待。\n- 空闲让进：当无进程处于临界区时，任何有权进程可进入临界区。\n- 有限等待：进程进入临界区的请求应在有限时间内得到满足。临界区设置过大可能导致另一个进程等待时间过长，过小可能达不到临界区的目的。\n- 让权等待：等待进程放弃CPU。（让其它进程有机会得到CPU）\n\n\n<br />**锁机制**<br />\n<br />**基本原理**<br />\n\n- 设置一个“**标志**”S：\n   - 表明临界资源“可用”还是“不可用”  ? 1:0\n- 上锁操作：进入临界区之前检查标志是否“可用”？\n   - 若为“不可用”状态：进程在临界区之外等待\n   - 若为“可用”状态：\n      - 访问临界资源……\n      - 且将标志修改为“不可用”\n- 开锁操作：退开临界区时将标志修改为“可用”状态\n\n\n<br />**上锁操作**<br />\n\n- 步骤：\n   - 第一步：检测锁S的状态（0或1？）\n   - 第二步：如果S=0，则返回第一步\n   - 第三步：如果S=1，则置其为0\n- 上锁原语```c\nLOCK(s) //上锁操作\n{\n    test:if(S == 0)\n        goto test;  //测试锁标志\n    else\n        S = 0;  //上锁\n}\n```\n\n\n\n<br />**开锁操作**<br />\n\n- 步骤：<br />第一步：把锁S的状态置1\n- 开锁原语```c\nUnLock(S)//开锁操作\n{\n    S = 1; //开锁\n}\n```\n\n\n\n<br />**用锁机制访问临界区**<br />\n\n- 步骤：\n   1. 初始化锁的状态S = 1(可用)\n   2. 进入临界区之前执行上锁Lock(s)操作；\n   3. 离开临界区之后执行开锁unLock(s)操作。\n\n\n<br />**问题**：<br />\n\n- CPU循环测试\n- 不公平现象（优先级高反复请求资源）\n\n\n\n<a name=\"3caeef1e\"></a>\n### 4.5 同步和P-V操作\n\n<br />**进程的互斥关系**<br />\n\n- 多个进程由于共享了**独占性资源**，必须协调各进程对资源的存取顺序：确保没有任何两个或以上的进程同时进行**存取操作**。\n- **互斥和资源共享有关**\n- 资源：**临界资源**\n- 存取操作区域：**临界区**\n\n\n<br />**进程的同步关系**<br />\n\n- 若干**合作进程**为了完成一个共同任务，需要相互协调运行步伐：**一个进程**开始某个操作**之前**必须要求**另一个进程**已经完成某个操作，否则前面的进程只能**等待**。\n- **例子**：司机和售票员之间的操作属于同步关系。司机：起步、行驶、停车；售票员：关门、售票、开门。_同步关系_：司机起步前售票员先关门，否则等待；售票员开门前司机先停车，否则等待。\n- **另一种解释**\n   - 合作进程中某些操作之间需要满足某种**先后关系**或某个操作能否进行需要满足某个**前提条件**，否则只能**等待**。\n   - **互斥**关系属于**特殊的同步**关系。\n\n\n<br />**P-V操作的概念**<br />\n\n1. **信号灯的概念**：①信号灯是一种卓有成效的进程同步机制②1965年荷兰学家迪科斯彻提出。\n2. **信号灯用于进程同步的基本思想：**进程在运行过程受信号灯状态控制，并能改变信号灯状态\n   - **进程受控制**：信号灯的**状态**可以**阻塞**或**唤醒**进程\n   - **改变信号灯**：灯信号灯的**状态**可以被进程改变\n3. **信号灯机制：**\n   - 信号灯变量定义为一个二元矢量（S,q）\n   - S: 整数,初值非负（S又称**信号量**）\n   - q：PCB**队列**，初值为空集```c\nstruct SEMAPHORE{\n    int S; //整数，初值为负\n    pointer_PCB q; //队列：进程PCB指针，初值空集\n}\n```\n\n4. **信号灯的操作：**P操作（函数或过程，**P(S,q)**），V操作（函数或过程，**V(S,q)**）；P,V是荷兰语：Passeren通过，Vrijgeven释放。\n   - **P操作的原理**（P(S,q), P(S)）\n      - S值**减1**；\n      - 若差大于或等于零，该进程继续；\n      - 若差小于零，则该进程**阻塞**并加入到队列q中，并转调度函数```c\nP(S,q){\n    S = S-1;\n    if(S<0){\n        Insert(Caller,q);\n        Block(Caller);\n        转调度函数();\n    }\n}\n```\n<br />提示：P操作可能使进程在调用处**阻塞**；**S初值很重要**。\n   - **V操作的原理**（V(S,q),V(S）)\n      - S值**加1**\n      - 若和大于零，则进程继续；\n      - 若和小于或等于零，该进程继续同时从q中**唤醒**一个进程```c\nV(S,q){\n    S = S+1;\n    if(S<=0){\n        Remove(q,pid);//pid:进程ID\n        Wakeup(pid);\n    }\n}\n```\n<br />提示：V操作可能会**唤醒**阻塞的进程。\n\n\n<br />**P-V操作解决互斥问题**<br />\n\n- **实质是实现对临界区的互斥访问**：允许最多一个进程处于临界区\n- **应用过程**：①进入临界区之前先执行P操作(可能阻塞当前进程)②离开临界区之后再执行V操作(可能唤醒某个进程)③S的初值设置要合理<br />\n\n![image-20200324174431291.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592469934932-1aef6809-5034-4af3-b0a9-2a342ae0abca.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&name=image-20200324174431291.png&originHeight=331&originWidth=740&size=98881&status=done&style=none&width=389)<br />**P-V操作解决同步问题**<br />\n\n- **同步机制实质**：①运行条件不满足时，能让进程**暂停**；②运行条件满足时，能让进程立即**继续**\n- **P-V操作应用于进程同步的基本思路：**\n   - 暂停当前进程：在关键操作**之前**执行 **P** 操作（必要时可暂停）\n   - 继续进程：在关键操作**之后**执行**V** 操作（必要时唤醒合作进程）\n   - 定义**有意义**的信号量**S**，并设置合适的**初值**（信号量S能明确地表示“**运行条件**”）\n- **例子**：司机（起步、行驶、停车），售票员（关门、售票、开门），同步要求：①只有售票员关门后，司机才能起步②只有司机停车后，售票员才能开门\n\n![image-20200606212700769.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592470008150-59ce1e70-b7ca-49f0-8cd4-4877f59d8cc1.png#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&name=image-20200606212700769.png&originHeight=339&originWidth=565&size=140716&status=done&style=none&width=309)<br />**经典同步问题**<br />\n\n- **生产者和消费者问题**（同步和互斥混合）\n\n`![image-20200606213226158.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592470027924-99509bb3-1e05-40fa-b6b8-f7db42430a01.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&name=image-20200606213226158.png&originHeight=406&originWidth=806&size=152252&status=done&style=none&width=410)![image-20200606213829517.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592470054484-28e6d65f-59c4-4fd7-ab30-a7ca78549fc0.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&name=image-20200606213829517.png&originHeight=322&originWidth=484&size=130686&status=done&style=none&width=334)\n\n- **读者和编者问题**（互斥问题）\n\n![image-20200606213859080.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592470078039-76fc87c0-51ef-4bde-9437-77485e531b10.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&name=image-20200606213859080.png&originHeight=257&originWidth=262&size=59941&status=done&style=none&width=162)<br />![image-20200326170859669.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592470107309-a4442c83-2b90-4b02-8c10-5e8657e87173.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image-20200326170859669.png&originHeight=410&originWidth=701&size=229992&status=done&style=none&width=370)\n\n- **信号灯机制P-V操作解决同步问题**\n   - 关键操作之前P操作\n   - 关键操作自后V操作\n   - 区分关键操作或运行条件或影响\n\n\n\n<a name=\"0a4e9c3c\"></a>\n### 4.6 Linux父子进程同步\n\n<br />**进程的阻塞wait()**：进程调用**wait(int status)**阻塞自己<br />\n\n- 堵塞到有子进程结束？\n   - 没有：进程一直阻塞。\n   - 有（**僵尸进程**）：Wait收集该子进程信息并彻底销毁它后返回。\n- status 保存进程退出时的状态\n   - 若忽略退出信息：pid = wait(**NULL**);\n\n\n<br />**进程的终结**<br />\n\n- 调用 void **exit**(int status)终结进程\n- **进程终结时要释放资源并报告父进程**\n   - 利用status传递进程结束时的状态\n   - 变为**僵尸状态**，保留部分PCB信息供**wait**收集\n      - 正常结束还是异常结束\n      - 占用总系统CPU时间\n      - 缺页中断次数\n   - 调用schedule()函数，选择新进程运行\n\n\n<br />**进程的休眠sleep()**<br />\n\n- sleep(int nSecond)\n   - 进程暂停执行**nSecond**秒\n   - 系统暂停调度该进程\n   - 相当于windows的suspend(),挂起若干秒\n\n\n<br />**例子：**<br />![image-20200326173102401.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592470138643-88bc234d-2b10-4468-8783-909088cb620f.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=image-20200326173102401.png&originHeight=488&originWidth=623&size=187718&status=done&style=none&width=346)<br />\n<br />**父子进程共享普通变量**：对于普通变量，父子进程各自操作变量副本，互不影响。<br />\n<br />**父子进程共享文件资源**：对于文件，父子进程共享同一文件和读写指针。<br />\n\n<a name=\"75f5b079\"></a>\n### 4.7 进程通信\n\n\n<a name=\"d184550c\"></a>\n#### 匿名管道通信\n\n<br />**管道通信机制**<br />\n\n1. **管道定义pipe**：管道是进程间的一种通信机制。一个进程(A)可以通过管道把数据传输给另一个进程(B)。前者(A)向管道**输入**数据，后者(B)从管道**读取**数据。\n\n![image-20200326175758207.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575121810-0d5b92fe-eef2-49bd-8dd7-086873e8ed1c.png#align=left&display=inline&height=70&margin=%5Bobject%20Object%5D&name=image-20200326175758207.png&originHeight=104&originWidth=492&size=45837&status=done&style=none&width=331)\n\n2. **管道工作原理**\n   1. 管道像文件一样，可读和可写，有读/写2个句柄。`CreatePipe(Handle W, Handle R)`\n   2. 通过写写句柄(W)向管道中**写数据**：WriteFile(W,Buffer)或通过输出重定向向写句柄(W)写入。\n   3. 通过读读句柄(R)从管道中**读数据**：ReadFile(R,Buffer)或通过输入重定向从读句柄(R)读出。\n4. **注意事项：仅能用于父子或兄弟进程间通信**\n   1. 由父进程(A)**创建管道**：CreatePipe(W,R)。\n   2. 由父进程(A)**创建子进程**(B)：CreateProcess()\n   3. 父进程写或读管道，子进程输入或输出重定向到管道。<br />![image-20200326175837455.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575138016-bac069f2-6d3b-4600-be44-1e35cdea4ee2.png#align=left&display=inline&height=131&margin=%5Bobject%20Object%5D&name=image-20200326175837455.png&originHeight=255&originWidth=701&size=146927&status=done&style=none&width=361)<br />	![image-20200326175917059.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575159669-33f8e0b9-3647-449c-8ef7-c88b7f1bf60c.png#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&name=image-20200326175917059.png&originHeight=257&originWidth=735&size=151758&status=done&style=none&width=378)![image-20200326175934345.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575189098-3895485e-0023-4803-abd0-3a25c6ea23ef.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&name=image-20200326175934345.png&originHeight=294&originWidth=665&size=135211&status=done&style=none&width=394)\n5. **应用管道的注意事项：双向通信必须建立2个管道；要支持程序间双向通信，父进程(A)必须创建2个管道**<br />\n\n\n\n<a name=\"f70fccd8\"></a>\n#### Linux信号通信\n\n<br />**信号的概念**<br />\n\n- 信号是Linux进程间一种重要的通信机制。\n- 信号是向进程发送的一个**通知**，通知某个事件已发生。\n- 收到信号的进程可以立即**执行**指定的操作。\n- 信号的**发出**可以是进程，也可以是系统（含硬件）。\n\n\n<br />**信号的产生**<br />\n\n- 来源1：键盘输入特殊组合键产生信号，例：“Ctrl+C”\n- 来源2：执行终端命令产生信号，例：kill系列命令\n- 来源3：程序中调用函数产生信号，例：kill()、abort()\n- 来源4：硬件异常或内核产生相应信号。例：内存访问错\n\n\n<br />**信号的定义**<br />\n<br />Linux定义了64种信号，信号用整数1~64表示。\n\n| 信号编号 | 信号名称 | 说明 |\n| --- | --- | --- |\n| 2 | SIGINT | 进程结束（按键Ctrl+C能产生） |\n| 6 | SIGABRT | 进程结束（调用abort函数产生） |\n| 9 | SIGKILL | 进程强制结束（用户不能捕获该信号） |\n| 11 | SIGUSR1 | 用户**自定义**信号1 |\n| 14 | SIGALRM | 定时器时间到的信号 |\n| 19 | SIGTSTP | 进程暂停执行（用户不能捕获该信号） |\n\n\n<br />**signal()：注册信号处理函数的函数**<br />\n\n- 原型：```c\nvoid signal(\n	int SigNo, //信号编号\n    void ( *Handle) int //自定义信号处理函数\n)\n```\n\n- 功能：为指定信号注册信号处理函数。当进程收到SigNo信号时，立即自动调用Handle函数执行。一般在进程初始化时使用该函数注册信号处理函数。\n\n\n<br />**kill()：发送信号的函数**<br />\n\n- 原型```c\nvoid kill(\n	int PID, //接收信号的目标进程ID\n    int SigNo //待发送的信号\n)\n```\n\n- 功能：向目标进程PID发送SigNo信号。\n\n\n<br />**信号机制编程：例子1**<br />\n\n- 任务：编写一个死循环的程序，当其收到键盘按下的 Ctrl+C 信号后,输出 “BYE BYE!”，然后退出。\n- 思路：让进程对 Ctrl+C 的 SIGINT 信号用自定义的信号处理函数响应。在自定义信号处理函数输出后“BYE BYE!”后结束。\n- ![image-20200331170949312.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575209701-3fa32609-98a3-4ca6-bb40-ab9449fb5934.png#align=left&display=inline&height=199&margin=%5Bobject%20Object%5D&name=image-20200331170949312.png&originHeight=359&originWidth=666&size=155017&status=done&style=none&width=370)\n\n\n<br />**信号机制编程：例子2**<br />\n\n- 任务：一个进程（父进程）等待另一个死循环的进程（子进程）先结束自己并向自己 BYE BYE 后,自己再结束\n- 思路：父进程主动发送一个信号给子进程，子进程收到之后立即准备结束。子进程中设置信号处理函数，提前结束自己，并向父进程 “BYE BYE!”\n- ![image-20200331171246756.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575224863-678d7d77-72f3-490e-a89b-0b5dfc739ee6.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image-20200331171246756.png&originHeight=412&originWidth=503&size=140983&status=done&style=none&width=303)\n- ![image-20200331171307029.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575234937-f0b9ce43-5edb-4db1-be9c-954eea6683ae.png#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&name=image-20200331171307029.png&originHeight=398&originWidth=496&size=115826&status=done&style=none&width=281)\n\n\n\n<a name=\"425be80c\"></a>\n## 第五章 死锁\n\n\n<a name=\"25729d96\"></a>\n### 死锁概念\n\n<br />**哲学家就餐问题**<br />![image-20200606215811591.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575274598-5bd2a6cb-12da-4344-951b-041655478a8b.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&name=image-20200606215811591.png&originHeight=394&originWidth=728&size=235399&status=done&style=none&width=360)<br />\n<br />若五位哲学家同时拿起左边的筷子，将导致死锁。<br />\n<br />**死锁定义**：两个或多个进程无限期地等待永远不会发生的条件的一种系统状态【结果：每个进程都永远阻塞】。<br />\n<br />**死锁的另一个定义**：在两个或多个进程中，每个进程都持有某种资源，但又继续申请其他进程已持有的某种资源，此时每个进程都拥有其运行所需的一部分资源，但是又都不够，从而每个进程都不能向前推进，陷于阻塞状态，这种状态称死锁。<br />\n\n<a name=\"2bc907b9\"></a>\n### 死锁起因\n\n<br />**死锁的起因**<br />\n\n- **系统资源有限**：资源数目不足，进程对资源的竞争而产生死锁\n- **并发进程的推进顺序不当**：进程请求资源和释放资源的顺序不当，导致死锁\n- ![image-20200606220713022.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575299031-7d5a26c5-00f1-4f9a-890e-aa9f32a68c14.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image-20200606220713022.png&originHeight=408&originWidth=779&size=228817&status=done&style=none&width=425)\n- **不正确的P-V操作也可能会带来死锁**：比如生产者消费者问题\n\n\n<br />**关于死锁的一些结论**<br />\n\n- 参与死锁的进程至少是两个，两个或以上进程才会出现死锁\n- 参与死锁的进程至少有两个已经占有资源\n- 参与死锁的所有进程都在等待资源\n- 参与死锁的进程是当前系统中所有进程的子集\n- 死锁会浪费大量系统资源，甚至导致系统崩溃\n\n\n\n<a name=\"3ef0dbe4\"></a>\n### 死锁预防策略\n\n<br />**死锁的必要条件**<br />\n\n- **互斥条件**：进程互斥使用资源，资源具有独占性。\n- **不剥夺条件**：进程在访问完资源前不能被其他进程强行剥夺。\n- **部分分配条件**：进程边运行边申请资源，临时需要临时分配\n- ![image-20200407163856321.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575322848-162d2133-446b-4cc3-82dc-e8928f066abb.png#align=left&display=inline&height=125&margin=%5Bobject%20Object%5D&name=image-20200407163856321.png&originHeight=302&originWidth=740&size=94713&status=done&style=none&width=307)\n- **环路条件**：多个进程构成环路：环中每个进程已占用的资源被前一进程申请，而自己所申请资源又被环中后一进程占用着。\n\n\n<br />**解决死锁的策略**<br />\n\n- **预防死锁**\n   - 通过设置某些限定条件，破坏死锁四个必要条件中的一个或多个，来防止死锁\n      - 破坏互斥条件（难）；破坏不剥夺条件（代价大）；破坏部分分配条件（**预先静态分配**）；破坏环路条件（有序资源分配）\n   - 较易实现，(早期)广泛使用\n      - 缺点：由于限制太严格，导致资源利用率和吞吐量降低。\n- **避免死锁**\n   - 不是先采取限制去破坏产生死锁的条件，而是在资源分配过程中用某种方法去评估**若分配资源是否会让系统进入死锁状态**，若是，则拒绝此分配资源，从而避免死锁的发生\n   - 银行家算法\n   - 只需要较弱的限制条件，可获得较高的资源利用率和系统吞吐量。缺点：实现较难。\n- **检测死锁**和**恢复死锁**\n   - 允许死锁发生，但可通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁清除，将进程从死锁状态解脱出来\n   - **缺点1**：检测方法复杂，实现难度大\n   - **缺点2**：恢复方法靠人工。撤销一些进程，回收资源再分配。\n\n\n<br />**预先静态分配法**<br />\n\n- **目的**：破坏部分分配条件\n- **策略**：进程运行前将所需资源一次性全部分配给它。因此进程在运行过程中不再提出资源请求，从而避免出现阻塞或者死锁\n- **特点**：\n   - 执行可能被延迟：所需资源不能全部满足时。\n   - 应用开销量增大：运行前估算资源需求。\n   - 资源利用率低：资源被占而不用。\n- **改进**：资源分配的单位由进程改为程序步。\n\n\n<br />**有序资源分配法**<br />\n\n- **目的**：破坏环路条件，使得环路无法构成。\n- **策略**：\n   - 系统中的每个资源分配有一个唯一**序号**；\n   - 进程每次申请资源时只能申请序号更大的资源！\n      - 如果进程已占有资源的序号最大为M，则下次只能申请序号大于M的资源，而不能再申请序号小于或等于M的资源。\n- 【**如何证明**？】按有序资源分配法分配资源并发进程不会死锁\n- **资源分配策略**\n   - 分配资源时检查资源序号是否符合**递增**规定\n      - 若不符合：则拒绝该申请并撤销该进程\n      - 若符合：且资源可用则予以分配\n      - 若符合：但资源不可用则不分配，陷于阻塞\n\n\n<br />**Windows，Linux没有采用死锁解决方案：鸵鸟策略**<br />\n\n<a name=\"da14c7de\"></a>\n## 第六章 进程调度\n\n\n> 在第四章提到过在操作系统里多个进程会共享CPU，以时间片为单位共享CPU，对于操作系统来说，在下一个CPU时间片改选哪个进程占用CPU运行呢？这是操作系统进程调度模块要考虑的。\n\n\n\n<a name=\"2257e060\"></a>\n### 进程调度的概念\n\n<br />**进程调度**<br />\n\n- **在合适的时候以一定策略选择一个就绪进程运行。**\n- 调度时机？\n- 调度策略？\n- 调度目标？\n\n\n<br />**进程调度的目标**<br />\n\n1. 响应速度尽可能快（CPU更频繁地切换）\n2. 进程处理的时间尽可能短（进程提交到系统中到进程输出最终结果这个时间）\n3. 系统吞吐量尽可能大（单位时间内要处理更多的数据，运行更多的进程）\n4. 资源利用率尽可能高（尽量让资源处于忙碌状态）\n5. 对所有进程要公平\n6. 避免饥饿\n7. 避免死锁\n\n\n<br />**上述部分原则之间存在自相矛盾**：1 2；1 3；2 5<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575374833-ecb79c13-8609-42ab-b686-8d69141419ca.png#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=577&size=185720&status=done&style=none&width=288.5)<br />\n<br />**两个量化的衡量指标**<br />\n\n- 周转时间/平均周转时间\n- 带权周转时间/平均带权周转时间\n\n\n<br />**周转时间:进程提交给计算机到最终完成所花费的时间（t）**<br />\n<br />**t=t-t**<br />\n\n- t—进程的提交时间（Start）\n- t—进程的完成时间(Complete)\n- 意义：说明进程在系统中停留时间的长短\n\n\n<br />**平均周转时间**<br />\n\n- t=(t+t+…+t)/n\n- 意义:平均周转时间越短，意味着这些进程在系统内停留的时间越短，因而系统吞吐量也就越大，资源利用率也越高\n\n\n<br />**带权周转时间w**<br />\n\n- w=t/t\n- t:进程的周转时间\n- t:进程的运行时间（run)，即进程在CPU上运行的时间，表明了进程自身的大小\n- 意义：进程在系统**相对**停留时间（w是一个无量纲的数字）\n\n\n<br />**平均带权周转时间：**<br />\n\n- w=(w+w+…+w)/n\n\n\n<br />**典型调度算法**<br />\n<br />先来先服务调度，短作业优先调度算法,响应比高者优先调度算法,优先数调度算法，循环轮转调度法，可变时间片轮转调度法，多重时间片循环调度法<br />\n\n<a name=\"2654a066\"></a>\n### 典型调度算法\n\n<br />**先来先服务调度 FCFS**<br />\n\n- **算法：**按照作业进入系统的时间，先后来挑选作业。先进入系统的作业优先被运行。\n- **特点**：\n   - 容易实现，效率不高\n   - 只考虑作业的**等候时间**，而没有考虑**运行时间**的长短。因此一个晚来但是很短的作业可能需要等待很长时间才能被运行，因而本算法**不利于短作业**\n\n\n<br />**短作业优先调度算法**<br />\n\n- **算法：**参考**运行时间**，选取运行时间最短的作业投入运行。\n- **特点：**\n   - 易于实现，效率不高\n   - 忽略了作业等待时间，一个早来但是很长的作业将会在很长时间得不到调度，易出现资源“**饥饿**”的现象\n\n\n<br />**响应比高者优先调度算法**<br />\n\n- **响应比定义：**\n   - 作业的响应时间与运行时间的比值\n   - 响应比=响应时间/运行时间=(等待时间+运行时间)/运行时间=1+等待时间/运行时间\n- **算法**：计算每个作业的响应比，选择响应比**最高**的作业优先投入运行。\n- **特点：**\n   - 响应比=1+等待时间/运行时间\n   - 如果作业等待时间相同，则运行时间越短的作业，其响应比越高，因此越容易被调度。因而**有利于短作业**。\n   - 如果作业运行时间相同，则等待时间越长的作业，其响应比越高，因此越容易被调度，因而有**利于等候长的作业**。\n   - 对于运行时间长的作业，其优先级可以随等待时间的增加而提高，当其**等待足够久的时候，也有可能获得CPU**\n\n\n<br />**优先数调度算法**<br />\n\n- **算法：**\n   - 根据进程优先数，把CPU分配给最高的进程\n   - **进程优先数**=静态优先数+动态优先数\n- **静态优先数：** 进程创建时确定，在整个运行期间不再改变。\n- **动态优先数：**动态优先数在进程运行期间可以改变\n- **静态优先数的确定：**\n   - 基于进程所需的资源多少\n   - 基于程序运行时间的长短\n   - 基于进程类型【IO/CPU,前台/后台,核心/用户】\n- **动态优先数的确定**：\n   - 当使用CPU超过一定时长时(-)\n   - 当进行I/O操作后(+)\n   - 当进程等待超过一定时长时(+)\n\n\n<br />**循环轮转调度法**<br />\n\n- **概念：**\n   - 把所有就绪进程按**先进先出**的原则排成队列，新来进程加到队列末尾。\n   - 进程以**时间片q为单位**轮流使用CPU。刚刚运行一个时间片的进程排到队列末尾，等候下一轮运行。\n   - 队列逻辑上是环形的。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575494041-f6836de0-8cc5-4a2a-bb1c-2a820726c70e.png#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=649&size=42590&status=done&style=none&width=324.5)\n\n- **优点：**\n   - 公平性：每个就绪进程有平等机会获得CPU\n   - 交互性：每个进程等待(N-1)*q的时间就可以重新获得CPU\n- **时间片q的大小：**\n   - 如果q太大:交互性差，甚至退化为fcfs调度算法\n   - 如果q太小:进程频换频繁，系统开销增大\n- **改进**：\n   - 时间片的大小可变\n   - 组织多个就绪队列\n\n\n\n<a name=\"fe40608d\"></a>\n## 第七章 存储管理\n\n\n<a name=\"9aad168b\"></a>\n### 内存管理功能\n\n<br />**存储器功能需求**：容量足够大、速度足够快、信息永久保存、多道程序并行<br />\n<br />**多道程序并行带来的问题**：共享（代码和数据共享，节省内存）、保护（不允许内存中的程序相互间非法访问）<br />\n<br />**实际存储体系**：<br />\n\n- 三级存储体系\n\n![image-20200414170701511.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575527173-1b9b9b7b-b4cc-4d56-8be0-49c79453c374.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&name=image-20200414170701511.png&originHeight=89&originWidth=536&size=24970&status=done&style=none&width=425)\n\n- Cache(快、小、贵)+内存（适中）+辅存（慢、大、廉）\n- 基本原理：\n   - 当内存太小不够用时，用辅存来支援内存\n   - 暂时不运行的模块换出到辅存，必要时再换入内存\n\n\n<br />**存储管理的功能**<br />\n\n1. **地址映射**\n   - **定义**：把程序中的地址（虚拟地址/虚地址/逻辑地址）变换成内存的真实地址（实地址/物理地址）的过程。地址重定位，地址重映射\n   - **方式**：<br />**固定地址映射**\n      - **定义**：**编程或编译时**确定逻辑地址和物理地址映射关系。\n      - **特点**：①程序加载时必须放在指定的内存区域②容易产生地址冲突，运行失效\n\n\n**静态地址映射**\n\n      - **定义**：程序**装入时**由操作系统完成逻辑地址到物理地址的映射。\n      - **过程**：①逻辑地址:VA②装入基址BA（装在内存里面的起始地址）③物理地址MA（每个虚拟地址对应的物理地址）<br />MA=BA+VA\n      - **例子**：逻辑地址：VA=X   (X)=1234   装入基址：BA\n\n![image-20200607090006078.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575590810-3067233b-eacd-494b-8a73-1810294d3f3f.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&name=image-20200607090006078.png&originHeight=183&originWidth=195&size=24247&status=done&style=none&width=126)![image-20200607090019300.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575600778-2eab5821-b52f-4f71-8c9a-d75bb405d428.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&name=image-20200607090019300.png&originHeight=425&originWidth=209&size=35599&status=done&style=none&width=127)\n\n      - **特点**\n         - 程序运行之前确定映射关系\n      - 程序装入后不能移动（如果移动必须放回原来位置）\n         - 程序占用连续的内存空间\n\n\n**动态地址映射**\n\n      - **定义**：在程序**执行过程中**把逻辑地址转换为物理地址。（例如：MOV AX,[500]; 访问500单元时执行地址转换）\n      - **映射过程**：MA=BA+VA<br />注意：如果程序有移动，BA可能有改变，自动计算新的MA\n      - **特点**\n         - 程序占用的内存空间可动态变化（要求及时更新基址BA）\n         - 程序不要求占用连续的内存空间（每段放置基址BA系统应该知道）\n         - 便于多个进程共享代码（共享代码作为独立的一段存放）\n         - ![image-20200607090303629.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575623599-4bc6e3d1-b206-4d25-a316-bff39d28126f.png#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&name=image-20200607090303629.png&originHeight=369&originWidth=157&size=45372&status=done&style=none&width=77)\n      - **缺点**：①硬件支持（MMU：内存管理单元）②软件复杂\n2. **虚拟存储**\n   - **解决的问题：**\n      - 程序过大或过多时，内存不够，不能运行\n      - 多个程序并发时地址冲突，不能运行\n   - **概念：虚拟内存是面向用户的虚拟封闭存储空间**<br />        ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575691002-46318279-89ff-42b9-9fb9-6c38c2ef49ac.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=438&size=64273&status=done&style=none&width=219)<br />	对每一个进程来说都有这样一个封闭的4G空间。一个进程的虚拟空间跟另外一个进程的虚拟空间完全不相关是分离的。\n   - **虚拟内存管理的目标**\n      - 使得大的程序能在较小的内存中运行；\n      - 使得多个程序能在较小的内存中运行(/能容纳下)\n      - 使得多个程序并发运行时地址不冲突(/方便高效)\n      - 使得内存利用率高：无碎片，共享方便\n3. **内存分配功能**\n   - **为程序运行分配足够的内存空间**\n   - **需要解决的问题**\n      - 放置策略：程序调入内存时将其放置在哪个/哪些内存区\n      - 调入策略：何时把要运行的代码和要访问的数据调入内存\n      - 淘汰策略：内存空间不够时，迁出（淘汰）哪些代码或数据以腾出内存的\n4. **存储保护功能**\n   - **保证在内存中的多道程序只能在给定的存储区域内活动并互不干扰**：①防止访问越界②防止访问越权\n   - **方法：界址寄存器**\n      - 在CPU中设置一对下限寄存器和上限寄存器存放程序在内存中的下限地址和上限地址\n         - 程序访问内存时硬件自动将目的地址与下限寄存器和上限寄存器中存放的地址界限比较，判断是否越界\n\n\n<br />物理存储单元的集合<br />\n<br />虚空间、逻辑空间；mmu负责把虚地址转换成物理地址，变换过程需要线性地址的转换<br />\n\n<a name=\"acbd91b9\"></a>\n### 物理内存管理\n\n\n<a name=\"bd4c500a\"></a>\n#### 分区内存管理\n\n\n<a name=\"3799be3e\"></a>\n##### 单一区存储管理（不分区存储管理）\n\n\n- 定义：用户区不分区，完全被一个程序占用（例如DOS)\n- 优点：简单，不需复杂硬件支持，适用于单用户单任务OS\n- 缺点：程序运行占用整个内存，即使小程序也是如此。内存浪费，利用率低。\n\n\n\n<a name=\"8361351b\"></a>\n##### 分区存储管理\n\n\n- **定义**：\n   - 把用户区内存划分为若干大小不等的分区，供不同程序使用。\n   - 适合单用户单任务系统。\n- 分类：\n   - **固定分区：**\n      - **定义**：把内存固定地划分为若干大小不等的分区供各个程序使用。每个分区的大小和位置固定，系统运行期间不再重新划分。\n      - **分区表**：记录分区的位置、大小和使用标志\n      - **例子**：\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575745849-de0ef826-654d-4b0d-b90c-c1c64f617e9d.png#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=634&size=77966&status=done&style=none&width=317)\n\n      - **使用特点**：\n         - 在程序装入前，内存已被分区，不再改变\n         - 每个分区大小不同，适应不同大小的程序。\n         - 系统要维护分区表\n         - 例如：IBM的OS/360采用了固定分区方法。（具有固定任务数的多道程序系统。）\n      - **缺点：**\n         - 浪费内存：程序比所在分区小\n         - 大程序可能无法运行：程序可能比最大分区大\n      - **建议**：根据分区表安排程序装入顺序，使每个程序都能找到合适的分区运行。当程序的大小、个数、装入顺序等都固定时，内存使用效率很高。\n   - **动态分区**\n      - **定义**：在程序**装入时**创建分区，使分区的大小刚好与程序的大小相等。\n      - **特点**：分区动态建立；分区的个数和大小均可变；存在内存碎片\n      - **例子：动态分区存在的问题**\n\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575783073-a7c97f49-304a-4a92-9291-950c33501c7a.png#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=635&size=149494&status=done&style=none&width=317.5)**\n\n      - **需要解决的问题**：分区的分配？分区的选择？分区的回收？解决内存碎片问题？\n\n\n\n<a name=\"8d4a71d6\"></a>\n#### 分区放置策略\n\n\n<a name=\"086c7aac\"></a>\n##### 分区的分配\n\n\n- **空闲区表**：描述内存空闲区的位置和大小的数据结构\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575803556-bbd46bbf-82a8-4a0c-b2c0-4cd7f650e87f.png#align=left&display=inline&height=171&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=670&size=121750&status=done&style=none&width=335)\n\n- **分配过程**（假设用户要求的空间大小为**s**）\n   1. 从空闲区表的第一个区开始，寻找**>=s**的空闲区\n   2. 找到后从分区中分割出大小为**s**的部分给用户使用。\n   3. 分割后的剩余部分作为空闲区仍然登记在空闲区表中。\n   3. 注意：分割空闲区时一般从**底部**（高地址）分割。【目的是为了让剩下的空闲区在空闲区表中位置不变，起始地址不变，只需要改变其大小即可，这是为了方便更新空闲区表】\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575820800-61545141-3cfd-4337-8142-10664e292499.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&name=image.png&originHeight=142&originWidth=282&size=21232&status=done&style=none&width=141)\n\n- **空闲区表如何排序--放置策略（空闲区表排序原则）**\n   - **首次适应算法**（效率最高）\n      - 前提：空闲区表按**首地址递增排序**。\n      - 特点/优点：尽可能地先使用**低地址**空间；当需要较大分区时在高地址空间有较大的满足可能性。\n      - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575834228-a2f4b566-b686-43c8-b6f2-f1e32c0f6066.png#align=left&display=inline&height=74&margin=%5Bobject%20Object%5D&name=image.png&originHeight=147&originWidth=240&size=13938&status=done&style=none&width=120)\n   - **最佳适应算法**（内存利用率最低）\n      - 前提：空闲区表按**大小递增排序**\n      - 特点/优点：尽可能地先使用较小的空闲区，保留大的空闲区。当需要较大分区时有较大的满足可能性。\n      - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575845013-299d1d0f-9dce-4cff-8819-da190cf77997.png#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=171&size=12017&status=done&style=none&width=85.5)\n   - **最坏适应算法**（内存利用率最高）\n      - 前提：空闲区表按**大小递减排序**\n      - 优点：大空闲区分割后剩下的部分还是很大，还能装下较大的程序\n      - 特点：仅作一次查找就可找到分区。\n      - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575854453-c8b53544-8052-4cfd-950c-b062c87c9ae0.png#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=185&size=15236&status=done&style=none&width=92.5)\n\n\n\n<a name=\"3a0a41ca\"></a>\n##### 分区的回收\n\n\n- **功能**：回收程序释放分区（释放区），登记到空闲区表中，以便再分配。\n- **回收算法**：\n   - 要考虑释放区与现有空闲区是否相邻？\n   - 若释放区与现有空闲区不相邻，则直接插入空闲区表。\n   - 若释放区与现有空闲区相邻，则空闲区合并后更新空闲区表。\n- 具体回收过程<br />\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575883230-bc19c6ac-80fb-4b3e-ba9f-d31a61d71c89.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&name=image.png&originHeight=316&originWidth=683&size=94709&status=done&style=none&width=341.5)\n<a name=\"584261be\"></a>\n#### 内存覆盖技术---Overlay\n\n<br />**目的**：在较小的内存空间中运行较大的程序。<br />\n<br />**内存分区：**<br />\n\n- **常驻区**：被某段单独且固定地占用，可划分多个\n- **覆盖区**：能被多段共用（覆盖），可划分多个\n- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575891575-a7f95d5e-8f7e-4bef-bb97-213f21c65b7a.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=156&originWidth=176&size=13610&status=done&style=none&width=88)\n\n\n<br />**覆盖的例子**<br />\n\n- 内存（110K）：一个常驻区，两个覆盖区\n- 程序（190K）：6个段\n- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575900301-8df0b33a-3067-4fc9-97bd-9f6db15cf407.png#align=left&display=inline&height=88&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=434&size=48309&status=done&style=none&width=217)\n\n\n<br />**缺点**：<br />\n\n- 编程复杂：程序员划分程序模块并确定覆盖关系\n- 程序执行时间长：从外存装入内存耗时\n\n\n\n<a name=\"7cad9ec8\"></a>\n#### 内存交换技术—Swapping\n\n\n> 目的：在小内存里面并发运行多个进程，在内存里面宏观上同时运行多个进程。\n\n\n<br />**原理**：内存不够时把进程写到磁盘（换出/Swap Out）。当进程要运行时重新写回内存（换入/Swap In）。<br />\n<br />**优点**：增加进程并发数。不考虑程序结构。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575910749-d56a7914-58dd-48bf-ad46-3ad2a68185f1.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=296&size=26524&status=done&style=none&width=148)<br />\n<br />**交换技术的缺点**：换入和换出增加CPU开销；交换单位太大（整个进程）。<br />\n<br />**需要考虑的问题**：减少交换传送的信息量（模块/段）；外存交换空间的管理方法；程序换入时的地址重定位。<br />\n<br />**换出与换入的地址重定位**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575924562-f1d8b60f-4c92-43de-80e0-05b3943eab99.png#align=left&display=inline&height=245&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=466&size=152921&status=done&style=none&width=233)<br />\n\n<a name=\"f71a3d45\"></a>\n#### 内存碎片\n\n<br />**内存碎片**：过小的空闲区，难实际利用。内存碎片会降低内存有效利用率。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575936692-a1e0dd0d-3116-405d-aecf-1489375e794f.png#align=left&display=inline&height=97&margin=%5Bobject%20Object%5D&name=image.png&originHeight=194&originWidth=251&size=50589&status=done&style=none&width=125.5)<br />\n<br />**碎片问题**<br />\n\n- **动态分区的缺点**：①容易产生内存碎片：内存反复分配和分割②首次适应法|**最佳适应法**|最坏适应法？\n- **解决碎片的办法1**\n   - 规定门限值\n- 分割空闲区，若剩余部分小于门限值，则此空闲区不进行分割，而是全部分配给用户\n- **解决碎片的办法2：内存拼接技术**\n   - 将所有空闲区集中一起构建一个大的空闲区\n   - 拼接的时机：\n      - 释放区回收的时候：拼接频率过大，系统开销大\n      - 系统找不到足够大的空闲区时：空闲区的管理复杂\n   - 定期：空闲区的管理复杂\n   - **拼接技术的缺点**：消耗系统资源、离线拼接、重新定义作业\n- **解决碎片的办法3：解除程序占用连续内存才能运行的限制**\n   - 把程序分拆多个部分装入不同分区，充分利用碎片\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575947330-ec139756-3722-485f-a563-71495a79ab67.png#align=left&display=inline&height=110&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=431&size=41989&status=done&style=none&width=215.5)\n<a name=\"3b667e41\"></a>\n### 虚拟内存管理\n\n\n<a name=\"95d70cb2\"></a>\n#### 页式虚拟内存管理\n\n<br />**物理内存（即实内存）管理**\n\n|  | 特点 | 缺点 |\n| --- | --- | :---: |\n| 1 | 源程序直接使用内存物理地址 | 程序间容易访问冲突 |\n| 2 | 程序必须全部装入内存才能运行 | 内存大小程序无法运行 |\n| 3 | 程序占用连续的一片内存 | 产生内存碎片 |\n| 4 | 多程序同时运行容易相互干扰 | 不安全 |\n\n\n<br />**改善物理内存管理的相关技术**<br />\n\n- 内存拼接\n- 对换技术【Swapping】\n- 覆盖技术【Overlay】\n\n\n<br />**虚拟内存管理的目标**<br />\n\n- 使得大的程序能在较小的内存中运行\n- 使得多个程序能在较小的内存中运行（/能容纳下）\n- 使得多个程序并发运行时地址不冲突（/方便，高效）\n- 使得内存利用率高：无碎片，共享方便\n\n\n<br />**虚拟内存管理的实现思路**<br />\n<br />	在程序运行时，只把当前必要的很小一部分代码和数据装入内存中。其余代码和数据需要时再装入。不再运行的代码和数据及时从内存删除。<br />\n<br />	实际内存很容易就能满足上述的内存需求。<br />\n<br />	该思路利用到了程序运行的局部性原理。<br />\n<br />**程序运行的局部性**<br />\n\n- 程序在一个**有限的时间段**内访问的代码和数据往往集中在**有限的地址范围**内。\n- 把程序**一部分**装入内存**在较大概率上**也足够让其运行一小段时间。\n\n\n<br />**典型虚拟内存管理方式**<br />\n\n- **页式虚拟内存管理**\n   - 概念：把进程空间（虚拟）和内存空间划成等大小的小片\n      - 小片的典型大小：1K,2K或4K…\n      - 进程的小片 --- **页**（虚拟页或页面）\n      - 内存的小片 --- **页框**（物理页）\n      - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575960542-abccb62e-8258-4690-aa22-c6287cb089a0.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=242&size=27190&status=done&style=none&width=121)\n   - **进程装入和使用内存的原则**\n      - 内存以**页框**为单位分配使用。\n      - 进程以**页**为单位装入内存\n         - 只把程序**部分页**装入内存便可运行。\n         - 页在内存中占用的页框**不必相邻**\n         - 需要新页时，**按需**从硬盘调入内存。\n         - 不再运行的页及时**删除**，腾出空间。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575972759-d370623e-8714-47e5-9a51-fad7544a0103.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=248&size=28092&status=done&style=none&width=124)\n\n- **段式虚拟内存管理**\n- **段页式虚拟内存管理**\n\n\n\n<a name=\"7da9d7ed\"></a>\n#### 页表和页式地址映射\n\n<br />**页式系统中的地址**<br />\n\n- 虚拟地址（VA）可以分解成**页号**P和**页内偏移**W\n   - 页号（P）：**VA所处页的编号=VA/页的大小**\n   - 页内偏移（W）：**VA所处页的偏移=VA%页的大小**\n   - 例子：VA=2500; 页面大小1K(2)\n      - P=2500/1024=2\n      - W=2500%1024=452\n\n\n<br />**P和W的另一种计算方法**（CPU）<br />\n\n- 已知：页的大小：2单元\n- P和W的计算：页号P=VA>>n;   页内偏移W=低n位=VA&&(2-1)\n\n\n<br />**页面映射表**<br />\n\n- 记录**页**与**页框**之间的**对应关系**。也叫**页表**。\n- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575985706-c7c4a1ca-7af1-49fe-9f40-ac3eee4638cf.png#align=left&display=inline&height=41&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=312&size=15636&status=done&style=none&width=156)\n- 页号：登记程序地址的页号\n- 页框号：登记页所在的物理页号\n- 页面的其他特性：登记含存取权限在内的其它特性\n\n\n<br />**页表例子：一个进程：4页**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592575997435-57d6f0ad-a081-4638-ae19-bbd7aef93864.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=233&originWidth=369&size=39773&status=done&style=none&width=184.5)<br />\n<br />**页式地址映射**<br />\n\n- 功能：**虚拟地址（页式地址）---> 物理地址**\n- 过程【三步】\n   - 从VA分离页号**P**和页内偏移**W**\n   - 查**页表**：以P为索引查**页框号P**\n   - 计算物理地址**MA** = P*页大小+W\n- **例子：**\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576007312-29f96184-86b0-40ac-a599-f7b5a7a5c4c2.png#align=left&display=inline&height=144&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=373&size=95992&status=done&style=none&width=186.5)\n<a name=\"b584f48e\"></a>\n#### 快表技术和页面共享技术\n\n<br />**快表机制（Cache）**<br />\n\n- **快表的概念**\n   - 慢表：页表放在内存中\n   - 快表：页表放在Cache中\n- **快表的特点**\n   - 容量小，访问快，成本高\n   - 快表是慢表的部分内容的复制\n   - 地址映射时优先访问快表（若在快表中找到所需数据，则称为“命中”；没有命中时，需要访问慢表，同时更新快表）\n   - 合理的页面调度策略能使快表具有较高命中率\n- 快表机制下地址映射**过程**\n   - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576019383-9cbca460-2157-48a2-b3bd-5cfa06f832a0.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&name=image.png&originHeight=315&originWidth=505&size=96964&status=done&style=none&width=252.5)\n\n\n<br />思考1：没有快表执行访存命令时，总共需要访问几次内存？<br />\n<br />**页面的共享**<br />\n\n- 代码共享的**例子**---文本编辑器占用多少内存\n   - 文本编辑器：150KB代码段和50KB数据段\n   - 有10进程并发执行该文本编辑器\n   - 占用内存=10*（150+50）KB=2MB\n   - 如果采用代码段共享，代码段在内存只有一份真实存储\n      - 占用内存 = 150+10*50=650KB\n- 页面共享**原理**\n   - 在不同进程的页表中填上**相同的页框号**，多个进程能访问相同的内存空间，从而实现**页面共享**。\n   - **共享页面**在内存中只有**一份**真实存储，节省内存。\n- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576029783-5190272b-f235-4332-b51d-a5888761c436.png#align=left&display=inline&height=138&margin=%5Bobject%20Object%5D&name=image.png&originHeight=275&originWidth=519&size=133282&status=done&style=none&width=259.5)\n\n\n\n<a name=\"c605dedd\"></a>\n#### 缺页中断\n\n<br />**分级存储体系**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576039406-fcc6bb71-f3f7-451a-8375-a7cf39b0a163.png#align=left&display=inline&height=61&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=415&size=28335&status=done&style=none&width=207.5)<br />\n<br />**页表的扩充----带中断位的页表**<br />\n\n- 扩充有**中断位**和辅存地址的页表\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576055048-80c4e5d7-75fb-4d85-a550-efcd94830b8f.png#align=left&display=inline&height=54&margin=%5Bobject%20Object%5D&name=image.png&originHeight=108&originWidth=282&size=23861&status=done&style=none&width=141)\n\n- 中断位I ---- 标识该页是否在内存？若I=1，不在，I=0,在\n- 辅存地址---该页在辅存上的位置\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576069656-3287566a-0e43-4a58-b986-fb5cf08dfe0c.png#align=left&display=inline&height=149&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=456&size=76667&status=done&style=none&width=228)<br />**页表的扩充----带访问位和修改位的页表**<br />\n\n- 扩充有**访问位**和**修改位**的页表\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576082711-fb4555d2-e63f-40d3-981f-bf98e0c596df.png#align=left&display=inline&height=45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=89&originWidth=281&size=18581&status=done&style=none&width=140.5)\n\n   - 访问位---标识该页最近是否被访问？0--没有，1---有\n   - 修改位---标识该页的数据是否已被修改？ 0 -- 未， 1---有\n- **缺页中断**：在地址映射过程中，当所要访问的目的页不在内存时，则系统产生异常中断---缺页中断。\n   - **缺页中断处理程序**：中断处理程序把所缺的页从页表指出的**辅存地址**调入内存的某个**页框**中，并更新页表中该页对应的**页框号**以及修改**中断位I**为0。\n\n\n<br />**访存指令的执行过程（含缺页中断处理）**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576092799-10dee429-9c63-4b22-ab10-fc838bd77d80.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&name=image.png&originHeight=317&originWidth=478&size=109537&status=done&style=none&width=239)<br />\n\n- **缺页（中断）率**：\n   - **缺页率f = 缺页次数/访问页面总次数**\n   - 命中率=1-f\n\n\n\n<a name=\"ac024661\"></a>\n#### 页面淘汰策略\n\n<br />**淘汰策略**<br />\n\n- **淘汰策略**：选择淘汰**哪一页**的规则称**淘汰策略**。\n- **页面抖动**：页面在内存和辅存间频繁交换的现象；“抖动”会导致系统效率下降\n- **好的淘汰策略**：具有较低的缺页率（高命中率）；页面抖动较少\n- **常用的淘汰算法：**\n   - **最佳算法（OPT算法）**：淘汰以后**不再需要**或**最远的将来**才会用到的页面\n      - 例子：\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576111271-86e8b219-7e18-4715-937d-7e7293bc83b4.png#align=left&display=inline&height=102&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=450&size=98384&status=done&style=none&width=225)\n\n      - 特点：理论上最佳，实践中该算法**无法实现**。（在进程没有运行完之前，我们并不知道这个进程后面要访问什么样的页面）\n   - **先进先出淘汰算法（FIFO算法）**：淘汰在内存中**停留时间最长**的页面\n      - 例子：![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576124999-c6986f17-10a8-48b9-881e-ad387c913617.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=425&size=96344&status=done&style=none&width=212.5)\n      - **优点**：实现简单：页面按进入内存的时间排序，淘汰对头页面\n      - **缺点**：①进程只有按**顺序访问**地址空间时页面命中率才最理想。②异常现象：对于一些特定的访问序列，随分配的页框增多，缺页率反而增加！\n      - 例子2：![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576157873-f9c325ea-34b7-4ce6-8575-ff4ac0718b2f.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=233&originWidth=408&size=101594&status=done&style=none&width=204)\n   - **最久未使用淘汰算法（LRU算法）**：淘汰**最长时间未被使用**的页面\n      - 例子：![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576172982-2844d71a-4989-4d4b-bdc4-1cbb92ff9dd7.png#align=left&display=inline&height=103&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=436&size=101916&status=done&style=none&width=218)\n      - **LRU的实现（硬件方法）**\n         - 页面设置一个**移位寄存器R**。每当页面被访问则将其**重置为1**.\n         - 周期性地（**周期很短**）将所有页面的R左移1位（右边补0）\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576192433-ba085fd1-ea13-4e92-9358-b579388f2a3c.png#align=left&display=inline&height=52&margin=%5Bobject%20Object%5D&name=image.png&originHeight=103&originWidth=384&size=33036&status=done&style=none&width=192)\n\n         - 当需要淘汰页面时选择**R值最大**的页：R越大，对应页未被使用的时间越长\n         - R的**位数越多**且位移**周期越小**就越**精确**，但硬件成本也越高。\n         - 若R的位数太少，可能同时出现多个为0的页面，难以比较。\n      - **LRU近似算法（软件方法）**\n         - 利用页表**访问位**，页被**访问时**其值由硬件**置1**\n         - 软件周期性（T）地将所有访问位**置0**\n         - 当淘汰页面时根据该页**访问位**来判断是否淘汰\n            - 访问位为1：在时间T内，该页被访问过，保留该页\n            - 访问位为0：在时间T内，该页未被访问过，淘汰该页\n      - **缺点**：周期T难定\n         - 太小，访问位为0的页过多，找不到合适的页面淘汰\n         - 太大，访问位为1的页过多，找不到合适的页面淘汰\n   - **最不经常使用（LFU）算法**\n      - 算法原则\n         - 选择到当前时间为止被访问**次数**最少的页面\n         - 每页设置**访问计数器**，每当页面被访问时，该页面的访问计数器加1\n         - 发生缺页中断时，淘汰**计数值最小**的页面，并将所有计数清零。\n\n\n\n<a name=\"0f64b971\"></a>\n#### 缺页因素与页式系统缺点\n\n<br />**缺页的因素**<br />\n\n- 淘汰算法\n- 分配给进程的页框数：页框越**少**，越容易缺页\n- 页本身大小\n\n\n<br />**页面的大小选择**<br />\n\n- 页面太大（浪费内存：极限是分区存储）\n- 页面太小（页面增多，页表长度增加，浪费内存；换页频繁，系统效率低）\n- 页面的常见大小：2的整数次幂：1KB 2KB **4KB**\n\n\n<br />**影响缺页次数的因素**<br />\n\n- 淘汰算法\n- 分配给进程的页框数：页框越少，越容易缺页\n- 页本身大小\n- 程序的编制方法：局部性越好，越不容易缺页；跳转或分支越多越容易缺页\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576208875-ccb38e02-3d5f-4112-807c-8b3f208fc74d.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=187&originWidth=314&size=76921&status=done&style=none&width=157)<br />	在os中，在分配内存的时候，对上述数组是通过以行位单位分配。逐行赋值局部性更好，在较短的时间内，CPU访问地址空间的时候，地址空间局限在一个较小的空间范围内。以列为单位，CPU跳转频繁，局部性差。<br />\n<br />**页式系统的不足**<br />\n\n- 页面划分无逻辑含义\n- 页的共享不灵活\n- 页内碎片\n\n\n\n<a name=\"84ab8ae2\"></a>\n#### 段式和段页式虚拟存储\n\n<br />**段式存储管理**<br />\n\n- **进程分段**：把进程按**逻辑意义**划分为多个**段**，每段有**段名**，长度不定。进程有**多段**组成。\n   - 例：一个具有代码段、数据段、堆栈段的进程\n   - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576222175-eb440a68-d51b-46cc-b5f9-0f79cd7fbaea.png#align=left&display=inline&height=77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=153&originWidth=300&size=8209&status=done&style=none&width=150)\n- **段式内存管理系统的内存分配**\n   - 以**段**为单位装入，每段分配连续的内存\n   - 但是段和段不要求相邻\n- **段式系统的虚拟地址**\n   - 段式虚拟地址**VA**包括**段号S**和**段内偏移W**\n   - VA:(S,W)\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576231667-8ff29678-ab87-40fe-b98b-59223197e429.png#align=left&display=inline&height=25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=50&originWidth=428&size=8235&status=done&style=none&width=214)<br />**段式地址的映射机制**<br />\n\n- **段表**（SMT)\n   - 记录每段在内存中映射的位置\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576253158-18d351db-e7e4-4227-92f2-e9e2d6041c7a.png#align=left&display=inline&height=63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=125&originWidth=153&size=8385&status=done&style=none&width=76.5)\n\n   - 段号S：段的唯一编号（唯一的）\n   - 段长L：该段的长度\n   - 基地址B：该段在内存中的首地址\n\n\n<br />**段式地址的映射过程**<br />\n\n- 段式地址的映射过程\n   1. 由逻辑地址VA分离出（**S,W**)\n   2. 查询段表：检索段号S，查询该段**基地址B**和**长度L**\n   3. 物理地址**MA=B+W**\n- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576267324-9458b994-acd3-43c6-a2f7-5eb4b19ab0f2.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=505&size=33173&status=done&style=none&width=252.5)\n- **段表的扩充**\n   - 基本字段：段号，长度，基址\n   - 扩展字段：中间位，访问位，修改位，R/W/X\n   - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576277499-ea4684af-8bfa-48c6-ab7c-d6582db5cbbc.png#align=left&display=inline&height=69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=137&originWidth=483&size=13983&status=done&style=none&width=241.5)\n- **段的共享**\n   - 共享段在内存中只有一份存储\n   - 共享段被多个进程映射到各自段表\n   - 需要共享的模块都可以设置为单独的段\n- **段式系统的缺点**\n   - 段需要连续的存储空间\n   - 段的最大尺寸受到内存大小的限制\n   - 在辅存中管理可变尺寸的段比较困难\n\n\n<br />**段式系统VS页式系统**<br />\n\n- **地址空间**的区别\n   - 页式系统：一维地址空间\n   - 段式系统：二维地址空间\n- **段和页**的区别\n   - 段长可变；页面的大小固定\n   - 段的划分有意义；页面无意义\n   - 段方便共享；页面不方便共享\n   - 段用户可见；页面用户不可见\n   - 段偏移有溢出；页面偏移无溢出\n\n\n<br />**段页式存储管理**<br />\n\n- **在段式存储管理中结合页式存储管理技术**\n- **在段中划分页面**\n\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576296626-0b006ae9-f3f5-4047-ad99-b942d3474158.png#align=left&display=inline&height=91&margin=%5Bobject%20Object%5D&name=image.png&originHeight=181&originWidth=369&size=12779&status=done&style=none&width=184.5)**\n\n- 段页式系统的地址构成：**段号，页号，页内偏移**\n\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576309363-b978be31-a51a-4a13-be76-a19f43046fc2.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=385&size=33203&status=done&style=none&width=192.5)**\n\n- **段页式地址的映射机构**\n   - 同时采用**段表**和**页表**实现地址映射\n      - 系统为每一个进程建立一个**段表**\n      - 系统为每个段建立一个**页表**\n      - 段表给出每段的**页表基地**址及**页表长度（段长）**\n      - 页表给出每页对应的**页框**\n\n\n<br />**段页式地址映射：VA(S, W) –> (S, P, W) —> MA**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576319195-11f362d2-5301-4254-960f-62cf7fe70d58.png#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&name=image.png&originHeight=284&originWidth=437&size=42554&status=done&style=none&width=218.5)<br />\n\n<a name=\"1ba08af0\"></a>\n## 第八章 设备管理\n\n\n<a name=\"1e1dd735\"></a>\n### 设备管理的概念\n\n<br />**分类**<br />\n\n1. **按交互对象分类**\n   - 人机交互设备：显示设备、键盘、鼠标、打印机\n   - 与CPU等交互的设备：磁盘、磁带、传感器、控制器\n   - 计算机间的通信设备：网卡、调制解调器\n2. **按交互方向分类**\n   - 输入设备：键盘、扫描仪\n   - 输出设备：显示设备、打印机\n   - 双向设备：输入/输出：硬盘、软盘、网卡\n3. **按外设特性分类**\n   - 使用特征：存储、输入/输出\n   - 数据传输率：低速（如键盘）、中速（如打印机）、高速（如网卡、磁盘）\n   - 信息组织特征：字符设备（如打印机，以字节为单位传输）、块设备（如磁盘，以块为单位传输数据）、网络设备\n\n\n<br />**键盘要点：**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576331731-bddfdfe0-8246-4470-b2f9-c7be3644bda2.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=481&originWidth=590&size=131970&status=done&style=none&width=295)<br />\n<br />ROM:存储按键字符码（ASCII）<br />\n<br />计算器：扫描键盘得到位置码<br />\n<br />按键按下时停止计数并产生中断请求，CPU读字符码<br />\n<br />**设备管理的主要功能：**<br />\n\n- **设备分配**\n   - 设备分配功能是设备管理的**基本任务**\n   - 设备分配程序按照一定的**策略**，为申请的进程分配设备，记录设备的使用情况。\n- **设备映射**\n   - **物理设备**\n      - I/O系统中实际安装的设备\n      - 物理名：ID或字符串\n   - **逻辑设备**\n      - 应用软件使用的设备\n      - 逻辑名：友好名（Friendly Name）\n   - 设备映射**功能**\n      - 设备管理模块将逻辑设备映射到物理设备的功能\n      - 从应用软件的角度看，逻辑设备是一类物理设备的抽象\n      - 从设备管理程序的角度看，物理设备是逻辑设备的实例\n\n\n**设备独立性：**\n\n   - 物理设备对用户透明，用户使用统一规范的方式使用设备\n   - 用户编程时使用设备逻辑名，由系统实现逻辑设备的物理设备的转换\n- **设备驱动**\n   - 对物理设备进行**控制**，实现I/0操作：IN/OUT\n   - 接收应用的服务请求(例如读/写命令)，转换为具体的I/O指令，控制设备完成相关操作\n   - 向用户提供统一接口\n      - read/wirte/open…\n      - 把外设作为特别文件处理\n\n\n**设备驱动程序的特点**\n\n   - 设备驱动程序与硬件密切相关\n   - 每类设备都要配置特定的驱动程序\n   - 驱动程序一般由设备厂商根据操作系统要求编写\n   - 操作系统仅对设备驱动的接口提出要求\n\n\n<br />**I/O设备与CPU之间的数据传送方式**<br />\n\n- 查询控制方式：<br />CPU通过程序主动读取[状态寄存器](https://www.baidu.com/s?wd=%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)以了解接口情况，并完成相应的数据操作。查询操作需要在[时钟周期](https://www.baidu.com/s?wd=%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)较少的间隔内重复进行，因而CPU效率低。\n- 中断控制方式：<br />当程序常规运行中，若外部有优先级更高的事件出现，则通过[中断请求](https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)通知CPU，CPU再读取[状态寄存器](https://www.baidu.com/s?wd=%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)确定事件的种类，以便执行不同的分支处理。这种方式CPU效率高且实时性好。\n- DMA（Direct Memory Access）控制方式：<br />顾名思义，直接内存存取即数据传送的具体过程直接由硬件（[DMA控制器](https://www.baidu.com/s?wd=DMA%E6%8E%A7%E5%88%B6%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)）在内存和IO之间完成，CPU只在开始时将控制权暂时交予DMA，直到数据传输结束。这种方式传送速度比通过CPU快，尤其是在批量传送时效率很高。\n- 通道控制方式：<br />基本方法同上述的DMA控制方式，只是DMA通过[DMA控制器](https://www.baidu.com/s?wd=DMA%E6%8E%A7%E5%88%B6%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)完成，通道控制方式有专门通讯传输的通道总线完成。效率比DMA更高。1、查询控制方式：<br />CPU通过程序主动读取[状态寄存器](https://www.baidu.com/s?wd=%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)以了解接口情况，并完成相应的数据操作。查询操作需要在[时钟周期](https://www.baidu.com/s?wd=%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)较少的间隔内重复进行，因而CPU效率低。\n\n\n\n<a name=\"b2a8a9b2\"></a>\n### spooling系统\n\n<br />**设备分配方法**<br />\n\n- 独占设备的分配\n- 共享设备的分配\n- 虚拟分配\n\n\n<br />**独占型设备VS共享型设备**<br />\n\n- **独占型设备包括所有的字符型设备。**\n   - 任意时间段内最多只能被一个进程占用。\n   - 使用时，进程首先向系统申请，可能进入阻塞状态\n      - 当设备可用时，唤醒一个等待进程\n      - 使用完毕以后，进程必须释放设备\n- **共享型设备包括所有块型设备**\n   - I/0传输单位：块\n   - 宏观上一个共享型设备可以被多个进程同时占用(硬盘)\n   - 微观上多个进程交替使用同一设备\n   - 进程使用这类设备时，无需申请或释放设备，也不存在某个进程占用设备的问题\n\n\n<br />**独占型设备的分配**<br />\n<br />**进程使用独占设备的过程：申请--使用--释放**<br />\n\n- 进程申请设备\n- 系统分配设备\n- 进程发送使用命令\n- 系统将转到设备驱动模块完成一次I/O传输\n- 进程释放设备\n- 系统回收设备\n\n\n<br />**从进程申请成功,直到释放用完之前,独占设备**<br />\n<br />**共享型设备的分配**<br />\n\n- 进程使用共享型设备**不需要申请**，当然也就不存在占用或释放设备的问题\n- 但是，I/O期间只能有一个进程使用设备。因此，进程使用共享型设备之前，有一个隐含的申请命令；使用完毕后，有一个隐含的释放命令，以实现一次基本I/O传输期间的排它性，保证操作的正常进行\n- 使用共享型设备的过程中，进程完全有可能进入阻塞等待状态\n\n\n<br />**虚拟分配**<br />\n\n- **虚拟技术**\n   - 在一类物理设备上模拟另一类物理设备技术：借助辅存部分区域模拟独占设备（键盘、鼠标），将独占设备转化为共享设备\n- **虚拟设备**\n   - 用来模拟独占设备的部分辅存称为虚拟设备，虚拟独占设备\n   - 输入井：模拟输入设备的辅存区域\n   - 输出井：模拟输出设备的辅存区域\n- **虚拟分配**\n   - 当进程需要与独占设备交换信息时，就采用虚拟技术将与该独占设备所对应的虚拟设备（部分辅存）分配给它。\n   - SPOOLing系统是虚拟技术和虚拟分配的实现\n      - Simultaneaus Periphernal OPERATIONS OnLine\n      - 外部设备同时联机操作【假脱机输入/输出操作】\n\n\n<br />**SPOOLing的结构**<br />\n<br />**例子：**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576346112-9d2d63a0-efac-484c-8751-8bba2f7c31d6.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=453&size=94331&status=done&style=none&width=226.5)<br />\n<br />结构：<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576354105-6084f540-cf3f-4bd5-b7a7-84ad6e034b9b.png#align=left&display=inline&height=128&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=474&size=62311&status=done&style=none&width=237)<br />\n\n- **输入井和输出井**\n- 磁盘上开辟了两个存储区域\n   - 输入井模拟脱机输入时的磁盘\n   - 输出井模拟脱机输出时的磁盘\n- **输入缓冲区和输出缓冲区**\n- 内存中开辟的存储区域\n   - 输入缓冲区：暂存输入数据，以后再传送到输入井\n   - 输出缓冲区：暂存输出数据，以后再传送到输出设备\n- **输入监控进程和输出监控进程**\n   - 输入监控进程模拟脱机输入的卫星机，将用户要求的数据从输入设备通过输入缓冲区再传送输入井。当用户进程需要数据时，直接从输入井读入所需数据\n   - 输出监控进程模拟脱机输出的卫星机，用户进程将输出数据从内存先传送到输出井，当输出设备空闲时，再将输出井的数据传送到输出设备上\n\n\n<br />**SPOOLing系统原理小结**<br />\n\n- 任务执行前：预先将程序和数据输入到输入井中\n- 任务运行时：使用数据时，从输入井中取出\n- 任务运行时：输出数据时，把数据写入输出井。\n- 任务运行完：外设空闲时输出全部数据和信息\n\n\n<br />**SPOOLing系统原理小结**<br />\n\n- “提高”了I/O速度\n- 将独占设备改造为“共享”设备\n   - 实现了虚拟设备功能\n\n\n\n<a name=\"14f4bf60\"></a>\n## 第九章 文件系统\n\n\n<a name=\"f6e42392\"></a>\n### 文件系统的概念\n\n<br />**文件的定义**：文件是计算机信息存取的一种重要组织形式。<br />\n\n- 文件由若干**信息项**有序构成。\n   - 信息项可以是**字节**，也可以是**结构化数据**（记录）。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576373176-9a7c52e8-0912-4dc0-94c3-fc1d8a2dff9c.png#align=left&display=inline&height=29&margin=%5Bobject%20Object%5D&name=image.png&originHeight=58&originWidth=404&size=18261&status=done&style=none&width=202)\n\n- 用户通过**读写指针**来读取文件的信息项\n- 文件具有**文件名**，用户通过文件名存取文件\n\n\n<br />**文件的分类**<br />\n\n- 分类标准1：**文件的用途**\n   - 系统文件\n   - 库文件\n   - 用户文件\n- 分类标准2：**文件的操作权限**\n   - 只读文件\n   - 读写文件\n   - 不保护文件\n- 分类标准3：**文件的性质**\n   - 普通文件\n   - **目录文件**：记录目录里面**文件列表信息**。\n      - 文件名、文件存放地址、文件属性…..\n   - 设备文件：把设备作为文件管理和使用（用文件的接口来存储设备）\n\n\n<br />**文件的属性**<br />\n\n- **指定文件的类型、操作特性和存取保护等一组信息**\n- 文件属性存放在文件所在目录的**目录文件**中（而不是存放在文件本身）\n- MS-DOS系统中，文件属性占目录项的一个字节\n   - 0000000**1**：只读属性\n   - 000000**1**0：隐藏属性\n\n\n<br />**文件系统**<br />\n\n- **定义**：负责管理文件的机构称为文件系统\n- **功能：**负责文件的创立、撤销、读写、修改、复制和存取控制等，并管理存放文件的存储设备。\n- **文件系统的目标是让用户以文件名来存取文件**\n\n\n<br />**文件的结构**<br />\n\n- **逻辑结构**\n   - 用户的观点\n   - 为用户提供逻辑结构清晰、使用方便的文件\n   - 强调文件信息项的构成方式和用户的存取方式。\n- **物理结构**\n   - 系统的观点\n   - 文件在存储设备（例：硬盘）上的存储结构\n   - 强调合理利用存储空间，缩短I/O存取时间\n\n\n<br />**文件的逻辑结构**<br />\n\n- **记录式文件**\n   - 信息项是记录：结构化数据\n      - 学生花名册文件：包含若干个学生记录\n      - 每条学生记录：姓名、学号、性别、籍贯、成绩\n      - 文件中是要保存记录长度和数量等说明信息\n      - 浪费存储空间\n- **流式文件**\n   - 信息项是字节，文件长度就是字节的数量\n   - 优点：文件无需额外的说明信息或控制信息，节省存储空间\n\n\n<br />**现代操作系统中文件都是流式文件，由应用程序解释和处理文件。**<br />\n<br />**文件存取方法**<br />\n\n- **顺序存取**\n   - **按文件信息项排列顺序依次存取**\n   - **读写指针**：文件打开时，读写指针指向第1个信息项（字节或记录；每存取一个信息项，读写指针自动加一而指向下一个信息项\n- **随机存取**\n   - **概念**：直接存取，存取操作时指定存取的位置\n   - **特点**：\n      - 对**流式文件或记录为定长的记录式文件**容易确定存取位置\n      - 对记录**不定长**的记录式文件比较定位较麻烦\n         - 从第1条记录开始查询，直到找到要存取的记录为止\n         - **建立索引**\n            - 索引可作为文件一部分也可以单独建立索引文件。\n\n\n<br />**文件读写示例（利用读写指针）**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576386795-c2be7d34-225a-404c-b236-61727877db66.png#align=left&display=inline&height=120&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=452&size=109268&status=done&style=none&width=226)<br />\n\n<a name=\"bd5dd042\"></a>\n### 文件的物理结构\n\n<br />**概念**<br />\n\n- 文件物理结构设置文件在**存储设备**（例：硬盘）的存储方式\n- 强调合理利用存储空间，并缩短I/O存取时间\n\n\n<br />**类型**<br />\n\n- **连续文件**\n   - **概念：**文件按逻辑块的顺序存放在硬盘**连续的**物理存储块中。**文件目录**记录文件长度（块数）和第1个存储块的块号\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576403263-b3925b99-e2f0-46ab-9344-ac4812d44241.png#align=left&display=inline&height=67&margin=%5Bobject%20Object%5D&name=image.png&originHeight=133&originWidth=308&size=13377&status=done&style=none&width=154)\n\n   - **特点**：文件建立时给出文件最大长度并登记文件起始位置\n   - **优点**：简单、支持**顺序存取和随机存取**、顺序存取速度快，所需磁盘寻道次数和寻道时间最少\n   - **缺点**：文件不易动态增长（预留空间：浪费，重新分配和移动）；不利于文件插入和删除；外部碎片问题(一个很大的文件，可能找不到一个连续的数量足够多的存储块来存储这个文件)\n- **索引文件**\n   - **概念**：文件存放在**不连续**的存储块中。建立**索引表**记录文件逻辑块和物理块的对应关系。**索引表单独放在存储块中**。\n   - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576416373-506607f5-b92b-4bc0-8803-1da629182bc7.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=473&size=75516&status=done&style=none&width=236.5)\n   - **特点**：文件=索引区+数据区；先访问索引，再访问数据；**支持顺序存取和随机存取**；支持文件动态增长、插入、删除\n- **串联文件**\n   - **概念**：文件存放在**不连续**的存储块中。（每个存储块有一个指针next，指向文件下一个存储块；**文件目录**：指明文件名和第1个存储块的块号）\n   - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576425829-2d31e5be-af28-4009-8773-6a0b9c24f966.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=143&originWidth=640&size=67888&status=done&style=none&width=320)\n   - **特点**：适用于**顺序存取**，随机存取较为困难。提高了磁盘空间利用率，不存在外部碎片问题。有利于文件动态扩充、插入和删除。\n   - **缺点**：存取速度慢，不适用于随机存取。可靠性问题：若next指针出错，则文件访问失败。next指针占用一定的空间。\n   - **应用**：FAT文件系统\n\n\n\n<a name=\"881ee3cf\"></a>\n### FAT文件系统\n\n<br />FAT: File Allocation Table<br />\n<br />FAT文件系统：<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576435909-9376be5d-a169-4e01-9f1f-16465ad790ad.png#align=left&display=inline&height=77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=578&size=16149&status=done&style=none&width=289)<br />\n<br />**文件分配表（FAT）**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576443481-f9e0eb9a-5a26-4e05-a455-1b2e3e514326.png#align=left&display=inline&height=128&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=503&size=79728&status=done&style=none&width=251.5)<br />\n<br />串联文件：存储块next域指向下个存储块<br />\n<br />**FAT: **将next有序集中放到FAT表中<br />\n<br />**文件访问过程：**<br />\n\n- 访问**文件目录**：找0块的块号i\n- 访问**FAT**，找到下一块的块号**FAT(i)**  (i是当前块的块号）\n- **FAT(i) =FFFF 文件结束**\n\n\n<br />文件分配表的**缺点:**<br />\n\n- 读文件时,先读FAT，影响使用效率\n- FAT要占用存储空间：存储容量越大，**存储块越多**，FAT元素越多。且元素位宽越长（因为每个元素里面要记录这个存储块的序号），占用更多额外存储空间。\n- 若存储块有**2**块，FAT有**2**个元素，每项至少需要**N**位的宽度\n\n\n<br />**FAT文件系统**<br />\n\n- **扇区**\n   - 磁盘上**最小可寻址存储单元**（512字节）\n- **簇(cluster)**  =  存储块\n   - 设备的**最小存取单元**，固定数量的扇区\n- **簇的例子**\n   - 360KB磁盘：簇=2个扇区（1024字节）\n   - 10MB硬盘：簇=8个扇区（4096字节）\n   - 2GB硬盘：簇=64个扇区（32KB）\n- **FAT元素数目和簇的数目一样多**   假如簇数=2\n   - FAT元素宽度至少应为N才能标识全部的簇\n   - N=8位：能标识2=256个簇  —- FAT8\n   - N=12位：能标识2=4096个簇  ---- FAT12\n   - N=16位：能标识2=64K个簇 ---- FAT16系统\n   - …\n- **磁盘容量=FAT长度_簇容量=FAT长度_簇扇区数_512字节_\n   - 若N=16，簇扇区数=64\n      - 磁盘容量=2簇x64扇区x512字节=2GB\n      - N越大，能标识越多的簇，能支持的磁盘容量越大。\n\n\n<br />**FAT16文件系统**<br />\n\n- 以簇为单位管理磁盘\n- 簇是扇区的倍数，是2的次幂，最大64扇区（扇区512B，簇32KB(64个扇区)）\n- FAT表元素宽度2字节，即16Bit\n- 每簇最大64扇区：磁盘分区最大=2G\n- FAT16格式化的硬盘\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576461910-929708a7-c54e-4311-bd9a-53a170c0a918.png#align=left&display=inline&height=28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=352&size=10303&status=done&style=none&width=176)\n\n- FAT16最大分区大小与对应簇大小\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576469387-b93bf95e-4d9b-4e74-84fe-dc2911b98525.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=158&originWidth=315&size=49149&status=done&style=none&width=157.5)\n<a name=\"06547336\"></a>\n### 文件存储和目录\n\n<br />**存储空间管理**<br />\n\n- **功能**：记录磁盘使用情况，管理和分配、回收存储空间。\n- **记录磁盘空闲块的方法：**\n   - **空闲文件目录**<br />**空闲文件**：把连续空闲区看成一个特殊文件，由多个连续空闲块组成<br />**空闲文件目录：**\n      - 所有空闲文件代表存储设备全部空闲空间\n      - 为空闲空间建立的专门目录：**空闲文件目录**\n      - 每个表项对应一个空闲文件，包括第1个空闲块号，空闲块个数等信息\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576480634-9a82a057-630c-49b1-91fa-a473253c14e1.png#align=left&display=inline&height=108&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=564&size=46413&status=done&style=none&width=282)\n\n   - **空闲块链**<br />把所有空闲块链接在一起<br />当申请者需要空闲块时，链头开始搜索所需空闲块<br />当回收空闲块时，把释放的空闲块逐个加在链尾\n   - **位示图**<br />从**内存中**划出若干个字节，每个bit代表1个存储块空闲或占用状态<br />\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576491590-19b286ca-8482-4b97-83a5-896737811061.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=177&originWidth=515&size=47164&status=done&style=none&width=257.5)<br />**文件目录管理**<br />\n\n- **文件目录**\n   - 文件名址录，记录文件名和存放地址的目录表\n   - 具有将文件名**转换**为外存物理位置的功能\n   - **文件属性也记录在目录中**\n- **目录文件**\n- 文件目录以文件形式存于外存，这个文件叫目录文件\n- **目录结构**\n   - 不同的系统，文件目录的组织也不完全相同\n   - DOS系统（32字节）\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576503658-759ba3d1-2f3c-413b-9481-042a3b4d8555.png#align=left&display=inline&height=38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=76&originWidth=361&size=10639&status=done&style=none&width=180.5)\n\n   - Unix\n      - 索引节点\n      - 文件目录项中的文件名和其他属性信息分开。后者单独组成一个定长数据结构：索引节点**i_node**\n- **目录结构**\n   - 单级目录\n   - 二级目录\n   - 多级目录（树形目录）【现代操作系统基本采用】\n\n\n<br />**文件全名和路径**<br />\n\n- **文件的全名**\n- 包括从根目录开始到文件为止的通路上所有子目录路径\n- 子目录之间用正斜线“/”或反斜线“\\”隔开\n- 子目录名组成的部分又称路径名\n- **每个文件都有唯一的路径名**\n- **两种路径名形式**\n- 绝对路径名：从根目录直到指定的文件\n- 相对路径名：从当前目录直到指定的文件\n\n\n<br />**Linux文件目录**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576513534-835e3844-20c0-4b58-ad71-15913922677d.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=242&size=15696&status=done&style=none&width=121)<br />\n<br />**文件的保护**<br />\n\n- **对文件的访问系统首先要检查访问权限**\n   - 仅允许执行（E）。\n   - 仅允许读（R）\n   - 仅允许写（W）\n   - 仅允许在文件尾写（A）\n   - 仅允许对文件进行修改（U）\n   - 允许改变文件的存取枚限（C)\n   - 允许取消文件（D)\n   - 权限可进行适当的组合。\n\n\n<br />**文件和目录操作**<br />\n\n- **文件操作**：创建、读、写文件，文件定位，删除文件，截断文件，属性设置和读取\n- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/351491/1592576521707-5ce16255-a0f5-4723-ad39-1a85d0b7f285.png#align=left&display=inline&height=139&margin=%5Bobject%20Object%5D&name=image.png&originHeight=278&originWidth=179&size=25836&status=done&style=none&width=89.5)\n\n\n\n- **目录操作**：创建目录，删除目录\n- **典型的文件系统**：FAT16，FAT32，NTFS，EXT2，EXT3，EXT4……\n', '操作系统', 1592841600, 30);
INSERT INTO `article` VALUES (11, 3, 'node基础', '# 前置浏览器知识\n\n## 浏览器内核（渲染引擎）介绍\n\n**浏览器的组成**\n\n- 人机交互部分（UI）\n- 网络请求部分（Socket）【接收服务器返回数据的功能】\n- Javascript引擎部分（解析执行JavaScript）【Chrome V8引擎】\n- 渲染引擎部分（渲染HTML、CSS）等【解释执行CSS、HTML】\n- 数据存储部分（cookie、HTML5中的本地存储LocalStorage、SessionStorage）\n\n**主流渲染引擎**\n\n1. 渲染引擎 又叫 排版引擎 或 浏览器内核\n2. 主流的 渲染引擎 有\n   - **Chrome浏览器**：Blink引擎（WebKit的一个分支）\n   - **Safari浏览器**：WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发windows版的safari\n   - **FireFox浏览器**：Blink引擎（早期版使用Persto引擎）\n   - **Internet Explorer浏览器**：Trident引擎\n   - **Microsoft Edge浏览器**：EdgeHTML引擎（Trident的一个分支）\n3. **工作原理**\n\n## 浏览器渲染引擎工作原理\n\n**工作原理**\n\n* 解析HTML构建**DOM树**（Document Object Model，文档对象模型），DOM是W3C组织推荐的处理可拓展置标语言的标准编程接口。\n* 构建“**渲染树**”，“渲染树”并不等同于“DOM 树”，因为像 `head`标签或`display:none`这样的元素就没有必要放到“渲染树”中了，但他们在“DOM 树”中。\n* 对“渲染树”进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫**`layout`或`reflow`**。\n* 绘制“渲染树”，调用操作系统底层API进行**绘图操作**。\n\n**原理示意图**\n\n​	![image-20200611225238071](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611225238071.png)\n\n**WebKit工作原理（Chrome,Safari,Opera)**\n\n![image-20200611225324822](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611225324822.png)\n\n**Gecko工作原理（FireFox)**\n\n<img src=\"C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611225457844.png\" alt=\"image-20200611225457844\"  />\n\n## 浏览器 reflow 和 layout 过程\n\n**假设一个空网页，有一个按钮和div标签，希望点击按钮添加50个文本框到div中，怎么做？**\n\n- ​	错误的做法：循环创建文本框，每创建一个就添加到div中。这种做法可能导致每添加一个就会导致reflow一次，这种做法有极大的性能问题。\n- ​	正确的做法：点击按钮，先创建50个文本框加到一个地方（文本片段，document fragment），然后一次性加到div里面，这样只reflow一次。\n\n**[视频演示](https://www.youtube.com/watch?v=ZTnlxlA5KGw)**\n\n**可以在浏览器看渲染过程**\n\n<img src=\"C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611230541238.png\" alt=\"image-20200611230541238\" style=\"zoom: 67%;\" />\n\n<img src=\"C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611230621962.png\" alt=\"image-20200611230621962\" style=\"zoom: 67%;\" />\n\n## 浏览器访问服务器过程\n\n1. 在浏览器地址栏中输入网址\n\n   ![image-20200611231048541](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611231048541.png)\n\n2. 浏览器通过用户在地址栏中输入的URL构建HTTP请求报文\n\n   ![image-20200611231340514](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611231340514.png)\n\n3. 浏览器发起DNS解析请求，将域名转为IP地址\n\n   ![image-20200611231252871](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611231252871.png)\n\n4. 浏览器将请求报文发送给服务器。\n\n5. 服务器接收请求报文，并解析。\n\n6. 服务器处理用户请求，并将处理结果封装成HTTP响应报文\n\n   ![image-20200611231603713](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611231603713.png)\n\n7. 服务器将HTTP响应报文发送给浏览器。\n\n8. 浏览器接收服务器响应的HTTP报文，并解析。\n\n9. 浏览器解析HTML页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。\n\n10. 最终浏览器展示出了页面。\n\n## HTTP请求报文和响应报文格式\n\n![image-20200611231850980](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611231850980.png)\n\n1. 请求行（请求方法，请求路径，请求所使用的HTTP协议）或响应行（服务器使用的http协议版本，服务器返回的http状态码，状态码对应的响应消息）\n2. 请求报文头 或  http响应报文头 \n3. 空一行\n4. 请求报文体（get请求无请求报文体）或 响应报文体\n\n## Web开发本质\n\n**牢记三点**\n\n* 请求，客户端发送请求\n* 处理，服务器处理请求\n* 响应，服务器将处理结果发送给客户端\n\n**客户端处理响应**\n\n* 服务器响应完毕后，客户端继续处理\n  * 浏览器：解析服务器返回的数据\n  * IOS、Android客户端：解析服务器返回的数据，并通过IOS或Android的UI技术实现页面的展示功能\n\n**关于 C/S（Client/Server）和 B/S （Browser/Server）**\n\nC/S：客户端服务器\n\nB/S：浏览器服务器\n\n![image-20200611233246296](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611233246296.png)\n\n# Node 基础\n\n## Node.js 简介\n\n- Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境\n- Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效\n- Node.js 的包管理器 npm，是全球最大的开源库生态系统\n- javascript 是脚本语言，需要解析器才能执行，浏览器就充当了解析器\n- 在Chrome中，解析器就是 V8 引擎，将 javascript 转换成 机器码\n- V8 引擎是开源的，由 C++ 语言编写，性能高\n- Node.js 高性能，事件驱动，非阻塞，生态圈很好\n\n## REPL介绍\n\n1. REPL 全称：Read-Eval-Print-Loop （交互式解释器）\n  - R 读取 - 获取用户输入，解析输入了JavaScript数据结构并存储在内存中。\n  - E 执行 - 执行输入的数据结构。\n  - P 打印 - 输出结果。\n  - L 循环 - 循环操作以上步骤直到用户两次按下 ctrl+c 按钮退出。\n\n2. 在 REPL 中编写程序（类似浏览器开发人员工具中的控制台功能）\n  - 直接在控制台输入 `node` 命令进入 REPL 环境\n\n3. 按两次 Control+C 退出 REPL 界面 或者 输入 `.exit` 退出 REPL 界面\n\n## node.js单线程-非阻塞IO解释\n\n![image-20200611142039934](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611142039934.png)\n\n> the callstack: one thread == one call stack == one thing at a time\n\n演示：http://latentflip.com/loupe\n\n## 事件 events\n\n- 多数 Node.js 核心 API 都采用异步事件驱动架构\n- 所有能触发事件的对象都是 EventEmitter 类的实例\n- 事件名称通常是驼峰式的字符串\n- 继承了EventEmitter 类的类的实例也可以使用on，emit等api\n- 实践代码\n\n```javascript\nvar events = require(\'events\')\n\n// 事件 对象\nvar myEmitter = new events.EventEmitter()\n\n// 绑定 事件名称 和 回调函数\nmyEmitter.on(\'someEvent\', function (message) {\n    console.log(message)\n})\n\n// 触发实践，使用事件名称\nmyEmitter.emit(\'someEvent\', \'The event was emitted\')\n```\n\n## 文件\n\n**同步文件读写**：同步读写文件，顺序执行，如果读取时间很长，会阻塞进程\n\n```javascript\nvar fs = require(\'fs\')\n\nvar readMe = fs.readFileSync(\'readMe.txt\', \'utf8\')\nfs.writeFileSync(\'writeMe.txt\', readMe)\n\nconsole.log(readMe)\nconsole.log(\'finished sync\')\n```\n\n**异步文件读写**：异步事件，Nodejs 维护一个事件队列，注册事件，完成后执行主线程。当主线程空闲时，取出执行事件，从线程池中发起线程执行事件， 当事件执行完成后通知主线程。这就是异步高效的原因。\n\n```javascript\nvar fs = require(\'fs\')\n\nvar filename = __dirname + \'\\\\\' +\'hello.txt\' //此处拼接路径的方法并不好\n\nvar msg = \'Hello World!\'\n//写文件\nfs.writeFile(filename, msg, \'utf8\', (err)=>{\n	if(err)console.log(err);\n	else console.log(\'ok\')\n})\n//读文件\nfs.readFile(\'./hello.txt\',\'utf8\',(err,data)=>{//若不传utf8,data为buffer类型\n    if(err) throw err\n    console.log(data)\n})\n\n```\n\n注意：`./hello.txt`此处的`./`相对路径，相对的是执行 node 命令的路径\n\n解决方法：`__dirname`（表示当前正在执行的 js文件所在的目录）；`__filename`（表示当前正在执行的 js 文件的完整路径）\n\n`__dirname`和`__filename`不是全局变量\n\n**创建文件目录**\n\n```js\nvar fs = require(\'fs\')\nfs.mkdir(\'./test\', (err)=>{\n    if(err) throw err\n    console.log(\'ok\')\n})\n```\n\n**try-catch的使用**\n\n`try-catch`只能捕获同步异常，不能捕获异步异常。对于异步操作，要通过错误号（err.code) 来进行错误处理\n\n```javascript\nvar fs = require(\'fs\')\ntry{\n   fs.writeFile(\'./dd/abc.txt\',\'大家好\', \'utf8\', (err)=>{ //当前目录下没有dd这个目录，但是还是输出了ok，try-catch并未捕获到异常\n        console.log(\'ok\')\n    }) \n}catch(e){\n    console.log(\'出错了\'+e)\n}\n```\n\n## 路径拼接（path模块）\n\n```javascript\nvar path = require(\'path\')\nvar filename = path.join(__dirname, \'hello./txt\')\n```\n\n## 流和管道\n\n一个简单的例子体验流：ls输出的流，作为grep app 的输入\n\n<img src=\"C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611190420312.png\" alt=\"image-20200611190420312\" style=\"zoom:67%;\" />\n\n- 流（stream）\n  - 处理流式数据的抽象接口\n  - stream 模块提供了一些基础的 API，用于构建实现了流接口的对象\n  - 流可以是可读的、可写的、或是可读写的，所有的流都是 EventEmitter 的实例\n  - 流处理数据通过缓存可以提高性能\n  - 所有的流都是EventEmitter的实例。\n  - 作用：处理数据；提高性能。\n- 管道\n  - 使用管道，代码量更少\n  - myReadStream.pipe(myWriteStream)\n\n示例：\n\n```javascript\nvar fs = require(\'fs\')\n// 创建一个读的流，输入流，相当于读文件\nvar myReadStream = fs.createReadStream(__dirname + \'/readMe.txt\')\nmyReadStream.setEncoding(\'utf8\')\n// 创建一个写的流，相当于写文件\nvar myWriteStream = fs.createWriteStream(__dirname + \'/writeMe.txt\')\n\nvar data = \'\'\nmyReadStrem.setEncoding(\'utf8\')\n\n// 接收数据的时候使用 data\nmyReadStream.on(\'data\', function (chunk) {\n    console.log(chunk)//chunk是一段一段的，不是整个文件一下读进去\n    //data+=chunk\n    myWriteStream.write(chunk)//写文件\n})\n//接收完数据后，使用end这个监听函数\nmyReadStream.on(\'end\', function () {\n    console.log(data)\n})\n\nvar writeData = \'hello world\'\nmyWriteStream.write(writeData)\nmyWriteStream.end()\nmyWriteStream.on(\'finish\', function () {\n    console.log(\'finished\')\n})\n\n// 使用管道，代码量更少\nmyReadStream.pipe(myWriteStream)\n//将读的流的输出作为写的流的输入\n\n\n// 或者\n// var data = []\n// data.push(chunk)\n// data = Buffer.concat(data).toString()\n```\n\n\n\n## http服务程序（http模块)\n\n### 一个简单的示例\n\n```javascript\n// 1.创建一个http服务对象\nvar server = http.createServer()\n\n// 2.监听用户的请求事件（request事件）\n// request 对象包含了用户请求报文中的所有内容，通过 request 对象可以获得所有用户提交过来的数据\n// response 对象用来向用户响应一些数据，当服务器要向客户端响应请求数据的时候必须使用 response 对象\n// 有了 request 对象和 response 对象，就既可以获取用户提交的数据，也可以向用户响应数据了\nserver.on(\'request\',(req, res)=>{\n    //解决乱码的思路，服务器通过设置 http 响应报文头，告诉浏览器使用相应的编码来解析网页\n    res.setHeader(\'Content-Type\', \'text/plain; charset=utf-8\')\n    res.write(\'hello\')\n    //对于每一个请求，服务器必须结束响应，否则客户端（浏览器）会一直等待服务器响应\n    res.end()\n})\n\n// 3.启动服务\nserver.listen(8080, ()=>console.log(\'server running at http://localhost:8080\'))\n```\n\n**通过设置http响应报文头来解决浏览器显示html的问题**\n\n```javascript\nres.setHeader(\'Content-Type\', \'text/html; charset=utf-8\')\n```\n\n**响应json**\n\n```javascript\nvar myObj = {\n    name: \'able\',\n    job: \'programmer\',\n    age: 27\n}\nres.end(JSON.stringify(myObj))\n```\n\n\n\n### request 和 response对象\n\n**request 对象**\n\n- requset：服务器解析用户提交的 http 请求报文，将结果解析到 request 对象中。凡是要获取和用户请求相关的数据都可以通过request对象获取\n- request 对象类型 <http.IncomingMessage>，继承自stream.Readable\n- request 对象常用成员\n  - `request.headers`：请求报文头，返回的是一个对象，这个对象中包含了所有的请求报文头\n  - `request.rawHeaders`：请求报文头，返回的是一个数组，数组中保存的都是请求报文头的字符串\n  - `request.httpVersion`：获取客户端http协议版本号\n  - `request.method`：获取用户请求方法\n  - `request.url`：获取用户请求路径（不包含主机名称，端口号，协议）\n\n**response对象**\n\n- response： 在服务器端用来向用户作出响应的对象，凡是需要向用户（客户端）响应的操作，都需要通过 response 对象来进行。\n\n- response 对象类型 <http.ServerResponse>\n\n- response 对象常用成员\n\n  - `response.writeHead()`：直接向客户端响应（写入）http报文头，建议在res.write()和res.end()之前设置，可以用来代替res.statusCode，res.statusMessage，res.setHeader。如果不手动设置，系统也会自动调用。\n\n  - `response.setHeader()`：设置响应报文头，放在res.write()和res.end()之前设置\n\n  - `response.statusCode`：设置http响应状态码\n\n  - `response.statusMessage`：设置http响应状态码对应的消息\n\n  - `response.write(chunk[, encoding][, callback])`：写入数据。这里的编码不是说告诉浏览器用什么编码显示，而是说把data转为比如utf8编码表示的数据，然后发给浏览器。\n\n  - `response.end()`：结束响应（请求）：此方法向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成。必须在每个响应上调用此 response.end() 方法。res.end()要响应数据的话，数据必须是string或者Buffer类型\n\n  - ```javascript\n    req.setHeader(\'Content-Type\', \'text/plain; charset=utf-8\')\n    res.statusCode =404\n    res.statusMessage = \'Not Found\'\n    res.writeHead(404,\'Not Found\',{\n       \'Content-Type\':\'text/plain; charset=utf-8\'\n    })\n    res.write(\'hello, world!\', \'utf8\',()=>{})\n    res.end(\'over\')\n    ```\n\n\n\n### 根据不同请求做出不同响应\n\n**示例的一个问题**：比如当我们在浏览器中输入`http://localhost:8080/asf/asfdf/assf`，响应的内容还是 `hello`，即没有对不同的路径进行处理。\n\n```javascript\nvar http = require(\'http\')\nvar fs = require(\'fs\')\nvar path = require(\'path\')\n\nvar server = http.createServer((req,res)=>{\n    res.setHeader(\'Content-Type\', \'text/plain; charset=utf-8\')\n    // 通过 req.url 获取用户的请求路径，根据不同的请求路径服务器做出不同的响应\n    if(req.url === \'/\' || req.url === \'/index\'){\n        fs.readFile(path.join(__dirname, \'index.html\'),(err,data)=>{\n            if(err) throw err;\n            res.end(data)\n        })\n    } else if (req.url === \'/list\') {\n        res.writeHead(200, { \'Content-Type\': \'text/html\' })\n		fs.createReadStream(path.join(__dirname,\'list.html\')).pipe(res)//使用管道的方法\n    } else{\n        res.end(\'404 not Found!\')\n    }\n    res.end()\n}).listen(8080, () => console.log(\'server running at http://localhost:8080\'))\n```\n\n注意这个示例比上个示例精简的地方。\n\n**问题**：当我们请求的网页含有图片,引入了css等的时候，浏览器会再次对服务器发起请求，所以我们需要对图片进行处理。\n\n```javascript\n// 处理图片\nelse if(req.url === \'/4.jpg\'){\n   fs.readFile(path.join(__dirname, \'images\',\'4.jpg\'),(err,data)=>{\n   	res.setHeader(\'Content-Type\', \'application/x-jpg\')\n   	res.end(data)\n   })\n}\n\n// 处理css\nelse if(req.url === \'/css/css.index\'){\n   fs.readFile(path.join(__dirname, \'css\',\'index.css\'),(err,data)=>{\n   	res.setHeader(\'Content-Type\', \'text/css\')\n   	res.end(data)\n   })\n}\n```\n\n**问题**：要是一个网站要请求很多图片，为每一个图片写一个判断显然不现实！！！\n\n### 模拟Apache服务器\n\n```javascript\nvar http = require(\'http\')\nvar fs = require(\'fs\')\nvar path = require(\'path\')\nvar mime = require(\'mime\')  //要先npm install mime\n\nvar server = http.createServer((req,res)=>{\n    var publicPath = path.join(__dirname, \'public\')//假设我们的静态资源存放在public目录下\n    var filename = path.join(publicPath, req.url) //将请求路径与publicPath拼接\n\n    fs.readFile(filename, (err,data)=>{\n        if(err) {\n            res.end(\'文件不存在 404\')\n        } else {\n            // 因为不同的文件的Content-Type不同，所以可以通过第三方模块 mime ,来判断不同的资源对应的 Content-Type 类型\n            res.setHeader(\'Content-Type\', mime.getType(filename))\n            res.end(data)\n        }\n    })\n}).listen(8080, () => console.log(\'server running at http://localhost:8080\'))\n```\n\n可以看到，通过这样处理，就不用把每个静态资源文件单独处理了。也不需要对每个路径进行处理了。\n\n**注意**：对于服务器来说请求的url就是一个标识符。比如我们输入index.do，可能返回index.html，或者比如我们输入index.png，也可能返回index.html，返回什么内容完全取决于服务器。\n\n## NPM\n\n> NPM -- Node Package Manager -- Node 包管理\n>\n> npm 是Node.js默认的、以JavaScript编写的软件包管理器。\n>\n> [npm 官网](https://www.npmjs.com)\n>\n> [npm 官方文档](https://docs.npmjs.com)\n\n![image-20200611182058824](C:\\Users\\theon\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200611182058824.png)\n\n* 更新npm：`npm install npm@latest -g`\n\n* 生成package.json文件：`npm init -y`\n\n## package.json\n\n### package.json\n\n**package.json**：项目描述文件\n\n- 元数据：描述自身的信息\n\n**作用**：\n\n* package.json是一个包说明文件（项目描述文件），用来管理组织一个包（一个项目）\n* package.json文件是一个json格式的文件\n* 位于当前项目的根目录下\n\n**常见的项**\n\n* name：包的名字\n* version：包的版本\n* description：包描述\n* author：包作者\n* main：包的入口js文件，从main字段这里指定的那个js文件开始执行\n* dependencies：当前包依赖的其他包\n\n**创建**：`npm init`\n\n### package-lock.json\n\n保存了包的更多信息。\n\n## nodemon\n\n- nodemon 用来监视应用中的任何文件更改并自动重启服务\n- 非常适合用在开发环境中，方便啊，不用手动操作了\n- 全局安装 `npm install -g nodemon`\n- 本地安装 `npm install --save-dev nodemon`\n- 启动应用 `nodemon [your node app]`\n- 获取修改 package.json 中的启动脚本，添加`nodemon app.js`， 用 npm start 直接启动，方便', 'node基础知识', 1591804800, 34);
INSERT INTO `article` VALUES (12, 2, 'JS深拷贝和浅拷贝', '# 基础\n\n![总览](https://user-gold-cdn.xitu.io/2017/9/3/998e84124743f57f2f7e4005773baa0c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 堆和栈\n\n其实深拷贝和浅拷贝的主要区别就是其在**内存中的存储类型不同**。\n\n堆和栈都是内存中划分出来用来存储的区域。\n\n> 栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。\n\n## ECMAScript的数据类型\n\n### 基本数据类型存放在栈中\n\n存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。\n\n### 基本数据类型值不可变\n\n> javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。**字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值**。\n\n### 基本类型的比较是值的比较\n\n基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的。\n\n比较的时候最好使用严格等，因为 `==` 是会进行类型转换的，比如：\n\n```js\n    var a = 1;\n    var b = true;\n    console.log(a == b);//true复制代码\n```\n\n## 引用类型\n\n### 引用类型存放在堆中\n\n引用类型（`object`）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。\n\n```js\nvar person1 = {name:\'jozo\'};\nvar person2 = {name:\'xiaom\'};\nvar person3 = {name:\'xiaoq\'};\n```\n\n![堆内存](https://user-gold-cdn.xitu.io/2017/9/3/6fb2c3d13d830efc6ae07ac368df0816?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### 引用类型值可变\n\n引用类型是可以直接改变其值的，例如：\n\n```js\n    var a = [1,2,3];\n    a[1] = 5;\n    console.log(a[1]); // 5\n```\n\n### 引用类型的比较是引用的比较\n\n所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：\n\n```js\n    var a = [1,2,3];\n    var b = [1,2,3];\n    console.log(a === b); // false\n```\n\n虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。\n\n![引用类型在内存中的存储](https://user-gold-cdn.xitu.io/2017/9/3/a32ee86b9f3e303216d19240441cedfd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 传值与传址\n\n了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。\n在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：\n\n```js\nvar a = 10;\nvar b = a;\n\na ++ ;\nconsole.log(a); // 11\nconsole.log(b); // 10复制代码\n```\n\n![基本数据类型的赋值](https://user-gold-cdn.xitu.io/2017/9/3/8d973a9718da1806d19db0c1541ff425?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。\n\n但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：\n\n```js\nvar a = {}; // a保存了一个空对象的实例\nvar b = a;  // a和b都指向了这个空对象\n\na.name = \'jozo\';\nconsole.log(a.name); // \'jozo\'\nconsole.log(b.name); // \'jozo\'\n\nb.age = 22;\nconsole.log(b.age);// 22\nconsole.log(a.age);// 22\n\nconsole.log(a == b);// true复制代码\n```\n\n\n\n![引用类型的赋值](https://user-gold-cdn.xitu.io/2017/9/3/01dad9dc00fb0efe81d9bcbe9d30a1bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n# 浅拷贝\n\n## 赋值（=）和浅拷贝的区别\n\n那么赋值和浅拷贝有什么区别呢，我们看下面这个例子：\n\n```js\n    var obj1 = {                      //原始数据\n        \'name\' : \'zhangsan\',\n        \'age\' :  \'18\',\n        \'language\' : [1,[2,3],[4,5]],\n    };\n\n    var obj2 = obj1;                 //赋值操作得到\n\n\n    var obj3 = shallowCopy(obj1);    //浅拷贝得到\n    function shallowCopy(src) {\n        var dst = {};\n        for (var prop in src) {\n            if (src.hasOwnProperty(prop)) {\n                dst[prop] = src[prop];\n            }\n        }\n        return dst;\n    }\n\n    obj2.name = \"lisi\";\n    obj3.age = \"20\";\n\n    obj2.language[1] = [\"二\",\"三\"];\n    obj3.language[2] = [\"四\",\"五\"];\n\n    console.log(obj1);  \n    //obj1 = {\n    //    \'name\' : \'lisi\',\n    //    \'age\' :  \'18\',\n    //    \'language\' : [1,[\"二\",\"三\"],[\"四\",\"五\"]],\n    //};\n\n    console.log(obj2);\n    //obj2 = {\n    //    \'name\' : \'lisi\',\n    //    \'age\' :  \'18\',\n    //    \'language\' : [1,[\"二\",\"三\"],[\"四\",\"五\"]],\n    //};\n\n    console.log(obj3);\n    //obj3 = {\n    //    \'name\' : \'zhangsan\',\n    //    \'age\' :  \'20\',\n    //    \'language\' : [1,[\"二\",\"三\"],[\"四\",\"五\"]],\n    //};复制代码\n```\n\n这是因为**浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据**。所以就会出现改变浅拷贝得到的 `obj3` 中的引用类型时，会使原始数据得到改变。\n\n深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，\n\n浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象\n\n| --     | 和原数据是否指向同一对象 | 第一层数据为基本数据类型     | 原数据中包含子对象           |\n| ------ | ------------------------ | ---------------------------- | ---------------------------- |\n| 赋值   | 是                       | 改变会使原数据一同改变       | 改变会使原数据一同改变       |\n| 浅拷贝 | 否                       | 改变**不**会使原数据一同改变 | 改变会使原数据一同改变       |\n| 深拷贝 | 否                       | 改变**不**会使原数据一同改变 | 改变**不**会使原数据一同改变 |\n\n# 深拷贝\n\n深拷贝是对对象以及对象的所有子对象进行拷贝。\n\n### Js自带的深拷贝方法\n\n#### 1、Array\n\n- **slice()、concat、Array.from()、... 操作符**：只能实现一维数组的深拷贝\n\n```jsx\nvar arr1 = [1, 2, [3, 4]], arr2 = arr1.slice();\nconsole.log(arr1); //[1, 2, [3, 4]]\nconsole.log(arr2); //[1, 2, [3, 4]]\narr2[0] = 2 \narr2[2][1] = 5; \nconsole.log(arr1); //[1, 2, [3, 5]]\nconsole.log(arr2); //[2, 2, [3, 5]]\n```\n\n#### 2、Object\n\n- **Object.assign()**：只能实现一维对象的深拷贝\n\n```jsx\nvar obj1 = {x: 1, y: 2}, obj2 = Object.assign({}, obj1);\nconsole.log(obj1) //{x: 1, y: 2}\nconsole.log(obj2) //{x: 1, y: 2}\nobj2.x = 2; //修改obj2.x\nconsole.log(obj1) //{x: 1, y: 2}\nconsole.log(obj2) //{x: 2, y: 2}\nvar obj1 = {\n    x: 1, \n    y: {\n        m: 1\n    }\n};\nvar obj2 = Object.assign({}, obj1);\nconsole.log(obj1) //{x: 1, y: {m: 1}}\nconsole.log(obj2) //{x: 1, y: {m: 1}}\nobj2.y.m = 2; //修改obj2.y.m\nconsole.log(obj1) //{x: 1, y: {m: 2}}\nconsole.log(obj2) //{x: 2, y: {m: 2}}\n```\n\n- **JSON.parse(JSON.stringify(obj))**：可实现多维对象的深拷贝，但会忽略`undefined、任意的函数、symbol 值`，循环引用会报错，相同的引用会被重复复制\n\n```jsx\nvar obj1 = {\n    x: 1, \n    y: {\n        m: 1\n    },\n    a:undefined,\n    b:function(a,b){\n      return a+b\n    },\n    c:Symbol(\"foo\")\n};\nvar obj2 = JSON.parse(JSON.stringify(obj1));\nconsole.log(obj1) //{x: 1, y: {m: 1}, a: undefined, b: ƒ, c: Symbol(foo)}\nconsole.log(obj2) //{x: 1, y: {m: 1}}\nobj2.y.m = 2; //修改obj2.y.m\nconsole.log(obj1) //{x: 1, y: {m: 1}, a: undefined, b: ƒ, c: Symbol(foo)}\nconsole.log(obj2) //{x: 2, y: {m: 2}}\n```\n\n**注：**进行`JSON.stringify()`序列化的过程中，`undefined、任意的函数以及 symbol 值`，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。\n\n由上面可知，JS 提供的自有方法并不能彻底解决Array、Object的深拷贝问题，因此我们应该自己实现。\n\n\n\n### 深拷贝函数简单写法（递归实现）\n\n```jsx\nfunction deepClone(obj){\n  let result = Array.isArray(obj)?[]:{};\n  if(obj && typeof obj === \"object\"){\n    for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n        if(obj[key] && typeof obj[key] === \"object\"){\n          result[key] = deepClone(obj[key]);\n        }else{\n          result[key] = obj[key];\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// 测试用\nvar obj1 = {\n    x: {\n        m: 1\n    },\n    y: undefined,\n    z: function add(z1, z2) {\n        return z1 + z2\n    },\n    a: Symbol(\"foo\"),\n    b: [1,2,3,4,5],\n    c: null\n};\nvar obj2 = deepClone(obj1);\nobj2.x.m = 2;\nobj2.b[0] = 2;\nconsole.log(obj1);\nconsole.log(obj2);\n```\n\n![img](https:////upload-images.jianshu.io/upload_images/6991256-3067fb1fc039a6f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/555/format/webp)\n\n但上面的深拷贝方法遇到循环引用，会陷入一个循环的递归过程，从而导致爆栈。如：\n\n```csharp\nvar obj1 = {\n    x: 1, \n    y: 2\n};\nobj1.z = obj1;\nvar obj2 = deepClone(obj1);\n```\n\n因此需要改进。\n\n### 深拷贝函数改进（防止循环递归）\n\n解决因循环递归而暴栈的问题，只需要判断一个对象的字段是否引用了这个对象或这个对象的任意父级即可。\n\n```jsx\nfunction deepClone(obj, parent = null){ // 改进（1）\n  let result = Array.isArray(obj)?[]:{};\n  let _parent = parent;  // 改进（2）\n  while(_parent){ // 改进（3）\n    if(_parent.originalParent === obj){\n      return _parent.currentParent;\n    }\n    _parent = _parent.parent;\n  }\n  if(obj && typeof obj === \"object\"){\n    for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n        if(obj[key] && typeof obj[key] === \"object\"){\n          result[key] = deepClone(obj[key],{ // 改进（4）\n            originalParent: obj,\n            currentParent: result,\n            parent: parent\n          });\n        }else{\n          result[key] = obj[key];\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// 调试用\nvar obj1 = {\n    x: 1, \n    y: 2\n};\nobj1.z = obj1;\nvar obj2 = deepClone(obj1);\nconsole.log(obj1); //太长了去浏览器试一下吧～ \nconsole.log(obj2); //太长了去浏览器试一下吧～ \n```\n\n\n\n### 深拷贝函数最终版(支持基本数据类型、原型链、RegExp、Date类型)\n\n```jsx\nfunction deepClone(obj, parent = null){ \n  let result; // 最后的返回结果\n\n  let _parent = parent; // 防止循环引用\n  while(_parent){\n    if(_parent.originalParent === obj){\n      return _parent.currentParent;\n    }\n    _parent = _parent.parent;\n  }\n  \n  if(obj && typeof obj === \"object\"){ // 返回引用数据类型(null已被判断条件排除))\n    if(obj instanceof RegExp){ // RegExp类型\n      result = new RegExp(obj.source, obj.flags)\n    }else if(obj instanceof Date){ // Date类型\n      result = new Date(obj.getTime());\n    }else{\n      if(obj instanceof Array){ // Array类型\n        result = []\n      }else{ // Object类型，继承原型链\n        let proto = Object.getPrototypeOf(obj);\n        result = Object.create(proto);\n      }\n      for(let key in obj){ // Array类型 与 Object类型 的深拷贝\n        if(obj.hasOwnProperty(key)){\n          if(obj[key] && typeof obj[key] === \"object\"){\n            result[key] = deepClone(obj[key],{ \n              originalParent: obj,\n              currentParent: result,\n              parent: parent\n            });\n          }else{\n            result[key] = obj[key];\n          }\n        }\n      }\n    }\n  }else{ // 返回基本数据类型与Function类型,因为Function不需要深拷贝\n    return obj\n  }\n  return result;\n}\n\n// 调试用\nfunction construct(){\n    this.a = 1,\n    this.b = {\n        x:2,\n        y:3,\n        z:[4,5,[6]]\n    },\n    this.c = [7,8,[9,10]],\n    this.d = new Date(),\n    this.e = /abc/ig,\n    this.f = function(a,b){\n        return a+b\n    },\n    this.g = null,\n    this.h = undefined,\n    this.i = \"hello\",\n    this.j = Symbol(\"foo\")\n}\nconstruct.prototype.str = \"I\'m prototype\"\nvar obj1 = new construct()\nobj1.k = obj1\nobj2 = deepClone(obj1)\nobj2.b.x = 999\nobj2.c[0] = 666\nconsole.log(obj1)\nconsole.log(obj2)\nconsole.log(obj1.str)\nconsole.log(obj2.str)\n```\n\n![img](https:////upload-images.jianshu.io/upload_images/6991256-5bec563260387756.png?imageMogr2/auto-orient/strip|imageView2/2/w/950/format/webp)\n\n**注：Function类型的深拷贝：**\n\n- **bind()**：使用`fn.bind()`可将函数进行深拷贝，但因为this指针指向问题而不能使用；\n- **eval(fn.toString())**：只支持箭头函数，普通函数`function fn(){}`则不适用；\n- **new Function(arg1,arg2,...,function_body)**：需将参数与函数体提取出来；\n   PS：一般也不需要深拷贝Function。\n\n## 深度优先、广度优先实现深拷贝\n\n```javascript\n<!--工具函数-->\nconst _toString = Object.prototype.toString\nfunction getType(obj) {\n  return _toString.call(obj).slice(8, -1)\n}\n\n<!--深度优先-->\nfunction DFSDeepClone(obj, vistied = new Set(), level = 0) {\n  let res = {}\n\n  if (getType(obj) === \'Object\' || getType(obj) === \'Array\') {\n    if (vistied.has(obj)) {\n      // 处理环状结构\n      res = obj\n    } else {\n      vistied[level] = obj\n      vistied.add(obj)\n      res = getType(obj) === \'Object\' ? {} : []\n      Object.keys(obj).forEach(k => {\n        res[k] = DFSDeepClone(obj[k], vistied, level + 1)\n      })\n    }\n  } else if (typeof obj === \'function\') {\n    res = eval(`(${obj.toString()})`)\n  } else {\n    res = obj\n  }\n\n  return res\n}\n\n<!--广度优先-->\nfunction BFSDeepClone(obj) {\n  if (getType(obj) !== \'Object\' && getType(obj) !== \'Array\') {\n    if (typeof obj === \'function\') {\n      obj = eval(`(${obj.toString()})`)\n    }\n    return obj\n  }\n\n  let res = {}\n  const origin = [obj]\n  const copy = [res]\n  const vistied = new Set([obj])\n\n  while (origin.length) {\n    const _obj = origin.shift()\n    const copyObj = copy.shift()\n\n    Object.keys(_obj).forEach(k => {\n      const item = _obj[k]\n      if (getType(item) === \'Object\' || getType(item) === \'Array\') {\n        if (vistied.has(item)) {\n          copyObj[k] = item\n        } else {\n          vistied.add(item)\n          copyObj[k] = getType(item) === \'Object\' ? {} : []\n          origin.push(item)\n          copy.push(copyObj[k])\n        }\n      } else if (typeof item === \'function\') {\n        copyObj[k] = eval(`(${item.toString()})`)\n      } else {\n        copyObj[k] = item\n      }\n    })\n  }\n\n  return res\n}\n```\n\n没有实现对Symbol属性的处理，如果想实现的话可以用 Object.getOwnPropertySymbols()得到所有的Symbol属性，然后去遍历。\n\n# 参考\n\n[浅拷贝vs深拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b#heading-1)\n\n[浅拷贝与深拷贝](https://www.jianshu.com/p/2188dcd91090)\n\n[深浅拷贝](https://github.com/mqyqingfeng/Blog/issues/32)\n\n[对象深拷贝的两种实现方式（深度优先，广度优先）](https://blog.csdn.net/wangyue_cool/article/details/89100392)', 'JS深拷贝和浅拷贝', 1594051200, 36);
INSERT INTO `article` VALUES (13, 2, '一个简单的 Redux 示例', '# 一个简单的 redux 示例(todoList)\n\n<img src=\"https://s1.ax1x.com/2020/07/21/UTCA7F.png\" alt=\"UTCA7F.png\" style=\"zoom:20%;\" />\n\n## todolist\n\n```react\nimport React, { Component } from \'react\';\nimport \'antd/dist/antd.css\'\nimport { Input , Button , List } from \'antd\'\n\nconst data=[\n    \'早8点开晨会，分配今天的开发工作\'\n]\n\nclass TodoList extends Component {\n    render() { \n        return ( \n            <div>\n                <div>\n                    <Input placeholder=\'write someting\'/>\n                    <Button type=\"primary\">增加</Button>\n                </div>\n                <div>\n                    <List\n                        bordered\n                        dataSource={data}\n                        renderItem={item=>(<List.Item>{item}</List.Item>)}\n                    />    \n                </div>\n            </div>\n         );\n    }\n}\nexport default TodoList;\n```\n\n\n\n## 创建redux中的仓库--store和reducer\n\n* 先安装：`npm install --save redux`\n\n* 然后在`src`目录下建立一个`store`文件夹，然后在其下创建要给`index.js`文件。\n\n  ```js\n  // /src/store/index.js\n  import { createStore } from \'redux\'  // 引入createStore方法\n  import reducer from \'./reducer\'\n  const store = createStore(reducer)          // 创建数据存储仓库\n  \n  export default store                 //暴露出去\n  ```\n\n* 建立好仓库之后，需要一个有管理能力的模块出现，这就是`Reducer`。我们在`store`文件夹下新建`reducer.js`\n\n  ```js\n  const defaultState = {}  //默认数据\n  export default (state = defaultState,action)=>{  //就是一个方法函数\n      return state\n  }\n  ```\n\n* 然后初始化一下`todoList`中的数据，在store中添加两个新数据\n\n  ```js\n  const defaultState = {\n      inputValue : \'Write Something\',\n      list:[\n          \'早上4点起床，锻炼身体\',\n          \'中午下班游泳一小时\'\n      ]\n  }\n  export default (state = defaultState,action)=>{\n      return state\n  }\n  ```\n\n* 在**组件**中获取`store`数据\n\n  ```js\n  import store from \'./store\'\n  ```\n\n* 这时数据还不能让在UI层的组件直接使用，我们可以直接复制给组件的`state`\n\n  ```js\n  constructor(props){\n      super(props)\n      this.state = store.getState() //关键代码\n  }\n  ```\n\n\n\n## Redux Dev Tools的使用\n\n* 安装：直接去 chrome 应用商店下载。\n\n* 配置 `Redux Dev Tools`插件（[传送门](https://github.com/zalmoxisus/redux-devtools-extension)）\n\n  ```js\n  import { createStore } from \'redux\'  //  引入createStore方法\n  import reducer from \'./reducer\'    \n  const store = createStore(reducer,\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()) // 创建数据存储仓库\n  export default store   //暴露出去\n  ```\n\n  \n\n## 通过Input体验Redux流程\n\n* 增加`Input`响应事件\n\n  ```react\n  <Input \n      placeholder={this.state.inputValue} \n      onChange={this.changeInputValue}\n  />\n  ```\n\n* 创建`Action`，并通过`dispatch()`方法传递给`store`\n\n  ```js\n  changeInputValue(e){\n      const action = {\n          type:\'changeInput\',\n          value:e.target.value\n      }\n      store.dispatch(action)\n  }\n  ```\n\n* `store`的自动推送策略\n\n  `store`只是一个仓库，没有管理能力，它会把收到的`action`自动转发给`Reducer`，记住`reducer`是一个纯函数\n\n  ```js\n  //reducer.js\n  export default (state = defaultState,action)=>{\n      console.log(state,action) //reducer拿到了原来的数据和新传递过来的数据\n      if(action.type === \'changeInput\'){\n          let newState = JSON.parse(JSON.stringify(state)) //深度拷贝state\n          newState.inputValue = action.value\n          return newState\n      }\n      return state\n  }\n  ```\n\n  - **state**: 指的是原始仓库里的状态。\n  - **action**: 指的是action新传递的状态。\n\n* 让组件更新\n\n  ```js\n  //todolist.js\n  constructor(props){\n      super(props)\n      this.state=store.getState();\n      this.changeInputValue= this.changeInputValue.bind(this)\n      //----------关键代码-----------start\n      this.storeChange = this.storeChange.bind(this)  //转变this指向\n      store.subscribe(this.storeChange) //订阅Redux的状态\n      //----------关键代码-----------end\n  }\n  \n  soreChange(){\n      this.setState(sore.getState())\n  }\n  ```\n\n  \n\n## 编写`constants.js`\n\n* 将我们之前写的那些`action`的`type`的字符串字段写成一个常量的形式。\n\n  ```js\n  //store/constants.js\n  export const  CHANGE_INPUT = \'changeInput\'\n  export const  ADD_ITEM = \'addItem\'\n  export const  DELETE_ITEM = \'deleteItem\'\n  ```\n\n* 其他文件中引入\n\n  ```js\n  import { CHANGE_INPUT , ADD_ITEM , DELETE_ITEM } from \'./store/actionTypes\'\n  ```\n\n  \n\n## 编写`actionCreators.js`\n\n将创建`action`的代码专门放在一个文件夹\n\n* 建立`actionCreators.js`文件\n\n  ```js\n  // store/actionCreators.js\n  import {CHANGE_INPUT}  from \'./actionTypes\'\n  \n  export const changeInputAction = (value)=>({\n      type:CHANGE_INPUT,\n      value\n  })\n  ```\n\n* 修改`todolist.js`文件\n\n  ```js\n  import {changeInputAction} from \'./store/actionCreatores\'\n  \n  changeInputValue(e){\n          const action = changeInputAction(e.target.value)\n          store.dispatch(action)\n  }\n  ```\n\n  \n\n## axios 获取数据\n\n```js\n//todolist.js\ncomponentDidMount(){\n    axios.get(\'https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList\').then((res)=>{    \n        const data = res.data\n        const action = getListAction(data)\n        store.dispatch(action)\n    })\n}\n```\n\n```js\n//actionCreators.js\nexport const getListAction  = (data)=>({\n    type:GET_LIST,\n    data\n})\n```\n\n```js\n// reducer.js\n    if(action.type === GET_LIST ){ //根据type值，编写业务逻辑\n        let newState = JSON.parse(JSON.stringify(state)) \n        newState.list = action.data.data.list //复制性的List数组进去\n        return newState\n    }\n```\n\n```js\n// constants.js\nexport const  GET_LIST = \'getList\'\n```\n\n可以看到，`axios`请求还是要在`componentDidMount`中获取。后面使用`redux-thunk`就可以直接在`actionCreators.js`中获取了。\n\n# 进阶 & react-redux\n\n1. 在src目录下新建store目录，这个是总的redux，里面包含两个文件，index.js和reducer.js\n\n   ```js\n   //index.js\n   import {createStore,compose,applyMiddleware} from \'redux\'\n   import thunk from \'redux-thunk\'\n   import reducer from \'./reducer\'\n   //这里是为了使用redux-devtools这个插件\n   const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n   \n   const store = createStore(reducer,composeEnhancers(\n       applyMiddleware(thunk)\n   ));\n   export default store\n   ```\n\n   ```js\n   //reducer.js\n   import {reducer as headerReducer} from \'../common/header/store\'\n   //使用redux-immutable的combinReducer可将数据转为immutable对象\n   import {combineReducers} from \'redux-immutable\'\n   \n   const reducer =  combineReducers({\n       header: headerReducer,\n   })\n   \n   export default reducer;\n   \n   ```\n\n2. 然后改写src下的index.js\n\n   ```js\n   import React from \'react\';\n   import ReactDOM from \'react-dom\';\n   import {Provider} from \'react-redux\'\n   import Home from \'./Home.jsx\'\n   //引入全局样式文件\n   import \'./style.js\'\n   import store from \'./store\'\n   \n   const App = (\n       <Provider store={store}>\n           <Home/>\n       </Provider>\n   )\n   \n   ReactDOM.render(App, document.getElementById(\'root\'));\n   ```\n\n3. 接着我们可以在需要的页面或组件中，定义store目录，该目录下包含4个文件：\n\n   * index.js\n\n     ```js\n     import reducer from \'./reducer\'\n     import * as constants from \'./constants\';\n     import * as actionCreator from \'./actionCreator\'\n     \n     //统一导出，便于管理\n     export {reducer,constants,actionCreator}\n     ```\n\n   * reducer.js\n\n     ```js\n     import * as constants from \'./constants\';\n     import { fromJS} from \'immutable\'\n     const defaultState = fromJS({\n         focused: false,\n         list:[],\n         totalPage:0\n     })\n     \n     export default(state = defaultState, action )=>{\n         switch(action.type){\n             case constants.SEARCH_FOCUS:\n                 return state.set(\'focused\',true)\n             case constants.CHANGE_LIST:\n                 return state.merge({\n                     list:action.data,\n                     totalPage:action.totalPage\n                 })\n                 // return state.set(\'list\',action.data).set(\'totalPage\',action.totalPage)\n             default:\n                 return state\n         }\n     }\n     ```\n\n   * constants.js\n\n     ```js\n     export const SEARCH_FOCUS = \'header/SEARCH_FOCUS\'\n     ```\n\n   * actionCreators.js\n\n     ```js\n     import * as constants from \'./constants\';\n     import axios from \'axios\'\n     //fromJS将普通js对象转为immutable对象\n     import { fromJS } from \'immutable\';\n     \n     export const changePage = (page)=>({\n         type:constants.CHANGE_PAGE,\n         page\n     })\n     const changeList = (data)=>({\n         type: constants.CHANGE_LIST,\n         data: fromJS(data),\n         totalPage: Math.ceil(data.length/10)\n     })\n     \n     //利用thunk中间件，可以在actionCreators里面写函数\n     export const getList=()=>{\n         return (dispath)=>{\n             axios.get(\'/api/headerList.json\').then((res)=>{\n                 const data = res.data;\n                 dispath(changeList(data.data))\n             }).catch((e)=>{\n                 console.log(\"error\")\n             })\n         }\n     }\n     ```\n\n4. 在组件中使用时\n\n   * 引入connect\n\n     ```js\n     const mapStateToProps=(state)=>({\n         focused:state.get(\'header\').get(\'focused\'),\n         // focused:state.getIn([\'header\',\'focused\']),\n         list:state.getIn([\'header\',\'list\']),\n     })\n     \n     const mapDispatchToProps = dispatch=>({\n         handleInputBlur() {\n             //在这里dispatch\n             dispatch(actionCreator.searchBlur())\n         }\n     })\n     export default connect(mapStateToProps,mapDispatchToProps)(Header);\n     ```\n\n## ', '一个简单的示例跑通 redux 流程', 1595260800, 47);
INSERT INTO `article` VALUES (14, 7, 'vim 基础', '# VIM\n\n## Vim快速入门\n\n### Vim模式简介\n\n> 从vi衍生出来的Vim具有多种模式，这种独特的设计容易使初学者产生混淆。几乎所有的编辑器都会有*插入*和*执行*命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。\n\nVim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：\n\n- 普通模式(Normal mode)\n\n> 在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。\n\n> Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令`dd`删除当前行，但是第一个\"d\"的后面可以跟另外的移动命令来代替第二个`d`，比如用移动到下一行的\"j\"键就可以删除当前行和下一行。另外还可以指定命令重复次数，`2dd`（重复`dd`两次），和`dj`的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。\n\n> 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按`a`（append／追加）键或者`i`（insert／插入）键。\n\n- 插入模式(Insert mode)\n\n> 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。\n\n> 在插入模式中，可以按`ESC`键回到普通模式。\n\n- 可视模式(Visual mode)\n\n> 这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的\"文本对象\"也能和移动命令一样用在这个模式中。\n\n- 选择模式(Select mode)\n\n> 这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。\n\n- 命令行模式(Command line mode)\n\n> 在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（`:`键），搜索（`/`和`?`键）或者过滤命令（`!`键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。\n\n- Ex模式(Ex mode)\n\n> 这和命令行模式比较相似，在使用`:visual`命令离开Ex模式前，可以一次执行多条命令。\n\n> 这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容\n\n### 进入vim\n\n**使用vim命令进入vim界面**\n\nvim后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。 打开Xfce终端，输入以下命令\n\n```\n$ vim practice_1.txt\n```\n\n直接使用vim也可以打开vim编辑器，但是不会打开任何文件。\n\n```\n$ vim\n```\n\n进入命令行模式后输入`:e 文件路径` 同样可以打开相应文件。\n\n**游标移动**\n\n在进入vim后，按下`i`键进入插入模式。在该模式下您可以输入文本信息.\n\n按`Esc`进入普通模式，在该模式下使用方向键或者`h`,`j`,`k`,`l`键可以移动游标。\n\n| 按键 | 说明             |\n| ---- | ---------------- |\n| `h`  | 左               |\n| `l`  | 右（小写L）      |\n| `j`  | 下               |\n| `k`  | 上               |\n| `w`  | 移动到下一个单词 |\n\n### 进入插入模式\n\n在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入\n\n| 命令 | 说明                                     |\n| ---- | ---------------------------------------- |\n| `i`  | 在当前光标处进行编辑                     |\n| `I`  | 在行首插入                               |\n| `A`  | 在行末插入                               |\n| `a`  | 在光标后插入编辑                         |\n| `o`  | 在当前行后插入一个新行                   |\n| `O`  | 在当前行前插入一个新行                   |\n| `cw` | 替换从光标所在位置后到一个单词结尾的字符 |\n\n### 保存文档\n\n**命令行模式下保存文档**\n\n从普通模式输入`:`进入命令行模式，输入`w`回车，保存文档。输入`:w 文件名`可以将文档另存为其他文件名或存到其它路径下\n\n### 退出vim\n\n**命令行模式下退出vim**\n\n从普通模式输入`:`进入命令行模式，输入`wq`回车，保存并退出编辑\n\n以下为其它几种退出方式：\n\n| 命令               | 说明             |\n| ------------------ | ---------------- |\n| `:q!`              | 强制退出，不保存 |\n| `:q`               | 退出             |\n| `:wq!`             | 强制保存并退出   |\n| `:w <文件路径>`    | 另存为           |\n| `:saveas 文件路径` | 另存为           |\n| `:x`               | 保存并退出       |\n| `:wq`              | 保存并退出       |\n\n**普通模式下退出vim**\n\n普通模式下输入`Shift+zz`即可保存退出vim\n\n### 删除文本\n\n**普通模式下删除vim文本信息**\n\n进入普通模式，使用下列命令可以进行文本快速删除：\n\n| 命令      | 说明                       |\n| --------- | -------------------------- |\n| `x`       | 删除游标所在的字符         |\n| `X`       | 删除游标所在前一个字符     |\n| `Delete`  | 同`x`                      |\n| `dd`      | 删除整行                   |\n| `dw`      | 删除一个单词（不适用中文） |\n| `d$`或`D` | 删除至行尾                 |\n| `d^`      | 删除至行首                 |\n| `dG`      | 删除到文档结尾处           |\n| `d1G`     | 删至文档首部               |\n\n除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：\n\n`2dd`表示一次删除2行\n\n\n\n## Vim 文档编辑\n\n### Vim重复命令\n\n**重复执行上次命令**\n\n在普通模式下`.`(小数点)表示重复上一次的命令操作\n\n比如：普通模式下输入`x`，删除第一个字符，输入`.`(小数点)会再次删除一个字符，除此之外也可以重复`dd`的删除操作\n\n**执行指令次数相同的命令**\n\n进入普通模式输入`N`，N 表示重复后面的次数，下面来练习：\n\n比如：\n\n- 输入`10x`，删除10个连续字符\n- 输入`3dd`，将会删除3行文本\n\n在普通模式下，你还可以使用`dw`或者`daw`(delete a word)删除一个单词，所以你可以很容易的联想到`dnw`(**n替换为相应数字**) 表示删除n个单词\n\n### 游标快速跳转\n\n普通模式下，下列命令可以让光标快速调转到指定位置，我们分别讨论快速实现**行间**跳转和**行内**跳转\n\n**行间跳转**\n\n| 命令            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| `nG`(n Shift+g) | 游标移动到第 n 行**(如果默认没有显示行号，请先进入命令模式，输入`:set nu`以显示行号)** |\n| `gg`            | 游标移动到到第一行                                           |\n| `G`(Shift+g)    | 到最后一行                                                   |\n\n**小技巧：你在完成依次跳转后，可以使用 `Ctrl+o` 快速回到上一次(跳转前)光标所在位置**,这个技巧很实用，比如当你在写代码时，忽然想起有个 bug，需要修改，这时候你跳过去改好了，只需要按下 `Ctrl+o` 就可以回到你之前的位置。vim 中会用很多类似的小技巧就等着你去发掘。\n\n**行内跳转**\n\n普通模式下使用下列命令在行内按照单词为单位进行跳转\n\n| 命令      | 说明                                                       |\n| --------- | ---------------------------------------------------------- |\n| `w`       | 到下一个单词的开头                                         |\n| `e`       | 到当前单词的结尾                                           |\n| `b`       | 到前一个单词的开头                                         |\n| `ge`      | 到前一个单词的结尾                                         |\n| `0`或`^`  | 到行头                                                     |\n| `$`       | 到行尾                                                     |\n| `f<字母>` | 向后搜索<字母>并跳转到第一个匹配的位置(非常实用)           |\n| `F<字母>` | 向前搜索<字母>并跳转到第一个匹配的位置                     |\n| `t<字母>` | 向后搜索<字母>并跳转到第一个匹配位置之前的一个字母(不常用) |\n| `T<字母>` | 向前搜索<字母>并跳转到第一个匹配位置之后的一个字母(不常用) |\n\n操作练习：\n\n- 在普通模式下，任意跳转到一行，使用 `w` 跳转到一个单词的开头，然后使用 `dw` 删除这个单词\n- 在普通模式下，使用 `e` 跳转到一个单词的结尾，并使用 `~` 将游标所在字母变成大写或小写\n\n### 复制粘贴和剪切\n\n**复制及粘贴文本**\n\n- 普通模式中使用`y`复制\n  - 普通模式中，`yy`复制游标所在的整行（`3yy`表示复制3行）\n  - 普通模式中，`y^` 复制至行首，或`y0`。不含光标所在处字符。\n  - 普通模式中，`y$` 复制至行尾。含光标所在处字符。\n  - 普通模式中，`yw` 复制一个单词。\n  - 普通模式中，`y2w` 复制两个单词。\n  - 普通模式中，`yG` 复制至文本末。\n  - 普通模式中，`y1G` 复制至文本开头。\n- 普通模式中使用 `p` 粘贴\n  - 普通模式中，`p`(小写)代表粘贴至光标后（下）\n  - 普通模式中，`P`(大写)代表粘贴至光标前（上）\n\n**剪切及粘贴**\n\n其实前面讲得 `dd` 删除命令就是剪切，你每次 `dd` 删除文档内容后，便可以使用 `p` 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行：\n\n`ddp` ,就这么简单，即实现了快速交换光标所在行与它下面的行\n\n## 查找替换\n\n### 字符的替换及撤销(Undo操作)\n\n**替换和撤销(Undo)命令**\n\n替换和Undo命令都是针对普通模式下的操作\n\n| 命令             | 说明                                         |\n| ---------------- | -------------------------------------------- |\n| `r`+<待替换字母> | 将游标所在字母替换为指定字母                 |\n| `R`              | 连续替换，直到按下`Esc`                      |\n| `cc`             | 替换整行，即删除游标所在行，并进入插入模式   |\n| `cw`             | 替换一个单词，即删除一个单词，并进入插入模式 |\n| `C`(大写)        | 替换游标以后至行末                           |\n| `~`              | 反转游标所在字母大小写                       |\n| `u`{n}           | 撤销一次或n次操作                            |\n| `U`(大写)        | 撤销当前行的所有修改                         |\n| `Ctrl+r`         | redo，即撤销undo的操作                       |\n\n### 快速缩进\n\n**使用命令进行快速调整缩进操作**\n\n缩进操作均在普通模式下有效\n\n打开文件进行编辑\n\n```\n$ vim protocols\n```\n\n- 普通模式下输入`15G`，跳转到15行\n- 普通模式下输入`>>` 整行将向右缩进（使用，用于格式化代码超爽）\n- 普通模式下输入`<<` 整行向左回退\n- 普通模式下输入`:`进入命令行模式下对`shiftwidth`值进行设置可以控制缩进和回退的字符数\n\n**shiftwidth命令**\n\n`shiftwidth`命令是指上一节`>>`命令产生的缩进（可以简写成`sw`） 普通模式下输入`:`进入命令行模式下对`shiftwidth`值进行设置可以控制缩进和回退的字符数 获取目前的设定值\n\n```\n:set shiftwidth?\n```\n\n设置缩进为10个字符\n\n```\n:set shiftwidth=10\n```\n\n输入 `ESC` 回到普通模式，再次尝试 `>>` 看缩进量是否变化\n\n**调整文本位置**\n\n命令行模式下输入`:ce`(center)命令使本行内容居中\n\n```\n:ce\n```\n\n命令行模式下输入`:ri`(right)命令使本行文本靠右\n\n```\n:ri\n```\n\n命令行模式下输入:`le`(left)命令使本行内容靠左\n\n```\n:le\n```\n\n### 查找\n\n**快速查找**\n\n普通模式下输入 `/` 然后键入需要查找的字符串 按回车后就会进行查找。 `？` 与`/` 功能相同，只不过 `？` 是向上而 `/` 是向下查找。 进入查找之后，输入`n` 和 `N` 可以继续查找。 `n`是查找下一个内容,`N`查找上一个内容。\n\n**快速查找练习**\n\n使用 vim 打开文件进行编辑（搜索高亮需要在配置文件 `.vimrc` 中设置 `set hls` ，实验环境中已经设置好了）\n\n```\n$ vim protocols\n```\n\n- 普通模式下输入`/icmp`然后回车即可查找字符串 `icmp`\n- 普通模式下输入`n`查找下一个 `icmp`\n- 普通模式下输入`？tcp`向上查找字符串 `tcp`\n- 普通模式下输入`N`查找上一个出现的 `tcp`\n- 命令行模式下输入 `noh` 然后回车即可取消搜索\n\n**高级查找**\n\n- 普通模式下输入`\\*`寻找游标所在处的单词\n- 普通模式下输入`\\#`同上，但 `\\#` 是向前（上）找，`\\*`则是向后（下）找\n- 普通模式下输入`g\\*`同`\\*` ，但部分符合该单词即可\n- 普通模式下输入`g\\#`同`\\#` ，但部分符合该单词即可\n\n以上查找`n`,`N` 的继续查找命令依然可以用\n\n## 高级功能入门\n\n### 多文件编辑\n\n**使用vim编辑多个文件**\n\n编辑多个文件有两种形式，一种是在进入vim前使用的参数就是多个文件。另一种就是进入vim后再编辑其他的文件。 同时创建两个新文件并编辑\n\n```\n$ vim 1.txt 2.txt\n```\n\n默认进入`1.txt`文件的编辑界面\n\n- 命令行模式下输入 `:n` 编辑 2.txt 文件，可以加 `!` 即 `:n!` 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件\n- 命令行模式下输入 `:N` 编辑 1.txt 文件，可以加 `!` 即 `:N!` 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件\n\n**进入vim后打开新文件**\n\n- 命令行模式下输入`:e 3.txt` 打开新文件3.txt\n- 命令行模式下输入`:e#` 回到前一个文件\n- 命令行模式下输入`:ls`可以列出以前编辑过的文档\n- 命令行模式下输入`:b 2.txt`（或者编号）可以直接进入文件2.txt编辑\n- 命令行模式下输入`:bd 2.txt`（或者编号）可以删除以前编辑过的列表中的文件项目\n- 命令行模式下输入`:e! 4.txt`，新打开文件4.txt，放弃正在编辑的文件\n- 命令行模式下输入`:f` 显示正在编辑的文件名\n- 命令行模式下输入`:f new.txt`，改变正在编辑的文件名字为new.txt\n\n**恢复文件**\n\n如果因为断电等原因造成文档没有保存，可以采用恢复方式，`vim -r`进入文档后，输入`:ewcover 1.txt`来恢复\n\n```\n$ vim -r 1.txt\n```\n\n### 可视模式\n\n**可视模式命令简介**\n\n- 在普通模式下输入 `v`（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v后就会取消选取。\n- 在普通模式下输入 `Shift+v`（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 `Shift+v` 就可以取消选取。\n- 在普通模式下输入 `Ctrl+v`（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 `Ctrl+v` 取消选取。\n- 在可视模式下输入 `d` 删除选取区域内容\n- 在可视模式下输入`y`复制选取区域内容\n\n**可视模式命令练习**\n\n拷贝练习文件到当前目录\n\n```\n$ cp /etc/protocols .\n```\n\n打开练习文件\n\n```\n$ vim protocols\n```\n\n- 在普通模式下`9G`跳转到第9行,输入`Shift+v`（小写V），进入可视模式进行行选择，选中5行，按下`>>`缩进，将5行整体缩进一个`shiftwidth`\n- 在普通模式下输入 `Ctrl+v`（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后`x`删除整列\n\n### 视窗操作\n\n**视窗操作简介**\n\nvim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如：可以使用在命令行模式下输入 `:new` 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 `Ctrl+w`也可以），除了 `:new` 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：\n\n**注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。**\n\n- 命令行模式下输入`:sp 1.txt` 打开新的水平分屏视窗来编辑1.txt\n- 命令行模式下输入`:vsp 2.txt` 打开新的垂直分屏视窗来编辑2.txt\n- 普通模式下`Ctrl+w s` 将当前窗口分割成两个水平的窗口\n- 普通模式下`Ctrl+w v` 将当前窗口分割成两个垂直的窗口\n- 普通模式下`Ctrl+w q` 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!\n- 普通模式下`Ctrl+w o` 打开一个视窗并且隐藏之前的所有视窗\n- 普通模式下`Ctrl+w j` 移至下面视窗\n- 普通模式下`Ctrl+w k` 移至上面视窗\n- 普通模式下`Ctrl+w h` 移至左边视窗\n- 普通模式下`Ctrl+w l` 移至右边视窗\n- 普通模式下`Ctrl+w J` 将当前视窗移至下面\n- 普通模式下`Ctrl+w K` 将当前视窗移至上面\n- 普通模式下`Ctrl+w H` 将当前视窗移至左边\n- 普通模式下`Ctrl+w L` 将当前视窗移至右边\n- 普通模式下`Ctrl+w -` 减小视窗的高度\n- 普通模式下`Ctrl+w +` 增加视窗的高度\n\n**视窗操作练习**\n\n打开练习文件\n\n```\n$ vim 1.txt\n```\n\n- 命令行模式下输入`:new` 打开一个新的vim视窗\n- 命令行模式下输入`:vsp 2.txt` 打开新的横向视窗来编辑2.txt\n- 命令行模式下输入`:vsp 3.txt` 打开新的横向视窗来编辑3.txt\n- 如果使用非chrome浏览器可以使用`Ctrl+w`进行视窗间的跳转\n- 分别在不同视窗的命令行模式下输入`:q!`退出多视窗编辑\n\n### 文档加密\n\n**创建加密文档**\n\n```\n$ vim -x file1\n```\n\n输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码\n\n### 在vim执行外部命令\n\n在命令行模式中输入`!`可以执行外部的shell命令\n\n- `:!ls` 用于显示当前目录的内容\n- `:!rm FILENAME`用于删除名为 FILENAME 的文件\n- `:w FILENAME`可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件\n\n### 帮助系统\n\n **vim中的查看帮助**\n\n- 普通模式下按`F1`打开`vim`自己预设的帮助文档\n- 命令行模式下输入`:h shiftwidth` 打开名为`shiftwidth`的帮助文件\n- 命令行模式下输入`:ver` 显示版本及参数\n\n### 功能设定\n\n**vim的功能设定**\n\n可以在编辑文件的时候进行功能设定，如命令行模式下输入`:set nu`（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件`~/.vimrc`(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用\n\n**获取目前的设定**\n\n- 命令行模式下输入`:set`或者`:se`显示所有修改过的配置\n- 命令行模式下输入`:set all` 显示所有的设定值\n- 命令行模式下输入`:set option?` 显示option的设定值\n- 命令行模式下输入`:set nooption` 取消当前设定值\n\n**set功能的说明**\n\n- 命令行模式下输入`:set autoindent(ai)` 设置自动缩进\n- 命令行模式下输入`:set autowrite(aw)` 设置自动存档，默认未打开\n- 命令行模式下输入`:set background=dark`或`light`，设置背景风格\n- 命令行模式下输入`:set backup(bk)` 设置自动备份，默认未打开\n- 命令行模式下输入`: set cindent(cin)` 设置C语言风格缩进', 'vim 基础', 1595347200, 31);
INSERT INTO `article` VALUES (16, 3, '数据结构与算法【链表篇】', '# 数据结构与算法【链表篇】\n\n## 核心知识\n\n- null 异常处理\n- dummy node 哑巴节点\n- 快慢指针\n- 插入一个节点到排序链表\n- 从一个链表中移除一个节点\n- 翻转链表\n- 合并两个链表\n- 找到链表的中间节点\n\n## 反转链表\n\n### 1. 反转一个单链表\n\n[reverse-linked-list](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n**示例:**\n\n```\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n```javascript\nvar reverseList = function(head) {\n   if(!head) return null\n   var  cur = head\n   var  prev = null\n    while(cur){\n        var tmp = new ListNode()\n        tmp = cur.next\n        cur.next = prev\n        prev = cur\n        cur = tmp\n    }\n    return prev\n};\n//递归\nvar reverseList = function(head) {\n    if(!head) return null\n    var reverse = function(prev, cur){\n        if(!cur) return prev;\n        var tmp = cur.next\n        cur.next = prev\n        return reverse(cur, tmp)\n    }\n    return reverse(null, head)\n};\n```\n\n### 2. 区间反转\n\n[reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\n\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n\n说明:\n1 ≤ m ≤ n ≤ 链表长度。\n\n示例:\n\n```javascript\n输入: 1->2->3->4->5->NULL, m = 2, n = 4\n输出: 1->4->3->2->5->NULL\n```\n![img](https://user-gold-cdn.xitu.io/2020/1/31/16ffae9acac18faa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```javascript\nvar reverseBetween = function(head, m, n) {\n    if(!head || !head.next) return head\n    var dummy = new ListNode(0)\n    dummy.next = head\n    var front = dummy\n    var back = head\n    while(m-1>0) {\n        front = front.next\n        m--\n    }\n    while(n-1>0){\n        back=back.next\n        n--\n    }\n    var last=back.next\n    back.next=null\n    var cur = front.next\n    var prev = null\n    while (cur) {\n        [cur.next, prev, cur] = [prev, cur, cur.next]\n    }\n    front.next = prev\n    var tmp = prev\n    while(tmp.next){\n        tmp=tmp.next\n    }\n    tmp.next = last\n    return dummy.next\n};\n```\n\n### 两个一组反转\n\n[swap-nodes-in-pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n**示例:**\n\n```\n给定 1->2->3->4, 你应该返回 2->1->4->3.\n```\n\n**思路**\n\n如图所示，我们首先建立一个虚拟头节点(dummyHead)，辅助我们分析。\n\n![img](F:%5Calgorithm%5Cimage%5C2.png)\n\n首先让 p 处在 dummyHead 的位置，记录下 p.next 和 p.next.next 的节点，也就是 node1 和 node2。\n\n随后让 **node1.next = node2.next**, 效果:\n\n![img](F:%5Calgorithm%5Cimage%5C3.png)\n\n然后让 **node2.next = node1**, 效果:\n\n![img](F:%5Calgorithm%5Cimage%5C4.png)\n\n最后，**dummyHead.next = node2**，本次翻转完成。同时 p 指针指向node1, 效果如下：\n\n![img](F:%5Calgorithm%5Cimage%5C5.png)\n\n依此循环，如果 `p.next` 或者 `p.next.next` 为空，也就是`找不到新的一组节点`了，循环结束。\n\n```javascript\nvar swapPairs = function(head) {\n    if(!head || !head.next) return head \n    var dummy = new ListNode(0)\n    dummy.next = head\n    var p = dummy\n    while(p.next && p.next.next){\n        var node1 = p.next\n        var node2 = p.next.next\n        node1.next = node2.next\n        node2.next = node1\n        p.next = node2\n        p = p.next.next\n    }\n    return dummy.next\n};\n//递归\nvar swapPairs = function(head){\n    if(!head || !head.next) return head\n    var node1 = head\n    var node2 = head.next\n    node1.next = swapPairs(node2.next)\n    node2.next = node1\n    return node2\n}\n```\n\n### K个一组翻转链表\n\n[reverse-nodes-in-k-group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n>\n> k 是一个正整数，它的值小于或等于链表的长度。\n>\n> 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n>\n\n示例：\n\n给你这个链表：1->2->3->4->5\n\n当 k = 2 时，应当返回: 2->1->4->3->5\n\n当 k = 3 时，应当返回: 3->2->1->4->5\n\n**思路**\n\n```javascript\n//递归\nvar reverseKGroup = function(head, k) {\n    var p = cur = head\n    var prev = null\n    for(var i=0; i<k; i++){\n        if(!p) return head\n        p=p.next\n    }\n    for(var i=0; i<k; i++){\n        var next = cur.next\n        cur.next = prev\n        prev = cur\n        cur = next\n    }\n    head.next = reverseKGroup(cur, k)\n    return prev\n};\n\nvar reverseKGroup = function(head, k) {\n    var count = 0\n    var q = head\n    //统计节点个数\n    while(q){\n        q=q.next\n        count++\n    }\n    var dummy = p = new ListNode()\n    dummy.next = head\n    //计算有几组\n    var groups = Math.floor(count/k)\n    for(var i=0; i<groups; i++){\n        var prev = null, cur = p.next\n        for(var j=0; j<k; j++){\n            var next = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next\n        }\n        //关键步骤\n        var start = p.next\n        start.next = cur\n        p.next = prev\n        p=start\n    }\n    return dummy.next\n};\n```\n\n## 环形链表\n\n### 检测链表是否形成环\n\n[linked-list-cycle](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n**思路**\n\n思路一: 循环一遍，用 Set 数据结构保存节点，利用节点的内存地址来进行判重，如果同样的节点走过两次，则表明已经形成了环。\n\n```javascript\n//使用Set验证\nvar hasCycle = function(head) {\n    var p = head\n    var set = new Set()\n    while(p){\n        if(set.has(p)) return true\n        set.add(p)\n        p=p.next\n    }\n    return false\n};\n```\n\n思路二: 利用快慢指针，快指针一次走两步，慢指针一次走一步，如果`两者相遇`，则表明已经形成了环。\n\n```javascript\nvar hasCycle = function(head){\n    if(!head || !head.next) return false\n    var slow = head, fast = head.next\n    while(fast && fast.next){\n        if(fast == slow) return true\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return false\n}\n```\n\n### 找到环的起点\n\n[linked-list-cycle-ii](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n> 示例 1：\n>\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：tail connects to node index 1\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n>\n>\n> ![img](F:%5Calgorithm%5Cimage%5C6.png)\n\n![img](F:%5Calgorithm%5Cimage%5C7.png)\n\n看上去比较繁琐，我们把它做进一步的抽象:\n\n\n\n![img](F:%5Calgorithm%5Cimage%5C8.png)\n\n\n\n设快慢指针走了`x`秒，慢指针一秒走一次。\n\n对快指针，有: **2x - L = m \\* S + Y** -----①\n\n对慢指针，有: **x -  L = n \\* S + Y** -----②\n\n其中，m、n 均为自然数。\n\n① - ② * 2 得:\n\n**L = (m - n) \\* S - Y**-----③\n\n好，这是一个非常重要的等式。我们现在假设有一个新的指针在 L 段的最左端，慢指针现在还在相遇处。\n\n让`新指针`和`慢指针`都每次走一步，那么，当`新指针`走了 L 步之后**到达环起点**，而与此同时，我们看看`慢指针情况如何`。\n\n由③式，慢指针走了`(m - n) * S - Y`个单位，以环起点为参照物，相遇时的位置为 Y，而现在由`Y + (m - n) * S - Y`即`(m - n) * S`，得知慢指针实际上参照环起点，走了整整(m - n)圈。也就是说，**慢指针此时也到达了环起点**。 :::tip 结论 现在的解法就很清晰了，当快慢指针相遇之后，让新指针从头出发，和慢指针同时前进，且每次前进一步，两者相遇的地方，就是**环起点**。\n\n```javascript\nvar detectCycle = function(head) {\n    if(!head || !head.next) return null\n    var fast = slow = head\n    while(fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n        if(fast == slow){\n            var p = head\n            while(p!=slow){\n                p=p.next\n                slow=slow.next\n            }\n            return p\n        }\n    }\n    return null\n};\n```\n\n## 链表合并\n\n### 合并两个有序链表\n\n[merge-two-sorted-lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n**示例：**\n\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n```javascript\nvar mergeTwoLists = function(l1, l2) {\n    if(l1 === null) return l2\n    if(l2 === null) return l1\n    var p1 = l1, p2 = l2\n    var dummy = p = new ListNode()\n    while(p1 && p2){\n        if(p1.val > p2.val){\n            p.next = p2\n            p2 = p2.next\n\n        }else{\n            p.next = p1\n            p1 = p1.next\n        }\n        p = p.next\n    }\n    if(p1) p.next = p1\n    else p.next = p2\n    return dummy.next\n};\n\n//递归\nvar mergeTwoLists = function(l1, l2){\n    var merge = function(l1, l2){\n        if(!l1) return l2\n        if(!l2) return l1\n        if(l1.val < l2.val){\n            l1.next = merge(l1.next, l2)\n            return l1\n        }else{\n            l2.next = merge(l1, l2.next)\n            return l2\n        }\n    }\n    return merge(l1,l2)\n}\n```\n\n### 合并 K 个有序链表\n\n[merge-k-sorted-lists](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n**示例:**\n\n```\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n```\n\n**自上而下（递归）实现**\n\n```javascript\nvar mergeKLists = function(lists) {\n    const _mergeLists = function(lists, start, end){\n        if(end - start < 0) return null\n        if(end - start === 0) return lists[end]\n        let mid = Math.floor((start+end)/2)\n        return mergeTwoLists(_mergeLists(lists, start, mid), _mergeLists(lists, mid+1, end)) //mergeTwoLists在上面已经实现\n    }\n    return _mergeLists(lists, 0, lists.length-1)\n};\n```\n\n**自下而上**\n\n```javascript\nvar mergeKLists = function(lists) {\n    if(!lists.length || !lists) return null\n    let dummyHead = []\n    for(let i=0; i<lists.length; i++){\n        let node = new ListNode()\n        node.next = lists[i]\n        dummyHead[i] = node //为每一个链表绑定一个虚拟头指针方便后续合并操作\n    }\n    for(let size = 1; size < lists.length; size+=size){\n        for(let i = 0; i+size < lists.length; i+=size*2){\n            dummyHead[i].next = mergeTwoLists(dummyHead[i].next, dummyHead[i+size].next)\n        }\n    }\n    return dummyHead[0].next\n};\n```\n\n## 链表元素删除\n\n### 删除排序链表中重复元素\n\n[remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n**示例 1:**\n\n```\n输入: 1->1->2\n输出: 1->2\n```\n\n```javascript\nvar deleteDuplicates = function(head) {\n    let cur = head\n    while(cur!==null && cur.next!==null){\n        if(cur.val===cur.next.val){\n            cur.next = cur.next.next\n        }else{\n            cur = cur.next   \n        }\n\n    }\n    return head\n};\n```\n\n### 保留链表中没有重复出现的元素\n\n[remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)\n\n**示例 1:**\n\n```\n输入: 1->2->3->3->4->4->5\n输出: 1->2->5\n```\n\n```javascript\nvar deleteDuplicates = function (head) {\n    if(head === null) return head\n    var dummy = new ListNode(0)\n    dummy.next = head\n    var prev = dummy\n    var cur = head.next\n    while(cur!==null){\n        if(prev.next.val !== cur.val){\n            cur=cur.next\n            prev=prev.next\n        }else{\n            while(cur!==null && prev.next.val === cur.val){\n                cur = cur.next===null?null:cur.next\n            }\n            prev.next = cur\n            cur= cur===null? null : cur.next\n        }\n        \n    }\n    return dummy.next\n};\n```\n\n### 删除未排序重复节点\n\n[remove-duplicate-node-lcci](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)\n\n编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n\n**示例1:**\n\n```\n 输入：[1, 2, 3, 3, 2, 1]\n 输出：[1, 2, 3]\n```\n\n**示例2:**\n\n```\n 输入：[1, 1, 1, 1, 2]\n 输出：[1, 2]\n```\n\n**方法一：哈希表法**\n\n```javascript\nvar removeDuplicateNodes = function(head) {\n    if(!head) return null\n    var occurred = new Set()\n    occurred.add(head.val)\n    var pos = head\n    while(pos.next){\n        var cur = pos.next\n        if(!occurred.has(cur.val)){\n            occurred.add(cur.val)\n            pos = pos.next\n        }else{\n            pos.next = pos.next.next\n        }\n    }\n    pos.next = null\n    return head\n};\n//时间复杂度O(N)，空间复杂度O(N)\n```\n\n**方法二：双重循环（不使用额外缓存空间）**\n\n```javascript\nvar removeDuplicateNodes = function(head){\n    var pos = head\n    while(pos){\n        var cur = pos\n        while(cur.next){\n            if(cur.next.val == pos.val){\n                cur.next = cur.next.next\n            }else{\n                cur = cur.next\n            }\n        }\n        pos = pos.next\n    }\n    return head\n}\n//时间复杂度O(N*N)，空间复杂度O(1)\n```\n\n## 求链表中间节点\n\n### 判断回文链表\n\n[palindrome-linked-list](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n**示例**\n\n```\n输入: 1->2->2->1\n输出: true\n```\n**思路**\n\n找到中间节点，将后半部分翻转，与前半部分比较\n\n**分析【快慢指针找中间节点】**\n\n分析一下，分链表节点个数为`奇数`和`偶数`的时候分别讨论。\n\n- 当链表节点个数为奇数\n\n![img](F:%5Calgorithm%5Cimage%5C9.png)\n\n试着模拟一下， fast 为空的时候，停止循环, 状态如下:\n\n![img](F:%5Calgorithm%5Cimage%5C10.png)\n\n- 当链表节点个数为偶数\n\n![img](F:%5Calgorithm%5Cimage%5C11.png)\n\n模拟走一遍，当 fast.next 为空的时候，停止循环，状态如下:\n\n![img](F:%5Calgorithm%5Cimage%5C12.png)\n\n对于 `fast 为空`和`fast.next为空`两个条件，在奇数的情况下，总是 `fast为空`先出现，偶数的情况下，总是`fast.next`先出现.\n\n也就是说: 一旦`fast为空`, 链表节点个数一定为奇数，否则为偶数。因此两种情况可以合并来讨论，当 fast 为空或者 fast.next 为空，循环就可以终止了。\n\n\n\n```javascript\nvar isPalindrome = function(head) {\n    var dummy = slow = fast = new ListNode(0)\n    dummy.next = head\n    while(fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n    }\n    var back = slow.next\n    slow.next = null\n    var reverse = function(prev, cur){\n        if(!cur) return prev\n        var tmp = cur.next\n        cur.next = prev\n        return reverse(cur, tmp)\n    }\n    var rback = reverse(null, back)\n    for(;rback != null; rback = rback.next, head = head.next){\n        if(rback.val !== head.val) return false \n    }\n    return true\n};\n```\n\n## 链表排列\n\n### 分隔链表\n\n[partition-list](https://leetcode-cn.com/problems/partition-list/)\n\n给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n示例:\n\n```javascript\n输入: head = 1->4->3->2->5->2, x = 3\n输出: 1->2->2->4->3->5\n```\n\n\n思路：将大于 x 的节点，放到另外一个链表，最后连接这两个链表\n\n```javascript\nvar partition = function(head, x) {\n    if(!head) return null\n    var headDummy = new ListNode()\n    var tailDummy = tail = new ListNode()\n    headDummy.next = head\n    head = headDummy\n\n    while(head.next){\n        if (head.next.val < x) {\n            head = head.next\n        } else {\n            // 移除<x节点\n            t = head.next\n            head.next = head.next.next\n            // 放到另外一个链表\n            tail.next = t\n            tail = tail.next\n        }\n    }\n    // 拼接两个链表\n    tail.next = null\n    head.next = tailDummy.next\n    return headDummy.next\n};\n```\n\n### 链表排序\n\n[sort-list](https://leetcode-cn.com/problems/sort-list/)\n\n> 在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n\n**示例 :**\n\n```\n输入: 4->2->1->3\n输出: 1->2->3->4\n```\n\n```javascript\nvar sortList = function(head) {\n    return mergeSort(head)\n};\n\nvar mergeSort = function(head){\n    if(!head || !head.next) return head\n    var middle = findMid(head)\n    var tail = middle.next\n    middle.next = null\n    var left = mergeSort(head)\n    var right = mergeSort(tail)\n    var result = mergeTwoLists(left, right)\n    return result\n}\n\nvar findMid = function(head){\n    var fast = head.next\n    var slow = head\n    while(fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return slow\n}\n\nvar mergeTwoLists = function(l1, l2) {\n    if(l1 == null) return l2;\n    if(l2 == null) return l1;\n    let p = dummyHead = new ListNode();\n    let p1 = l1, p2 = l2;\n    while(p1 && p2) {\n        if(p1.val > p2.val) {\n            p.next = p2;\n            p = p.next;\n            p2 = p2.next;\n        }else {\n            p.next = p1;\n            p = p.next;\n            p1 = p1.next;\n        }\n    }\n    // 循环完成后务必检查剩下的部分\n    if(p1) p.next = p1;\n    else p.next = p2;\n    return dummyHead.next;\n};\n```\n\n### 重排链表\n\n[reorder-list](https://leetcode-cn.com/problems/reorder-list/)\n\n> 给定一个单链表 *L*：*L*0→*L*1→…→*L**n*-1→*L*n ，\n> 将其重新排列后变为： *L*0→*L**n*→*L*1→*L**n*-1→*L*2→*L**n*-2→…\n\n**示例 1:**\n\n```\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n```\n\n**思路**\n\n寻找中间节点，将后半部分反转，再与前半部分交替排列\n\n```javascript\nvar reorderList = function(head) {\n    if(!head) return head\n    var middle = findMid(head)\n    var tail = reverse(middle.next)\n    middle.next = null\n    head = mergeTwoLists(head, tail)\n    return head\n};\n\nvar reverse = function(head){\n    if(!head || !head.next) return head\n    var cur = head\n    var prev = null\n    while(cur){\n        var next = cur.next\n        cur.next = prev\n        prev = cur\n        cur = next\n    }\n    return prev\n}\n\nvar findMid = function(head){\n    var fast = head.next\n    var slow = head\n    while(fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return slow\n}\n\nvar mergeTwoLists = function(l1, l2) {\n    if(l1 == null) return l2;\n    if(l2 == null) return l1;\n    let p = dummyHead = new ListNode();\n    let p1 = l1, p2 = l2;\n    let toggole = false\n    while(p1 && p2) {\n        if(toggole) {\n            p.next = p2;\n            p = p.next;\n            p2 = p2.next;\n            toggole = false\n        }else {\n            p.next = p1;\n            p = p.next;\n            p1 = p1.next;\n            toggole = true\n        }\n    }\n    // 循环完成后务必检查剩下的部分\n    if(p1) p.next = p1;\n    else p.next = p2;\n    return dummyHead.next;\n};\n```\n\n## 链表复制\n\n[copy-list-with-random-pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)\n\n> 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。\n\n**示例 ：**\n\n![img](F:%5Calgorithm%5Cimage%5C13.png)\n\n```javascript\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n```\n\n**思路**：1、hash 表存储指针，2、复制节点跟在原节点后面\n\n```javascript\n//hash\nvar copyRandomList = function(head){\n    if(!head) return null\n    var node = head\n    var map = new Map()\n    while(node){\n        var clone = new Node(node.val, null, null)\n        map.set(node, clone)\n        node = node.next\n    }\n\n    node = head\n    while(node){\n        map.get(node).next = node.next === null?null:map.get(node.next)\n        map.get(node).random = map.get(node.random)\n        node = node.next\n    }\n    return map.get(head)\n}\n\n//思路2\nvar copyRandomList = function(head) {\n    if(!head) return null\n    var cur = head\n    while(cur){\n        var clone = new Node(cur.val,cur.next, null)\n        var tmp = cur.next\n        cur.next = clone\n        cur = tmp\n    }\n    cur = head\n    while(cur){\n        if(cur.random) cur.next.random = cur.random.next\n        cur = cur.next.next\n    }\n    cur = head\n    var cloneHead = cur.next\n    while(cur && cur.next){\n        var tmp = cur.next\n        cur.next = cur.next.next\n        cur = tmp\n    }\n    return cloneHead\n};\n```\n\n## 链表求和\n\n[sum-lists-lcci](https://leetcode-cn.com/problems/sum-lists-lcci/)\n\n给定两个用链表表示的整数，每个节点包含一个数位。\n\n这些数位是反向存放的，也就是个位排在链表首部。\n\n编写函数对这两个整数求和，并用链表形式返回结果。\n\n**示例：**\n\n```\n输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295\n输出：2 -> 1 -> 9，即912\n```\n\n```javascript\nvar addTwoNumbers = function(l1, l2) {\n    var res = cur = new ListNode(0)\n    var carry = sum = 0\n    while(l1 || l2){\n        var val1 = l1===null?0:l1.val\n        var val2 = l2===null?0:l2.val\n        var num = val1+val2+carry\n        carry = Math.floor(num/10)\n        cur.next = new ListNode(num%10)\n        l1 = l1===null?null:l1.next\n        l2 = l2===null?null:l2.next\n        cur = cur.next\n    }\n    if(carry===1) cur.next = new ListNode(carry)\n    return res.next\n};\n```\n\n**进阶**\n\n假设这些数位是正向存放的，请再做一遍。\n\n示例：\n\n```javascript\n输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295\n输出：9 -> 1 -> 2，即912\n```\n\n```javascript\nvar addTwoNumbers = function(l1,l2){\n    var stack1 = []\n    var stack2 = []\n    var carry = sum = 0\n    while(l1){\n        stack1.push(l1.val)\n        l1=l1.next\n    }\n    while(l2){\n        stack2.push(l2.val)\n        l2 =l2.next\n    }\n    var res = cur = new ListNode(0)\n    while(stack1.length!=0 || stack2.length!=0){\n        var val1 = stack1.length==0?0:stack1.pop()\n        var val2 = stack2.length==0?0:stack2.pop()\n        var num = val1+val2+carry\n        carry = Math.floor(num/10)\n        cur.next = new ListNode(num%10)\n        cur =cur.next\n    }\n    if(carry===1) cur.next = new ListNode(carry)\n    return reverse(null,res.next)\n}\nvar reverse = function(prev, cur){\n    if(!cur) return prev\n    var next = cur.next\n    cur.next = prev\n    return reverse(cur, next)\n}\n```\n\n\n\n## 重要参考\n\n[algorithm-pattern](https://greyireland.gitbook.io/algorithm-pattern/shu-ju-jie-gou-pian/linked_list)\n\n[神三元掘金](https://juejin.im/post/6844904061947346957#heading-39)\n\n', '数据结构与算法【链表篇】', 1598976000, 20);
INSERT INTO `article` VALUES (17, 7, 'webpack 4.x', '# webpack\n\n## 概念篇\n\n### 安装\n\n```javascript\nnpm install webpack webpack-cli -g  //全局安装命令行工具\nnpm install webpack -d //项目内使用\n```\n\n在一个项目中（项目中确保有 `package.json` 文件）安装好 webpack 后，创建一个 `./src/index.js` 文件，可以写任意 JS 代码。然后执行 `npm run build` 或 `yarn build` 命令，就会发现增加了一个 `dist` 目录，里面存放的就是 webpack 构建好的 `main.js` 文件。\n\n### 基本概念\n\n![img](https://img.kancloud.cn/2b/d3/2bd341d8d2d5db903750e08332d7f523_1896x755.jpg)\n\n> webpack 本质是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块打包。\n\n#### 入口\n\n如上图所示，在多个代码模块中会有一个起始的 `.js` 文件，这个便是 webpack 构建的入口。webpack 会读取这个文件，并从它开始解析依赖，然后进行打包。默认的入口文件是 `./src/index.js` 。常见项目中，如果是单页面应用，可能的入口只有一个；如果是多页面项目，经常是一个页面一个入口。\n\n入口可以使用 `entry` 字段来进行配置。\n\n```js\nmodule.exports = {\n  entry: \'./src/index.js\' \n}\n\n// 上述配置等同于\nmodule.exports = {\n  entry: {\n    main: \'./src/index.js\'\n  }\n}\n\n// 或者配置多个入口\nmodule.exports = {\n  entry: {\n    foo: \'./src/page-foo.js\',\n    bar: \'./src/page-bar.js\', \n    // ...\n  }\n}\n\n// 使用数组来对多个文件进行打包,可以理解为多个文件作为一个入口\nmodule.exports = {\n  entry: {\n    main: [\n      \'./src/foo.js\',\n      \'./src/bar.js\'\n    ]\n  }\n}\n```\n\n#### loader\n\nwebpack 中提供一种处理多种文件格式的机制，便是使用 loader。我们可以把 loader 理解为是一个**转换器**，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块。\n\n举个例子，在没有添加额外插件的情况下，webpack 会默认把所有依赖打包成 js 文件，如果入口文件依赖一个 .hbs 的模板文件以及一个 .css 的样式文件，那么我们需要 handlebars-loader 来处理 .hbs 文件，需要 css-loader 来处理 .css 文件（这里其实还需要 style-loader），最终把不同格式的文件都解析成 js 代码，以便打包后在浏览器中运行。\n\n当我们需要使用不同的 loader 来解析处理不同类型的文件时，我们可以在 `module.rules` 字段下来配置相关的规则，例如使用 Babel 来处理 .js 文件：\n\n```js\nmodule: {\n  // ...\n  rules: [\n    {\n      test: /\\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀\n      include: [\n        path.resolve(__dirname, \'src\') // 指定哪些路径下的文件需要经过 loader 处理\n      ],\n      use: \'babel-loader\', // 指定使用的 loader\n    },\n  ],\n}\n```\n\nloader 支撑着 webpack 来处理文件的多样性。\n\n#### plugin\n\n在 webpack 的构建流程中，plugin 用于处理更多其他的一些构建任务。可以这么理解，模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成。通过添加我们需要的 plugin，可以满足更多构建中特殊的需求。例如，要使用压缩 JS 代码的 uglifyjs-webpack-plugin 插件，只需在配置中通过 `plugins` 字段添加新的 plugin 即可：\n\n```js\nconst UglifyPlugin = require(\'uglifyjs-webpack-plugin\')\n\nmodule.exports = {\n  plugins: [\n    new UglifyPlugin()\n  ],\n}\n```\n\nplugin 理论上可以干涉 webpack 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求。\n\n#### 输出\n\nwebpack 的输出即指 webpack 最终构建出来的静态文件。当然，构建结果的文件名、路径等都是可以配置的，使用 `output` 字段：\n\n```js\nmodule.exports = {\n  // ...\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'bundle.js\',\n  },\n}\n\n// 或者多个入口生成不同文件\nmodule.exports = {\n  entry: {\n    foo: \'./src/foo.js\',\n    bar: \'./src/bar.js\',\n  },\n  output: {\n    filename: \'[name].js\',\n    path: __dirname + \'/dist\',\n  },\n}\n\n// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存\nmodule.exports = {\n  // ...\n  output: {\n    filename: \'[name].js\',\n    path: __dirname + \'/dist/[hash]\',\n  },\n}\n```\n\n我们一开始直接使用 webpack 构建时，默认创建的输出内容就是 `./dist/main.js`。\n\n### 一个简单的配置示例\n\nwebpack 运行时默认读取项目下的 `webpack.config.js` 文件作为配置。\n\n```js\n// webpack.config.js\nconst path = require(\'path\')\nconst UglifyPlugin = require(\'uglifyjs-webpack-plugin\')\n\nmodule.exports = {\n  entry: \'./src/index.js\',\n\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'bundle.js\',\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [\n          path.resolve(__dirname, \'src\')\n        ],\n        use: \'babel-loader\',\n      },\n    ],\n  },\n\n  // 代码模块路径解析的配置\n  resolve: {\n    modules: [\n      \"node_modules\",\n      path.resolve(__dirname, \'src\')\n    ],\n\n    extensions: [\".wasm\", \".mjs\", \".js\", \".json\", \".jsx\"],\n  },\n\n  plugins: [\n    new UglifyPlugin(), \n    // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码\n    // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件\n    // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数\n  ],\n}\n\n```\n\nwebpack 的配置其实是一个 Node.js 的脚本，这个脚本对外暴露一个配置对象，webpack 通过这个对象来读取相关的一些配置。创建了 `webpack.config.js` 后再执行 webpack 命令，webpack 就会使用这个配置文件的配置了。\n\n## 基本需求篇\n\n### 基本需求\n\n- 构建我们发布需要的 HTML、CSS、JS 文件\n- 使用 CSS 预处理器来编写样式\n- 处理和压缩图片\n- 使用 Babel 来支持 ES 新特性\n- 本地提供静态服务以方便开发调试\n\n### 关联 HTML\n\nwebpack  默认从作为入口的 .js 文件进行构建（更多是基于 SPA 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 `script` 标签直接引用构建好的 JS 文件，如：\n\n```html\n<script src=\"./dist/bundle.js\"></script>\n```\n\n但是，如果我们的文件名或者路径会变化，例如使用 `[hash]` 来进行命名，那么最好是将 HTML 引用路径和我们的构建结果关联起来，这个时候我们可以使用 [html-webpack-plugin](https://doc.webpack-china.org/plugins/html-webpack-plugin/)。\n\nhtml-webpack-plugin 是一个独立的 node package，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中：\n\n```js\nnpm install html-webpack-plugin -D \n```\n\n然后在 webpack 配置中，将 html-webpack-plugin 添加到 plugins 列表中：\n\n```js\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({//不添加参数会使用默认html模版\n        filename: \'index.html\', // 配置输出文件名和路径\n      	template: \'assets/index.html\', // 配置文件模板\n    }),\n  ],\n}\n```\n\n如果需要添加多个页面关联，那么实例化多个 `html-webpack-plugin`， 并将它们都放到 `plugins` 字段数组中就可以了。\n\n### 构建 CSS\n\n我们编写 CSS，并且希望使用 webpack 来进行构建，为此，需要在配置中引入 loader 来解析和处理 CSS 文件：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.css/,\n        include: [\n          path.resolve(__dirname, \'src\'),\n        ],\n        use: [\n          \'style-loader\',\n          \'css-loader\',\n        ],\n      },\n    ],\n  }\n}\n```\n\n> style-loader 和 css-loader 都是单独的 node package，需要安装。\n\n我们创建一个 index.css 文件，并在 index.js 中引用它，然后进行构建。\n\n```js\nimport \"./index.css\"\n```\n\n可以发现，构建出来的文件并没有 CSS，先来看一下新增两个 loader 的作用：\n\n- `css-loader` 负责解析 CSS 代码，主要是为了处理 CSS 中的依赖，例如 `@import` 和 `url()` 等引用外部文件的声明；\n- `style-loader` 会将 `css-loader` 解析的结果转变成 JS 代码，运行时动态插入 `style` 标签来让 CSS 代码生效。\n\n经由上述两个 loader 的处理后，CSS 代码会转变为 JS，和 index.js 一起打包了。\n\n如果需要单独把 CSS 文件分离出来，可以使用 `mini-css-extract-plugin` 插件。\n\n```js\nconst MiniCssExtractPlugin = require(\'mini-css-extract-plugin\');\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n            MiniCssExtractPlugin.loader,\n            \'css-loader\',\n        ], \n      },\n    ],\n  },\n  plugins: [\n    new MiniCssExtractPlugin(),\n  ],\n}\n```\n\n### CSS 预处理器\n\n在上述使用 CSS 的基础上，通常我们会使用 Less/Sass 等 CSS 预处理器，webpack 可以通过添加对应的 loader 来支持，以使用 Less 为例，我们可以在官方文档中找到对应的 [loader](https://doc.webpack-china.org/loaders/less-loader)。\n\n我们需要在上面的 webpack 配置中，添加一个配置来支持解析后缀为 `.less` 的文件：\n\n```javascript\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: [\n            MiniCssExtractPlugin.loader,\n            \'css-loader\',\n            \'less-loader\'\n        ]\n      },\n    ],\n  },\n  // ...\n}\n```\n\n### 处理图片文件\n\n在前端项目的样式中总会使用到图片，虽然我们已经提到 css-loader 会解析样式中用 `url()` 引用的文件路径，但是图片对应的 jpg/png/gif 等文件格式，webpack 处理不了。是的，我们只要添加一个处理图片的 loader 配置就可以了，现有的 file-loader 就是个不错的选择。\n\nfile-loader 可以用于处理很多类型的文件，它的主要作用是**直接输出文件**，把构建后的文件路径返回。配置很简单，在 `rules`中添加一个字段，增加图片类型文件的解析配置：\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: \'file-loader\',\n            options: {},\n          },\n        ],\n      },\n    ],\n  },\n}\n```\n\n更多关于 file-loader 的配置可以参考官方文档 [file-loader](https://webpack.js.org/loaders/file-loader/)。\n\n### 使用 Babel\n\n[Babel](http://babeljs.io/) 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/, // 支持 js 和 jsx\n        include: [\n          path.resolve(__dirname, \'src\'), // src 目录下的才需要经过 babel-loader 处理\n        ],\n        loader: \'babel-loader\',\n      },\n    ],\n  },\n}\n```\n\nBabel 的相关配置可以在目录下使用 .babelrc 文件来处理，详细参考 Babel 官方文档 [.babelrc](http://babeljs.io/docs/usage/babelrc/)。\n\n### 启动静态服务\n\n使用 [webpack-dev-server](https://github.com/webpack/webpack-dev-server) 在本地开启一个简单的静态服务来进行开发。\n\n在项目下安装 `webpack-dev-server`，然后添加启动命令到 package.json 中：\n\n```json\n\"scripts\": {\n  \"build\": \"webpack --mode production\",\n  \"start\": \"webpack-dev-server --mode development\"\n}\n```\n\n尝试着运行 `npm run start` 或者 `yarn start`，然后就可以访问 http://localhost:8080/ 来查看你的页面了。默认是访问 index.html，如果是其他页面要注意访问的 URL 是否正确。\n\n## 路径解析篇\n\n在 webpack 支持的前端代码模块化中，我们可以使用类似 `import * as m from \'./index.js\'` 来引用代码模块 `index.js`。引用第三方类库则是像这样：`import React from \'react\'`。webpack 构建的时候，会解析依赖后，然后再去加载依赖的模块文件，那么 webpack 如何将上述编写的 `./index.js` 或 `react` 解析成对应的模块文件路径呢？\n\n### 模块解析规则\n\n- 解析相对路径\n  1. 查找相对当前模块的路径下是否有对应文件或文件夹\n  2. 是文件则直接加载\n  3. 是文件夹则继续查找文件夹下的 package.json 文件\n  4. 有 package.json 文件则按照文件中 `main` 字段的文件名来查找文件\n  5. 无 package.json 或者无 `main` 字段则查找 `index.js` 文件\n- 解析模块名\n  查找当前文件目录下，父级目录及以上目录下的 `node_modules` 文件夹，看是否有对应名称的模块\n- 解析绝对路径（不建议使用）\n  直接查找对应路径的文件\n\n在 webpack 配置中，和模块路径解析相关的配置都在 `resolve` 字段下。\n\n```js\nmodule.exports = {\n  resolve: {\n    // ...\n  }\n}\n```\n\n### 常用配置\n\n```javascript\nresolve: {\n    \n    alias:{//①配置某个模块别名\n        util: path.resolve(__dirname, \'src/utils\')\n    },\n        \n    modules: [\"node_modules\"],\n    //对于直接声明依赖名的模块（如react），webpack 会类似 Node.js 一样进行路径搜索，搜索 node_modules 目录，这个目录就是使用 resolve.modules 字段进行配置的\n        \n    mainFields: [\"module\", \"main\"],\n    \n    extensions: [\".wasm\", \".mjs\", \".js\", \".json\", \".jsx\",\".css\"],\n    //这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js\n    //这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找\n},\n    \n//使用①\nimport \'utils/util.js\' //import \'[项目绝对路径]/src/utils/util.js\'\n```\n\n## loader 篇\n\n```js\nmodule.exports = {\n  // ...\n  rules: [ \n      {\n        resource: {//resource 的匹配条件(使用请求资源文件的绝对路径来进行匹配)\n          test: /\\.jsx?/, \n          include: [ \n            path.resolve(__dirname, \'src\'),\n          ],\n        },\n        // 如果要使用 issuer 匹配，便是 issuer: { test: ... }\n        use: \'babel-loader\',\n      },\n      // ...\n    ], \n}\n```\n\n### 规则条件匹配\n\n大多数情况下，配置 loader 的匹配条件时，只要使用 `test` 字段就好了，但为了一些复杂的条件 webpack 的规则提供了多种配置形式：\n\n- `{ test: ... }` 匹配特定条件\n- `{ include: ... }` 匹配特定路径\n- `{ exclude: ... }` 排除特定路径\n- `{ and: [...] }`必须匹配数组中所有条件\n- `{ or: [...] }` 匹配数组中任意一个条件\n- `{ not: [...] }` 排除匹配数组中所有条件\n\n上述的所谓条件的值可以是：\n\n- 字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径\n- 正则表达式：调用正则的 `test` 方法来判断匹配\n- 函数：(path) => boolean，返回 `true` 表示匹配\n- 数组：至少包含一个条件的数组\n- 对象：匹配所有属性值的条件\n\n通常我们会结合使用 `test/and` 和 `include&exclude` 来配置条件\n\n### 使用 loader 配置\n\n```js\nrules: [\n  {\n    test: /\\.less/,\n    use: [\n      \'style-loader\', // 直接使用字符串表示 loader\n      {\n        loader: \'css-loader\',\n        options: {\n          importLoaders: 1\n        },\n      }, // 用对象表示 loader，可以传递 loader 配置等\n      {\n        loader: \'less-loader\',\n        options: {\n          noIeCompat: true\n        }, // 传递 loader 配置\n      },\n    ],\n  },\n],\n```\n\n### loader 应用顺序\n\n一个匹配规则中可以配置使用多个 loader，即一个模块文件可以经过多个 loader 的转换处理，执行顺序是从最后配置的 loader 开始，一步步往前。例如，对于上面的 `less` 规则配置，一个 style.less 文件会途径 less-loader、css-loader、style-loader 处理，成为一个可以打包的模块。\n\n上述从后到前的顺序是在同一个 rule 中进行的，那如果多个 rule 匹配了同一个模块文件，loader 的应用顺序又是怎样的呢？看一份这样的配置：\n\n```js\nrules: [\n  {\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"eslint-loader\",\n  },\n  {\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"babel-loader\",\n    enforce: \'pre\'\n  },\n],\n```\n\n这样无法法保证 eslint-loader 在 babel-loader 应用前执行。webpack 在 `rules` 中提供了一个 `enforce` 的字段来配置当前 rule 的 loader 类型，没配置的话是普通类型，我们可以配置 `pre` 或 `post`，分别对应前置类型或后置类型的 loader。\n\n> eslint-loader 要检查的是人工编写的代码，如果在 babel-loader 之后使用，那么检查的是 Babel 转换后的代码，所以必须在 babel-loader 处理之前使用。\n\n还有一种行内 loader，即我们在应用代码中引用依赖时直接声明使用的 loader，如 `const json = require(\'json-loader!./file.json\')` 这种。不建议在应用开发中使用这种 loader。\n\n顾名思义，所有的 loader 按照**前置 -> 行内 -> 普通 -> 后置**的顺序执行。\n\n当项目文件类型和应用的 loader 不是特别复杂的时候，通常建议把要应用的同一类型 loader 都写在同一个匹配规则中，这样更好维护和控制。\n\n### 使用 `noParse`\n\n在 webpack 中，我们需要使用的 loader 是在 `module.rules` 下配置的，webpack 配置中的 module 用于控制如何处理项目中不同类型的模块。\n\n除了 `module.rules` 字段用于配置 loader 之外，还有一个 `module.noParse` 字段，可以用于配置哪些模块文件的内容不需要进行解析。对于一些**不需要解析依赖（即无依赖）** 的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度。\n\n> 使用 `noParse` 进行忽略的模块文件中不能使用 `import`、`require`、`define` 等导入机制。\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    noParse: /jquery|lodash/, // 正则表达式\n\n    // 或者使用 function\n    noParse(content) {\n      return /jquery|lodash/.test(content)\n    },\n  }\n}\n```\n\n`noParse` 从某种程度上说是个优化配置项，日常也可以不去使用。\n\n## plugin 篇\n\nwebpack 中的 plugin 大多都提供额外的能力，它们在 webpack 中的配置都只是把插件实例添加到 `plugins` 字段的数组中。不过由于需要提供不同的功能，不同的插件本身的配置比较多样化。\n\n### DefinePlugin\n\nDefinePlugin 是 webpack 内置的插件，可以使用 `webpack.DefinePlugin` 直接获取。\n\n这个插件用于创建一些在编译时可以配置的**全局常量**，这些常量的值我们可以在 webpack 的配置中去指定，例如：\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.DefinePlugin({\n      PRODUCTION: JSON.stringify(true), // const PRODUCTION = true\n      VERSION: JSON.stringify(\'5fa3b9\'), // const VERSION = \'5fa3b9\'\n      BROWSER_SUPPORTS_HTML5: true, // const BROWSER_SUPPORTS_HTML5 = \'true\'\n    }),\n  ],\n}\n```\n\n有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：\n\n```js\nconsole.log(\"Running App version \" + VERSION);\n```\n\n配置规则\n\n- 如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值\n- 如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 `true`，最后的结果是 `\'true\'`\n- 如果配置的是一个对象字面量，那么该对象的所有 key 会以同样的方式去定义\n\n社区中关于 DefinePlugin 使用得最多的方式是定义环境变量，例如 `PRODUCTION = true` 或者 `__DEV__ = true` 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 `react` 等。\n\n### copy-webpack-plugin\n\n我们一般会把开发的所有源码和资源文件放在 `src/` 目录下，构建的时候产出一个 `build/` 目录，通常会直接拿 build 中的所有文件来发布。有些文件没经过 webpack 处理，但是我们希望它们也能出现在 build 目录下，这时就可以使用 `CopyWebpackPlugin` 来处理了。\n\n```js\nconst CopyWebpackPlugin = require(\'copy-webpack-plugin\')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns:[\n          { from: \'src/file.txt\', to: \'build/file.txt\', }, // 顾名思义，from 配置来源，to 配置目标路径\n          { from: \'src/*.ico\', to: \'build/*.ico\' }, // 配置项可以使用 glob\n          // 可以配置很多项复制规则\n      ]\n    }),\n  ],\n}\n```\n\n更多的配置内容可以参考 [copy-webpack-plugin](https://github.com/webpack-contrib/copy-webpack-plugin)。\n\n### mini-css-extract-plugin\n\n前面已经介绍，用于将依赖的 CSS 分离出来成为单独文件。还有一个叫做 `extract-text-webpack-plugin` 也可以用来做相似的工作。\n\n### ProvidePlugin\n\nProvidePlugin 也是一个 webpack 内置的插件。\n\n该组件用于引用某些模块作为应用运行时的变量，从而不必每次都用 `require` 或者 `import`\n\n要自动加载 `jquery`，我们可以将两个变量都指向对应的 node 模块：\n\n```javascript\nnew webpack.ProvidePlugin({\n  $: \'jquery\', //import \'jquery\'\n  _map: [\'lodash\', \'map\']//import {map} from \'lodash\'\n})\n```\n\n然后在我们任意源码中：\n\n```javascript\n// in a module\n$(\'#item\'); // <= 起作用\n// $ 自动被设置为 \"jquery\" 输出的内容\n```\n\n### IgnorePlugin\n\n webpack 内置的插件。用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去。\n\n- `requestRegExp` 匹配(test)资源请求路径的正则表达式。\n- `contextRegExp` （可选）匹配(test)资源上下文（目录）的正则表达式。\n\n```js\nnew webpack.IgnorePlugin(requestRegExp, [contextRegExp])\n```\n\n## webpack-dev-server 篇\n\n在构建代码并部署到生产环境之前，我们需要一个本地环境，用于运行我们开发的代码。这个环境相当于提供了一个简单的服务器，用于访问 webpack 构建好的静态文件，我们日常开发时可以使用它来调试前端代码。`webpack-dev-server` 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 `hot reload` 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果。\n\n基础使用在【基本需求篇-启动静态服务 】介绍了。\n\n### webpack-dev-server 的配置\n\n在 webpack 的配置中，可以通过 `devServer` 字段来配置 webpack-dev-server，如端口设置、启动 gzip 压缩等，这里简单讲解几个常用的配置。\n\n* `public` 字段用于指定静态服务的域名。\n\n* `port` 字段用于指定静态服务的端口。\n\n* `publicPath` 字段用于指定构建好的静态文件在浏览器中用什么路径去访问。**如果你使用了 HMR，那么要设置 `publicPath` 就必须使用完整的 URL**。\n\n* `proxy` 用于配置 webpack-dev-server 将特定 URL 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如：\n\n  ```javascript\n  proxy: {\n    \'/api\': {\n      target: \"http://localhost:3000\", // 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上\n      pathRewrite: { \'^/api\': \'\' }, // 把 URL 中 path 部分的 `api` 移除掉\n    },\n  }\n  ```\n\n  webpack-dev-server 的 proxy 功能是使用 [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware) 来实现的，如果需要更详细的 proxy 配置，可以参考官方文档 [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware#example)。\n\n* `contentBase` 用于配置提供额外静态文件内容的目录，之前提到的 `publicPath` 是配置构建好的结果以什么样的路径去访问，而 `contentBase` 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）。`publicPath` 的优先级高于 `contentBase`。推荐使用绝对路径：\n\n  ```javascript\n  // 使用当前目录下的 public\n  contentBase: path.join(__dirname, \"public\") \n  ```\n\n* `before` 和 `after` 配置用于在 webpack-dev-server 定义额外的中间件，如\n\n  ```javascript\n  before(app){\n    app.get(\'/some/path\', function(req, res) { // 当访问 /some/path 路径时，返回自定义的 json 数据\n      res.json({ custom: \'response\' })\n    })\n  }\n  ```\n\n  `before` 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock。\n\n  `after` 在 webpack-dev-server 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理。\n\n* `hot`\n\n  ```js\n  hot: true //启用 webpack 的模块热替换特性\n  ```\n\n### webpack-dev-middleware\n\n如果你熟悉使用 Node.js 来开发 Web 服务，使用过 [Express](https://expressjs.com/) 或者 [Koa](http://koajs.com/)，那么对中间件的概念应该会有所了解。\n\n简而言之，中间件就是在 Express 之类的 Web 框架中实现各种各样功能（如静态文件访问）的这一部分函数。多个中间件可以一起协同构建起一个完整的 Web 服务器。\n\n不熟悉 Express 中间件概念的同学可以参考 Express 的官方文档 [使用中间件](http://www.expressjs.com.cn/guide/using-middleware.html)。\n\n[webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware) 就是在 Express 中提供 webpack-dev-server 静态服务能力的一个中间件，我们可以很轻松地将其集成到现有的 Express 代码中去，就像添加一个 Express 中间件那么简单。\n\n首先安装 webpack-dev-middleware 依赖：\n\n```js\nnpm install webpack-dev-middleware --save-dev\n```\n\n接着创建一个 Node.js 服务的脚本文件，如 app.js：\n\n```js\nconst webpack = require(\'webpack\')\nconst middleware = require(\'webpack-dev-middleware\')\nconst webpackOptions = require(\'./webpack.config.js\') // webpack 配置文件的路径\n\n// 本地的开发环境默认就是使用 development mode\nwebpackOptions.mode = \'development\'\n\nconst compiler = webpack(webpackOptions)\nconst express = require(\'express\')\nconst app = express()\n\napp.use(middleware(compiler, {\n  // webpack-dev-middleware 的配置选项\n}))\n\n// 其他 Web 服务中间件\n// app.use(...)\n\napp.listen(3000, () => console.log(\'Example app listening on port 3000!\'))\n```\n\n然后用 Node.js 运行该文件即可：\n\n```js\nnode app.js # 使用刚才创建的 app.js 文件\n```\n\n使用 webpack-dev-server 的好处是相对简单，直接安装依赖后执行命令即可，而使用 webpack-dev-middleware 的好处是可以在既有的 Express 代码基础上快速添加 webpack-dev-server 的功能，同时利用 Express 来根据需要添加更多的功能，如 mock 服务、代理 API 请求等。\n\n其实 webpack-dev-server 也是基于 Express 开发的，前面提及的 webpack-dev-server 中 `before` 或 `after` 的配置字段，也可以用于编写特定的中间件来根据需要添加额外的功能。\n\n## 开发和生产环境篇\n\n我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，包含 sourcemap 文件；另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 mock 等工作。\n\n当你指定使用 production mode 时，默认会启用各种性能优化的功能，包括构建结果优化以及 webpack 运行性能优化，而如果是 development mode 的话，则会开启 debug 工具，运行时打印详细的错误信息，以及更加快速的增量编译构建。\n\n### 在配置文件中区分 mode\n\n之前我们的配置文件都是直接对外暴露一个 JS 对象，这种方式暂时没有办法获取到 webpack 的 mode 参数，我们需要更换一种方式来处理配置。根据官方的文档[多种配置类型](https://doc.webpack-china.org/configuration/configuration-types/)，配置文件可以对外暴露一个函数，因此我们可以这样做：\n\n```js\nmodule.exports = (env, argv) => ({\n  // ... 其他配置\n  optimization: {\n    minimize: false,\n    // 使用 argv 来获取 mode 参数的值\n    minimizer: argv.mode === \'production\' ? [\n      new UglifyJsPlugin({ /* 你自己的配置 */ }), \n      // 仅在我们要自定义压缩配置时才需要这么做\n      // mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin\n    ] : [],\n  },\n})\n```\n\n这样获取 mode 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 loader 或 plugin 做额外的配置就可以了。\n\n### 运行时的环境变量\n\n我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 `process.env.NODE_ENV` 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 debug 信息。\n\n下面这个简单的例子，在应用开发的代码中实现一个简单的 console 打印封装：\n\n```js\nexport default function log(...args) {\n  if (process.env.NODE_ENV === \'development\' && console && console.log) {\n    console.log.apply(console, args)\n  }\n}\n```\n\n### 常见的环境差异配置\n\n前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的 webpack 构建差异配置：\n\n- 生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件\n- 生产环境需要压缩 HTML/CSS/JS 代码\n- 生产环境需要压缩图片\n- 开发环境需要生成 sourcemap 文件\n- 开发环境需要打印 debug 信息\n- 开发环境需要 live reload 或者 hot reload 的功能\n\n以上是常见的构建环境需求差异，可能更加复杂的项目中会有更多的构建需求（如划分静态域名等），但是我们都可以通过判断环境变量来实现这些有环境差异的构建需求。\n\nwebpack 4.x 的 mode 已经提供了上述差异配置的大部分功能，mode 为 production 时默认使用 JS 代码压缩，而 mode 为 development 时默认启用 hot reload，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 loader 和 plugin 做区分配置就可以了。\n\n### 拆分配置\n\n前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 webpack 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 webpack 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下：\n\n- webpack.base.js：基础部分，即多个文件中共享的配置\n- webpack.development.js：开发环境使用的配置\n- webpack.production.js：生产环境使用的配置\n- webpack.test.js：测试环境使用的配置\n\n一些复杂的项目可能会有更多配置。这里介绍一下如何处理这样的配置拆分。\n\n首先我们要明白，对于 webpack 的配置，其实是对外暴露一个 JS 对象，所以对于这个对象，我们都可以用 JS 代码来修改它，例如：\n\n```js\nconst config = {\n  // ... webpack 配置\n}\n\n// 我们可以修改这个 config 来调整配置，例如添加一个新的插件\nconfig.plugins.push(new YourPlugin());\n\nmodule.exports = config;\n```\n\n当然，如果是对外暴露一个 JS 函数的话，像本小节第一个例子那样，那么修改配置就更加容易了，这里不再举例说明。\n\n因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 [webpack-merge](https://github.com/survivejs/webpack-merge)。\n\n我们的 webpack 配置基础部分，即 webpack.base.js 应该大致是这样的：\n\n```js\nmodule.exports = {\n  entry: \'...\',\n  output: {\n    // ...\n  },\n  resolve: {\n    // ...\n  },\n  module: {\n    // 这里是一个简单的例子，后面介绍 API 时会用到\n    rules: [\n      {\n        test: /\\.js$/, \n        use: [\'babel\'],\n      },\n    ],\n    // ...\n  },\n  plugins: [\n    // ...\n  ],\n}\n```\n\n然后 webpack.development.js 需要添加 loader 或 plugin，就可以使用 webpack-merge 的 API，例如：\n\n```js\nconst { smart } = require(\'webpack-merge\')\nconst webpack = require(\'webpack\')\nconst base = require(\'./webpack.base.js\')\n\nmodule.exports = smart(base, {\n  module: {\n    rules: [\n      // 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理\n      // 和上述 base 配置合并后，这里会是 { test: /\\.js$/, use: [\'babel\', \'coffee\'] }\n      // 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值\n      {\n        test: /\\.js$/,\n        use: [\'coffee\'],\n      },\n      // ...\n    ],\n  },\n  plugins: [\n    // plugins 这里的数组会和 base 中的 plugins 数组进行合并\n    new webpack.DefinePlugin({\n      \'process.env.NODE_ENV\': JSON.stringify(process.env.NODE_ENV),\n    }),\n  ],\n})\n```\n\n可见 webpack-merge 提供的 `smart` 方法，可以帮助我们更加轻松地处理 loader 配置的合并。webpack-merge 还有其他 API 可以用于自定义合并行为，这里就不详细介绍了，需要深入了解的同学可以查阅官方文档 [webpack-merge](https://github.com/survivejs/webpack-merge)。\n\n##　模块热替换HMR篇\n\n> HMR 全称是 Hot Module Replacement，即模块热替换。在这个概念出来之前，我们使用过 Hot Reloading，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 Hot Reloading，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，HMR 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率。\n\n### 配置使用HMR\n\n```JS\nconst webpack = require(\'webpack\')\n\nmodule.exports = {\n  // ...\n  devServer: {\n    hot: true // dev server 的配置要启动 hot，或者在命令行中带参数开启\n  },\n  plugins: [\n    // ...\n    new webpack.NamedModulesPlugin(), // 用于启动 HMR 时可以显示模块的相对路径\n    new webpack.HotModuleReplacementPlugin(), // Hot Module Replacement 的插件\n  ],\n}\n```\n\n## 优化资源篇【图片和代码】\n\n我们总是希望浏览器在加载页面时用的时间越短越好，所以构建出来的文件应该越少越小越好，一来减少浏览器需要发起请求的数量，二来减少下载静态资源的时间。\n\n其实 webpack 把多个代码文件打包成几个必需的静态资源，已经很大程度减少了静态资源请求数量了，接下来我们来介绍下如何使用 webpack 实现更多的前端资源加载的优化需求。\n\n### CSS Sprites\n\n[CSS Sprites](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS) 技术是前端领域一种很常见的用于减少图片资源请求数的优化方式\n\nwebpack 4.x 需要配合使用 [postcss](https://github.com/postcss/postcss) 和 [postcss-sprites](https://github.com/2createStudio/postcss-sprites)，才能实现 CSS Sprites 的相关构建。\n\n或者使用 [webpack-spritesmith](https://github.com/mixtur/webpack-spritesmith) 或者 [sprite-webpack-plugin](https://github.com/kezoo/sprite-webpack-plugin)。\n\n### 图片压缩\n\n我们之前提及使用 file-loader 来处理图片文件，在此基础上，我们再添加一个 [image-webpack-loader](https://github.com/tcoopman/image-webpack-loader) 来压缩图片文件。简单的配置如下：\n\n```javascript\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /.*\\.(gif|png|jpe?g|svg|webp)$/i,\n        use: [\n          {\n            loader: \'file-loader\',\n            options: {}\n          },\n          {\n            loader: \'image-webpack-loader\',\n            options: {\n              mozjpeg: { // 压缩 jpeg 的配置\n                progressive: true,\n                quality: 65\n              },\n              optipng: { // 使用 imagemin-optipng 压缩 png，enable: false 为关闭\n                enabled: false,\n              },\n              pngquant: { // 使用 imagemin-pngquant 压缩 png\n                quality: \'65-90\',\n                speed: 4\n              },\n              gifsicle: { // 压缩 gif 的配置\n                interlaced: false,\n              },\n              webp: { // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式\n                quality: 75\n              },\n          },\n        ],\n      },\n    ],\n  },\n}\n```\n\nimage-webpack-loader 的压缩是使用 [imagemin](https://github.com/imagemin) 提供的一系列图片压缩类库来处理的，如果需要进一步了解详细的配置，可以查看对应类库的官方文档 [usage of image-webpack-loader](https://github.com/tcoopman/image-webpack-loader#usage)。\n\n### 使用 DataURL\n\n有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 CSS Sprites 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 url-loader 来处理这些很小的图片。\n\n[url-loader](https://github.com/webpack-contrib/url-loader) 和 [file-loader](https://github.com/webpack-contrib/file-loader) 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，url-loader 会将其转换为一个 base64 编码的 DataURL，配置如下：\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: \'url-loader\',\n            options: {\n              limit: 8192, // 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理\n            },\n          },\n        ],\n      },\n    ],\n  },\n}\n```\n\n更多关于 url-loader 的配置可以参考官方文档 [url-loader](https://github.com/webpack-contrib/url-loader)，一般情况仅使用 `limit` 即可。\n\n### 代码压缩\n\n对于 **HTML 文件**，之前介绍的 html-webpack-plugin 插件可以帮助我们生成需要的 HTML 并对其进行压缩：\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \'index.html\', // 配置输出文件名和路径\n      template: \'assets/index.html\', // 配置文件模板\n      minify: { // 压缩 HTML 的配置\n        minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码\n        minifyJS: true // 压缩 HTML 中出现的 JS 代码\n      }\n    }),\n  ],\n}\n```\n\n如上，使用 `minify` 字段配置就可以使用 HTML 压缩，这个插件是使用 [html-minifier](https://github.com/kangax/html-minifier#options-quick-reference) 来实现 HTML 代码压缩的，`minify` 下的配置项直接透传给 html-minifier，配置项参考 html-minifier 文档即可。\n\n对于 **CSS 文件**，我们之前介绍过用来处理 CSS 文件的 css-loader，也提供了压缩 CSS 代码的功能：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.css/,\n        include: [\n          path.resolve(__dirname, \'src\'),\n        ],\n        use: [\n          \'style-loader\',\n          {\n            loader: \'css-loader\',\n            options: {\n              minimize: true, // 使用 css 的压缩功能\n            },\n          },\n        ],\n      },\n    ],\n  }\n}\n```\n\n在 css-loader 的选项中配置 `minimize` 字段为 `true` 来使用 CSS 压缩代码的功能。css-loader 是使用 [cssnano](http://cssnano.co/) 来压缩代码的，`minimize` 字段也可以配置为一个对象，来将相关配置传递给 cssnano。更多详细内容请参考 [cssnano](http://cssnano.co/) 官方文档。\n\n## 优化资源篇【代码分离】\n\n### 分离 CSS 代码\n\n* mini-css-extract-plugin 插件\n\n* 使用 [extract-text-webpack-plugin](https://doc.webpack-china.org/plugins/extract-text-webpack-plugin) 插件\n\n为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。\n\n假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。\n\n还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观。\n\n因此当我们考虑更好地利用缓存来加速静态资源访问时，会尝试把一些公共资源单独分离开来，利用缓存加速，以避免重复的加载。除了公共的 CSS 文件或者图片资源等，当我们的 JS 代码文件过大的时候，也可以用代码文件拆分的办法来进行优化。\n\n### 分离 JS 代码文件\n\n简单地配置：\n\n``` js\nmodule.exports = {\n  // ... webpack 配置\n\n  optimization: {\n    splitChunks: {\n      chunks: \"all\", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件\n    },\n  },\n}\n```\n\n拆分文件是为了更好地利用缓存，分离公共类库很大程度上是为了让多页面利用缓存，从而减少下载的代码量，同时，也有代码变更时可以利用缓存减少下载代码量的好处\n\n## 优化资源篇【控制JS大小】\n\n### 按需加载模块\n\n前面讲述了如何把大的代码文件进行拆分，抽离出多个页面共享的部分，但是当你的 Web 应用是单个页面，并且极其复杂的时候，你会发现有一些代码并不是每一个用户都需要用到的。你可能希望将这一部分代码抽离出去，仅当用户真正需要用到时才加载，这个时候就需要用到 webpack 提供的一个优化功能 —— 按需加载代码模块。\n\n在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 [dynamic-import](https://github.com/tc39/proposal-dynamic-import) 来编写代码即可，webpack 会自动处理使用该语法编写的模块：\n\n```js\n// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象\n// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用\nimport(/* webpackChunkName: \"lodash\" */ \'lodash\').then((_) => { \n  console.log(_.lash([1, 2, 3])) // 打印 3\n})\n```\n\n注意一下，如果你使用了 [Babel](http://babeljs.io/) 的话，还需要 [Syntax Dynamic Import](https://babeljs.io/docs/plugins/syntax-dynamic-import/) 这个 Babel 插件来处理 `import()` 这种语法。\n\n由于动态加载代码模块的语法依赖于 promise，对于低版本的浏览器，需要添加 promise 的 [polyfill](https://github.com/stefanpenner/es6-promise) 后才能使用。\n\n如上的代码，webpack 构建时会自动把 lodash 模块分离出来，并且在代码内部实现动态加载 lodash 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 `import` 方法是返回一个 promise 来获取动态加载的模块内容。\n\n`import` 后面的注释 `webpackChunkName: \"lodash\"` 用于告知 webpack 所要动态加载模块的名称。我们在 webpack 配置中添加一个 `output.chunkFilename` 的配置：\n\n```js\noutput: {\n  path: path.resolve(__dirname, \'dist\'),\n  filename: \'[name].[hash:8].js\',\n  chunkFilename: \'[name].[hash:8].js\' // 指定分离出来的代码文件的名称\n},\n```\n\n这样就可以把分离出来的文件名称用 lodash 标识了，如下图：\n\n![img](https://img.kancloud.cn/d4/b9/d4b9e8537c9ef30057e00fbbfc368b5d_1147x214.jpg)\n\n如果没有添加注释 `webpackChunkName: \"lodash\"` 以及 `output.chunkFilename` 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别。\n\n### Tree shaking\n\nTree shaking 这个术语起源于 ES2015 模块打包工具 [rollup](https://github.com/rollup/rollup)，依赖于 ES2015 模块系统中的[静态结构特性](http://exploringjs.com/es6/ch_modules.html#static-module-structure)，可以移除 JavaScript 上下文中的未引用代码，删掉用不着的代码，能够有效减少 JS 代码文件的大小。拿官方文档的例子来说明一下。\n\n```js\n// src/math.js\nexport function square(x) {\n  return x * x;\n}\n\nexport function cube(x) {\n  return x * x * x;\n}\n\n// src/index.js\nimport { cube } from \'./math.js\' // 在这里只是引用了 cube 这个方法\n\nconsole.log(cube(3))\n```\n\n如果整个项目代码只是上述两个文件，那么很明显，`square` 这个方法是未被引用的代码，是可以删掉的。在 webpack 中，只有启动了 JS 代码压缩功能（即使用 uglify）时，会做 Tree shaking 的优化。webpack 4.x 需要指定 mode 为 production。启动了之后，构建出来的结果就会移除 `square` 的那一部分代码了。\n\n如果你在项目中使用了 [Babel](http://babeljs.io/) 的话，要把 Babel 解析模块语法的功能关掉，在 `.babelrc` 配置中增加 `\"modules\": false` 这个配置：\n\n```js\n{\n  \"presets\": [[\"env\", { \"modules\": false }]]\n}\n```\n\n这样可以把 `import/export` 的这一部分模块语法交由 webpack 处理，否则没法使用 Tree shaking 的优化。\n\n有的时候你启用了 Tree shaking 功能，但是发现好像并没有什么用，例如这样一个例子：\n\n```js\n// src/component.js\nexport class Person {\n  constructor ({ name }) {\n    this.name = name\n  }\n\n  getName () {\n    return this.name\n  }\n}\n\nexport class Apple {\n  constructor ({ model }) {\n    this.model = model\n  }\n  getModel () {\n    return this.model\n  }\n}\n\n// src/index.js\nimport { Apple } from \'./components\'\n\nconst appleModel = new Apple({\n  model: \'X\'\n}).getModel()\n\nconsole.log(appleModel)\n```\n\n打包压缩后还是可以发现，`Person` 这一块看起来没用到的代码出现在文件中。关于这个问题，详细讲解的话篇幅太长了，建议自行阅读这一篇文章：[你的Tree-Shaking并没什么卵用](https://zhuanlan.zhihu.com/p/32831172)。\n\n这篇文章最近没有更新，但是 uglify 的相关 issue [Class declaration in IIFE considered as side effect](https://github.com/mishoo/UglifyJS2/issues/1261) 是有进展的，现在如果你在 Babel 配置中增加 `\"loose\": true` 配置的话，`Person` 这一块代码就可以在构建时移除掉了。\n\n### sideEffects\n\n这是 webpack 4.x 才具备的特性， webpack 的 examples ：[side-effects/README.md](https://github.com/webpack/webpack/blob/master/examples/side-effects/README.md)。\n\n我们拿 [lodash](https://github.com/lodash/lodash) 举个例子。它是一个工具库，提供了大量的对字符串、数组、对象等常见数据类型的处理函数，但是有的时候我们只是使用了其中的几个函数，全部函数的实现都打包到我们的应用代码中，其实很浪费。\n\nwebpack 的 sideEffects 可以帮助解决这个问题。现在 lodash 的 [ES 版本](https://www.npmjs.com/package/lodash-es) 的 `package.json` 文件中已经有 `sideEffects: false` 这个声明了，当某个模块的 `package.json` 文件中有了这个声明之后，webpack 会认为这个模块没有任何副作用，只是单纯用来对外暴露模块使用，那么在打包的时候就会做一些额外的处理。\n\n例如你这么使用 `lodash`：\n\n```js\nimport { forEach, includes } from \'lodash-es\'\n\nforEach([1, 2], (item) => {\n  console.log(item)\n})\n\nconsole.log(includes([1, 2, 3], 1))\n```\n\n由于 lodash-es 这个模块的 `package.json` 文件有 `sideEffects: false` 的声明，所以 webpack 会将上述的代码转换为以下的代码去处理：\n\n```js\nimport { default as forEach } from \'lodash-es/forEach\'\nimport { default as includes } from \'lodash-es/includes\'\n\n// ... 其他代码\n```\n\n最终 webpack 不会把 lodash-es 所有的代码内容打包进来，只是打包了你用到的那两个方法，这便是 sideEffects 的作用。\n\n## 提升webpack构建速度篇\n\n提升 webpack 构建速度本质上就是想办法让 webpack 少干点活，活少了速度自然快了，尽量避免 webpack 去做一些不必要的事情。\n\n### 减少 `resolve` 解析\n\n```js\nresolve: {\n  modules: [\n    path.resolve(__dirname, \'node_modules\'), // 使用绝对路径指定 node_modules，不做过多查询\n  ],\n\n  // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作\n  // 其他文件可以在编码时指定后缀，如 import(\'./index.scss\')\n  extensions: [\".js\"], \n\n  // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度\n  mainFiles: [\'index\'],\n},\n```\n\n### 把 loader 应用的文件范围缩小\n\n我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了：\n\n```js \nrules: [ \n  {\n    test: /\\.jsx?/,\n    include: [ \n      path.resolve(__dirname, \'src\'), \n      // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理\n      // 通常我们需要 loader 处理的文件都是存放在 src 目录\n    ],\n    exclude: /node_modules/, //这样也可以\n    use: \'babel-loader\',\n  },\n  // ...\n],\n```\n\n### 换种方式处理图片\n\n前边提到图片可以使用 webpack 的 [image-webpack-loader](https://github.com/tcoopman/image-webpack-loader) 来压缩图片，在对 webpack 构建性能要求不高的时候，这样是一种很简便的处理方式，但是要考虑提高 webpack 构建速度时，这一块的处理就得重新考虑一下了，思考一下是否有必要在 webpack 每次构建时都处理一次图片压缩。\n\n这里介绍一种解决思路，我们可以直接使用 [imagemin](https://github.com/imagemin/imagemin-cli) 来做图片压缩，编写简单的命令即可。然后使用 [pre-commit](https://github.com/observing/pre-commit) 这个类库来配置对应的命令，使其在 `git commit` 的时候触发，并且将要提交的文件替换为压缩后的文件。\n\n这样提交到代码仓库的图片就已经是压缩好的了，以后在项目中再次使用到的这些图片就无需再进行压缩处理了，image-webpack-loader 也就没有必要了。\n\n### 使用 DLLPlugin\n\n[DLLPlugin](https://doc.webpack-china.org/plugins/dll-plugin) 是 webpack 官方提供的一个插件，也是用来分离代码的，和 `optimization.splitChunks`有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 `optimization.splitChunks` 即可。\n\n[参考](https://www.webpackjs.com/plugins/dll-plugin/)\n\n### webpack 4.x 的构建性能\n\n比较重要的改进有这么几个：\n\n- [AST](https://zh.wikipedia.org/zh-hans/抽象語法樹) 可以直接从 loader 直接传递给 webpack，避免额外的解析，对这一个优化细节有兴趣的可以查看这个 [PR](https://github.com/webpack/webpack/pull/5925)。\n- 使用速度更快的 md4 作为默认的 hash 方法，对于大型项目来说，文件一多，需要 hash 处理的内容就多，webpack 的 hash 处理优化对整体的构建速度提升应该还是有一定的效果的。\n- Node 语言层面的优化，如用 `for of` 替换 `forEach`，用 `Map` 和 `Set` 替换普通的对象字面量等等，这一部分就不展开讲了，有兴趣的同学可以去 webpack 的 [PRs](https://github.com/webpack/webpack/pulls?q=is%3Apr+is%3Aclosed) 寻找更多的内容。\n- 默认开启 [uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin) 的 `cache` 和 `parallel`，即缓存和并行处理，这样能大大提高 production mode 下压缩代码的速度。\n\n除此之外，还有比较琐碎的一些内容，可以查阅：[webpack release 4.0](https://github.com/webpack/webpack/releases/tag/v4.0.0)，留意 **performance** 关键词。\n\n\n\n**重要参考**\n\n[webpack-examples](https://github.com/teabyii/webpack-examples)\n\n[使用webpack定制前端开发环境](https://www.kancloud.cn/sllyli/webpack/1242347)\n\n', 'webpack 4.x', 1599148800, 22);
INSERT INTO `article` VALUES (18, 3, '栈与队列篇【单调栈】', '# 栈与队列篇【单调栈】\n\n> **单调栈是什么**\n>\n> 单调栈指的是栈中存放的数据从底到顶(或从顶到底)是有序的，要么是递增，要么是递减（当然也可以相等），呈现一个单调性。递增的称为单调递增栈，递减的称为单调递减栈。\n>\n> **如何维护一个单调栈**\n>\n> 单调栈的维护很简单：如果入栈的元素满足单调性，直接入栈；如果不满足，就让栈顶元素出栈，直到能让入栈元素满足单调性为止，再将元素入栈（注意：已经出栈的元素就不再入栈了！）。\n\n## 模拟单调栈的数据push与pop\n\n> 模拟实现一个递增单调栈：\n\n现在有一组数10，3，7，4，12。从左到右依次入栈，则如果**栈为空**或**入栈元素值小于栈顶元素值**，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。\n\n- 10入栈时，栈为空，直接入栈，栈内元素为10。\n- 3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。\n- 7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。\n- 4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。\n- 12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。\n\n## 单调栈伪代码\n\n```javascript\n//以下为单调递减栈伪代码\nstack<int> st;\n//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解\nfor (遍历这个数组)\n{\n	if (栈空 || 栈顶元素大于等于当前比较元素)\n	{\n		入栈;\n	}\n	else\n	{\n		while (栈不为空 && 栈顶元素小于当前元素)\n		{\n			栈顶元素出栈;\n			更新结果;\n		}\n		当前数据入栈;\n	}\n}\n```\n\n## 单调栈的应用\n\n单调栈主要回答这样的几种问题\n\n- 比当前元素更大的下一个元素\n- 比当前元素更大的前一个元素\n- 比当前元素更小的下一个元素\n- 比当前元素更小的前一个元素\n\n**维护一个单调递减的栈**\n\n### 接雨水\n\n[No.42](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n示例:\n\n```javascript\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n> 找到左右边界和高\n\n```javascript\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    if(height.length<3) return 0\n    var sum = 0\n    var stack = []\n    for(var i = 0; i < height.length; i++){\n        if(stack.length==0 || height[stack[stack.length-1]] >= height[i]){\n            stack.push(i)\n        }else{\n            while(stack.length && height[stack[stack.length-1]] < height[i]){\n                var top = stack.pop()\n                if(stack.length != 0) { //这个条件非常巧妙\n                    sum += (Math.min(height[i], height[stack[stack.length-1]]) - height[top])*(i-stack[stack.length-1]-1)\n                }\n            }\n            stack.push(i)\n        }\n    }\n    return sum\n};\n```\n\n### 下一个更大元素 I\n\n[No.496](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。\n\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n\n**示例 1:**\n\n```\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n```\n\n> 这里需要用到 map 来存储对应关系\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar nextGreaterElement = function(nums1, nums2) {\n    var res = new Array(nums1.length).fill(-1)\n    var stack = []\n    var map = new Map()\n    for(var i = 0; i < nums2.length; i++){\n        if(stack.length==0 || nums2[i]<=nums2[stack[stack.length-1]]){\n            stack.push(i)\n        }else{\n            while(stack.length && nums2[i]>nums2[stack[stack.length-1]]){\n                var top = stack.pop()\n                map.set(nums2[top], nums2[i])\n            }\n            stack.push(i)\n        }\n    }\n    while(stack.length) map.set(nums2[stack.pop()], -1)\n    for(var i = 0; i < nums1.length; i++){\n        res[i] = map.get(nums1[i])\n    }\n    return res\n};\n```\n\n### 下一个更大元素 II\n\n[No.503](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n\n示例 1:\n\n```\n输入: [1,2,1]\n输出: [2,-1,2]\n```\n\n> 这里循环数组处理方式注意一下\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar nextGreaterElements = function(nums) {\n    var len = nums.length\n    var dist = new Array(len).fill(-1)\n    var stack = []\n    for(var i = 0; i < len*2; i++){\n        var num = nums[i%len]\n        while(stack.length && nums[stack[stack.length-1]] < num){\n            dist[stack.pop()] = num\n        }\n        if(i<len) stack.push(i)\n    }\n    return dist\n};\n```\n\n### 每日温度\n\n[No.739](https://leetcode-cn.com/problems/daily-temperatures/description/)\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。\n\n```javascript\n/**\n * @param {number[]} T\n * @return {number[]}\n */\nvar dailyTemperatures = function(T) {\n    var len = T.length\n    var stack = []\n    var dist = new Array(len).fill(0)\n    for(var curIndex = 0; curIndex < len; curIndex++){\n        while(stack.length && T[curIndex] > T[stack[stack.length-1]]) {\n            var preIndex = stack.pop()\n            dist[preIndex] = curIndex-preIndex\n        }\n        stack.push(curIndex)\n    }\n    return dist\n};\n```\n\n### 股票价格跨度\n\n[No.901](https://leetcode-cn.com/problems/online-stock-span/)\n\n编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n\n例如，如果未来7天股票的价格是 `[100, 80, 60, 70, 60, 75, 85]`，那么股票跨度将是 `[1, 1, 1, 2, 1, 4, 6]`。\n\n```javascript\nvar StockSpanner = function() {\n    this.prices = []\n    this.weigths = []\n};\n\n/** \n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n    var w = 1\n    while(this.prices && this.prices[this.prices.length-1]<=price){\n        this.prices.pop()\n        w+= this.weigths.pop()\n    }\n    this.prices.push(price)\n    this.weigths.push(w)\n    return w\n};\n```\n\n**维护一个单调递增的栈**\n\n### 柱状图中最大的矩形\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)\n\n**示例:**\n\n```\n输入: [2,1,5,6,2,3]\n输出: 10\n```\n\n```javascript\n/**\n * @param {number[]} heights\n * @return {number}\n */\nvar largestRectangleArea = function(heights) {\n    heights.push(0)\n    var stack = []\n    var maxArea = 0\n    for(var i = 0; i < heights.length; i++){\n        if(stack.length==0 || heights[stack[stack.length-1]] <= heights[i]){\n            stack.push(i)\n        }else{\n            while(stack.length!=0 && heights[stack[stack.length-1]] > heights[i]){\n                var top = stack.pop()\n                maxArea = Math.max(maxArea,heights[top]*(stack.length==0?i:i-stack[stack.length-1]-1))\n            }\n            stack.push(i)\n        }\n    }\n    return maxArea\n};\n```\n\n**重要参考**\n\n[[数据结构]--单调栈](https://blog.csdn.net/lucky52529/article/details/89155694)\n\n[单调栈问题总结](https://blog.csdn.net/qq_17550379/article/details/86519771)', '栈与队列篇【单调栈】', 1599148800, 20);
INSERT INTO `article` VALUES (19, 3, '算法【DFS篇】', '# 算法【DFS篇】\n\n> 本文主要讲的是递归方式的 DFS 的刷题套路。\n\n> 我们什么时候应该使用DFS呢？\n>\n> 当我们遇到的问题与路径相关，且不是寻找最短路径（最短路径为BFS，下次再说），或者需要遍历一个集合中的所有元素，或者是查找某一种问题的全部情况时，我们可以考虑使用DFS来求解。\n\n## 基础\n\n**伪代码**：\n\n```javascript\nvar dfs = function(参数){\n    if(返回条件成立) return 参数\n    dfs(进行下一步的搜索遍历)\n}\n```\n\n**思考三个问题**：\n\n* 是否有条件不成立的信息（撞南墙）\n* 是否有条件成立的信息（到终点）\n* 是否需要记录节点（记轨迹）\n\n**标记已访问节点：**\n\n```javascript\nboolean[] visited = new boolean[length] ; //数组表示，每访问过一个节点，数组将对应元素置为true\n\nSet<类型> set = new HashSet<>() ; //建立set，每访问一个节点，将该节点加入到set中去\n```\n\n**递归调用的作用：**\n\n- 递归调用就像是一个方向盘，用来把控下一个节点应该访问哪里\n- 同时递归还可以起到一个计数器的作用，可以记录每一条岔路的信息\n\n## 典型题目\n\n### 岛屿数量\n\n[No.200](https://leetcode-cn.com/problems/number-of-islands/)\n\n给你一个由 \'1\'（陆地）和 \'0\'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n```javascript\n输入:\n[\n[\'1\',\'1\',\'1\',\'1\',\'0\'],\n[\'1\',\'1\',\'0\',\'1\',\'0\'],\n[\'1\',\'1\',\'0\',\'0\',\'0\'],\n[\'0\',\'0\',\'0\',\'0\',\'0\']\n]\n输出: 1\n```\n\n```javascript\nvar numIslands = function(grid) {\n    var res = 0\n    for(var i = 0; i < grid.length; i++){\n        for(var j = 0; j <grid[0].length; j++){\n            if(grid[i][j] == \'1\'){\n                res++\n                dfs(i, j, grid)\n            }\n        }\n    }\n    return res\n};\n\nvar dfs = function(i, j , grid){\n    //撞南墙\n    if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==\'0\') return;\n    //记录节点轨迹，此处巧妙地将陆地变成水\n    grid[i][j]=\'0\'\n    //递归调用，控制方向\n    dfs(i,j+1,grid)\n    dfs(i,j-1,grid)\n    dfs(i-1,j,grid)\n    dfs(i+1,j,grid)\n}\n```\n\n### 岛屿最大面积\n\n[No.695](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给定一个包含了一些 0 和 1 的非空二维数组 grid 。\n\n一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。\n\n找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)\n\n示例：\n\n```javascript\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n```\n\n对于上面这个给定矩阵应返回 `6`。注意答案不应该是 `11` ，因为岛屿只能包含水平或垂直的四个方向的 `1` 。\n\n```javascript\nvar maxAreaOfIsland = function(grid) {\n    var max = 0\n    for(var i = 0; i < grid.length; i++){\n        for(var j = 0; j < grid[0].length; j++){\n            if(grid[i][j] == 1){\n                max = Math.max(max, dfs(i, j, grid))\n            }\n        }\n    }\n    return max\n};\n\nvar dfs = function(i, j, grid,max){\n    if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j] == 0) return 0;\n    grid[i][j]=0\n    var count = 1\n    count+=dfs(i-1,j,grid,max)\n    count+=dfs(i+1, j, grid,max)\n    count+=dfs(i, j-1, grid,max)\n    count+=dfs(i,j+1,grid,max)\n    return count\n}\n```\n\n### 被围绕的区域\n\n[No.130](https://leetcode-cn.com/problems/surrounded-regions/)\n\n给定一个二维的矩阵，包含 \'X\' 和 \'O\'（字母 O）。\n\n找到所有被 \'X\' 围绕的区域，并将这些区域里所有的 \'O\' 用 \'X\' 填充。\n\n示例:\n\n```javascript\nX X X X\nX O O X\nX X O X\nX O X X\n```\n\n运行你的函数后，矩阵变为：\n\n```javascript\nX X X X\nX X X X\nX X X X\nX O X X\n```\n\n思路：从边界出发，将与边界相邻的O变为N，然后将所有O变为X，再将N变为O\n\n```javascript\nvar solve = function(board) {\n    var grid = board\n    for(var i = 0; i < grid.length; i++){\n        for(var j = 0; j <grid[0].length; j++){\n            if(i==0 || j==0 || i==grid.length-1 || j==grid[i].length-1){\n                if(grid[i][j] == \'O\')\n                    dfs(i, j, grid)\n            }\n        }\n    }\n    for(var i=0; i < grid.length; i++){\n        for(var j = 0; j <grid[0].length; j++){\n            if(grid[i][j] == \'O\') grid[i][j]=\'X\'\n            if(grid[i][j] == \'N\') grid[i][j] = \'O\'\n        }\n    }\n};\n\nvar dfs = function(i, j , grid){\n    if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==\'X\'||grid[i][j] == \'N\') return;\n    grid[i][j] = \'N\'\n    dfs(i,j+1,grid)\n    dfs(i,j-1,grid)\n    dfs(i-1,j,grid)\n    dfs(i+1,j,grid)\n}\n```\n\n### 朋友圈\n\n[No.547](https://leetcode-cn.com/problems/friend-circles/)\n\n班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。\n\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。\n\n示例 1：\n\n```javascript\n输入：\n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n输出：2 \n解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。\n第2个学生自己在一个朋友圈。所以返回 2 。\n```\n\n思路：将 给定的矩阵看成无向图的邻接矩阵表示，本题可转化为求无向图的连通分量个数。\n\n```javascript\nvar findCircleNum = function(M) {\n    var res = 0\n    var visited = new Array(M.length).fill(0)\n    for(var i = 0; i < M.length; i++){\n        if(!visited[i]){\n            dfs(visited, i, M)\n            res++\n        }\n    }\n    return res\n};\n\nvar dfs = function(visited, i, M){\n    visited[i] = 1\n    for(var j =0; j < M.length; j++){\n        if(M[i][j] == 1 && !visited[j]){\n            dfs(visited, j, M)\n        }\n    }\n}\n```\n\n### 太平洋大西洋水流问题\n\n[No.417](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)\n\n给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。\n\n规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。\n\n请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。\n\n示例：\n\n```javascript\n给定下面的 5x5 矩阵:\n\n  太平洋 ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * 大西洋\n\n返回:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).\n```\n\n思路分析：\n\n* 二维平面上的上下左右四个方向可以行走，与其余类似题目一样，固定的写法有\n  * 表示四个方向的数组int[][] dires = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n  * 表示二维平面的行数与列数int m, n;\n  * 判断某个坐标x,y是否在矩形区域内的辅助函数boolean isIn(int x, int y)\n\n* 要同时满足可以到达大西洋与太平洋，所以一个点需要进行两次路径的行走，一次以太平洋为目标，一次以大西洋为目标。从内部的点以边界为目标去进行路径行走比较麻烦，但是如果换一个思路，从边缘往里面走。就类似于130. 被围绕的区域的第二种解法。\n* 从边缘向里走就修改通行规则，要往高度比当前点高或者相等的点走。\n* 定义函数dfs(int x, int y, boolean[][] canReach)，第三个参数代表大西洋/太平洋相邻的点可以访问到的点，这些点也就是可以流到相应大洋的点。\n  * 首先将canReach[x][y] = true;，将当前点设置为已访问。\n  * 然后对上下左右四个方向的点进行遍历，如果满足：在矩形内isIn(newX, newY)，高度比当前点更高或者相等matrix[x][y] <= matrix[newX][newY]且还没有访问过，就对其访问。\n* 主函数中，首先将各个成员变量初始化。然后生成表示大西洋/太平洋访问状态的 boolean[][] canReachP/canReachA = new boolean[m][n];。然后对于矩形的上下左右四条边界的点分别调用dfs()，进行从大西洋/太平洋到内部的访问。\n* 最后对二维平面内的所有点进行遍历，找到canReachA[i][j] && canReachP[i][j]的点，就是可以同时到达两个大洋。\n* 时间复杂度为O(n)，因为只对每一个点进行了最多三次遍历，n表示坐标点的个数。空间复杂度除去递归调用占用的空间为O(n)。\n\n```javascript\n/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar offset = [[0,-1],[1,0],[0,1],[-1,0]];\n\nvar pacificAtlantic = function(matrix) {\n    var res = [];\n    if(matrix.length <=0) return res;\n    // 初始化两个数组，能到达大西洋和能到达太平洋\n    var m = matrix.length;\n    var n = matrix[0].length;\n    \n    var canToWest = [];\n    var canToPacific = [];\n    for(let i = 0; i < m ; i++) {\n        canToWest[i] = [];\n        canToPacific[i] = [];\n        for(let j = 0; j< n; j++) {\n            canToWest[i][j] = 0;\n            canToPacific[i][j] = 0;\n        }\n    }\n\n    // 从能流向的往里流，最远能到达的地方，将途径的路径上的点都标为1\n    for(let i = 0 ; i < n; i++) {\n        dfs(matrix, 0, i, canToPacific); // 第一行能往上流流到太平洋\n        dfs(matrix, m-1,i, canToWest) // 最后一行能向下到大西洋的\n    }\n    for(let j = 0 ; j < m; j++) {\n        dfs(matrix, j,0, canToPacific); // 第一列能往左流流到太平洋\n        dfs(matrix, j,n-1, canToWest) // 最后一列能向右到大西洋的\n    }\n\n    for(let i =0; i < m ;i++) {\n        for(let j =0 ; j < n; j++) {\n            if(canToWest[i][j] && canToPacific[i][j]) {\n                res.push([i,j]);\n            }\n        }\n    }\n    return res;\n};\n\nvar dfs = function(arr, x, y, visited) {\n    visited[x][y] = 1;\n    for(let i = 0; i < 4; i++) {\n        let newX = x + offset[i][0];\n        let newY = y + offset[i][1];\n        if(isVaild(arr,newX,newY) && !visited[newX][newY] && arr[newX][newY] >= arr[x][y]) {\n            dfs(arr, newX, newY, visited);\n        }\n    }\n}\n\nvar isVaild = function(arr, x, y) {\n    let m  = arr.length;\n    let n = arr[0].length;\n    return x>=0 && y>=0 && x<m && y< n;\n}\n```\n\n### 克隆图\n\n[No.133](https://leetcode-cn.com/problems/clone-graph/)\n\n```\n输入：adjList = [[2,4],[1,3],[2,4],[1,3]]\n输出：[[2,4],[1,3],[2,4],[1,3]]\n解释：\n图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n```\n> 思路：\n> 1.有无终止条件（撞南墙）：当然有，遇到一个节点没有新的节点可以访问了；\n>\n> 2.有无成立条件（到终点）：这个没有，我们希望可以将图上的所有节点遍历一遍；\n>\n> 3.是否需要记录轨迹：需要，我们每次只遍历新的节点 ；\n>\n> 递归：\n>\n> 1.方向是新节点的方向\n>\n> 2.不需要记录信息\n\n```javascript\n/**\n * // Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function(node) {\n    if(!node) return null\n    var visited = new Map()\n    var head = new Node(node.val, [])\n    visited.set(node, head)\n    dfs(visited, node)\n    return head\n};\n\nvar dfs = function(visited, node){\n    if(!node) return null\n    for(neighbor of node.neighbors){\n        if(!visited.has(neighbor)){\n            var clone = new Node(neighbor.val, [])\n            visited.set(neighbor, clone)\n            dfs(visited, neighbor)\n        }\n        visited.get(node).neighbors.push(visited.get(neighbor))\n    }\n}\n```\n\n### 目标和\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n示例：\n\n```javascript\n输入：nums: [1, 1, 1, 1, 1], S: 3\n输出：5\n解释：\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n```\n\n思路：\n\n> 条件1：是否出现“撞南墙” ：出现了，当递归次数等于数组大小时，“撞南墙”不可以继续递归了\n>\n> 条件2：是否存在“终点” ：存在，当“撞南墙”的时候，累加的结果刚好等于给定的结果时，到达终点\n>\n> 条件3：是否需要记录轨迹：这是一个一维数组啊，没有回环，所以不需要记录\n>\n> 递归：\n>\n> 1.“方向”：两个方向：“ + ” 或者 “ - ”\n>\n> 2.是否需要记录信息：需要记录，记录每次递归之后和的值\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} S\n * @return {number}\n */\nvar res = 0\nvar findTargetSumWays = function(nums, S) {\n    if(nums == null) return 0\n    dfs(nums,S,0,0)\n    return res\n};\n\nvar dfs = function(nums, s, sum, k){\n    if(k==nums.length){\n        if(sum==s) res++\n        return \n    }\n    dfs(nums,s,sum+nums[k],k+1)\n    dfs(nums,s,sum-nums[k],k+1)\n}\n```\n\n**重要参考**\n\n[DFS讲解及刷题小结](https://www.cnblogs.com/handsomelixinan/p/10346065.html)\n\n[CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode)\n\n', '算法【DFS篇】', 1599408000, 17);
INSERT INTO `article` VALUES (20, 3, '算法【BFS篇】', '# 算法【BFS篇】\n\n> DFS实现重要依赖于堆栈/递归 ，较为简单的解决了如何遍历所有元素，以及寻求“终点”的问题。\n>\n> 但是，DFS虽然可以查找到到达路径，但是却找不到**最短的路径**，针对这一问题，给出了BFS(广度优先遍历)的算法。\n\n## 模版\n\n```javascript\nconst BFS = ()=>{\n    1、定义队列 queue\n    2、定义备忘录，用于记录已访问的位置，这一步根据题意选择，也可以用set、map\n    3、判断边界条件，是否能直接返回结果 \n    4、通常这里还需要定义一个变量用于记录遍历层数 step\n    5、将起始位置加入到队列中，同时更新备忘录\n    \n    while(队列不为空){\n        6、获取当前队列中元素个数 size\n        while(size--){\n            7、取出队列第一个位置节点 cur = queue.shift()\n            8、判断是否到达终点\n            9、获取它对应的下一个所有节点\n            	10、条件判断，过滤不符合条件的位置节点\n                11、新的节点加入队列\n        }\n        12、step++\n    }\n    return -1 //没有找到目标\n}\n```\n\n## 经典例题\n\n### 完全平方数\n\n[No.279](https://leetcode-cn.com/problems/perfect-squares/)\n\n给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。\n\n**示例 1:**\n\n```\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n```\n\n**思路**\n\n> 可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。\n>\n> 要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。\n\n\n\n![img](https://user-gold-cdn.xitu.io/2020/1/31/16ffae78d04fa541?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n在这个无权图中，每一个点指向的都是它可能经过的上一个节点。举例来说，对 5 而言，可能是 4 加上了`1的平方`转换而来，也可能是1 加上了`2的平方`转换而来，因此跟`1`和`2`都有联系，依次类推。\n\n那么我们现在要做了就是寻找到`从 n 转换到 0 最短的连线数`。\n\n举个例子， n = 8 时，我们需要找到它的邻居节点`4`和`7`，此时到达 4 和到达 7 的步数都为 1, 然后分别从 4 和 7 出发，4 找到邻居节点`3`和`0`，达到 3 和 0 的步数都为 2，考虑到此时已经到达 0，遍历终止，返回到达 0 的步数 2 即可。\n\n```javascript\nvar numSquares = function(n) {\n    var queue = [] \n    var visited = new Map()\n    queue.push([n,0])\n    visited.set(n, true)\n    while(queue.length){\n        var [num, step] = queue.shift()\n        for(var i=1; ;i++){\n            var nextNum = num - i*i\n            if(nextNum < 0) break\n            if(nextNum == 0) return step+1\n\n            if(!visited.get(nextNum)){\n                queue.push([nextNum, step+1])\n                visited.set(nextNum, true)\n            }\n        }\n    }\n    return 0\n};\n```\n\n### 二进制矩阵中的最短路径\n\n[No.1091](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)\n\n```\n[[0,0,0],[1,1,0],[1,1,0]]  =>4\n\n[[0,1],[1,0]] =>2\n```\n\n思路：\n\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar shortestPathBinaryMatrix = function(grid) {\n    if(grid == null || grid.length == 0 || grid[0].length == 0) return -1\n\n    var res = 1\n    var direction = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]\n\n    var queue = [] //定义队列\n\n    var m = grid.length\n    var n = grid[0].length\n\n    //判断边界条件\n    if(grid[0][0] == 1 || grid[m-1][n-1] ==1) return -1\n\n    //将起始位置加入队列，并更新备忘录\n    queue.push([0,0])\n    grid[0][0]=1\n\n    while(queue.length!==0){\n        var size = queue.length\n        for(var i=0; i < size; i++){\n            var cur = queue.shift()\n\n            var x = cur[0]\n            var y = cur[1]\n\n            if(x==m-1 && y == n-1) return res\n\n            for(var d of direction){\n                var dx = x+d[0],dy=y+d[1]\n                if(dx<0 || dy<0 ||dx>=m || dy>=m || grid[dx][dy] ==1){\n                    continue\n                }\n                grid[dx][dy] = 1\n                queue.push([dx,dy])\n            }\n        }\n        res++\n    }\n    return -1\n};\n```\n\n### 单词接龙\n\n[No127](https://leetcode-cn.com/problems/word-ladder/)\n\n给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：\n\n- 每次转换只能改变一个字母。\n- 转换过程中的中间单词必须是字典中的单词。\n\n说明:\n\n1. 如果不存在这样的转换序列，返回 0。\n2. 所有单词具有相同的长度。\n3. 所有单词只由小写字母组成。\n4. 字典中不存在重复的单词。\n5. 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n\n```javascript\n输入:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n输出: 5\n\n解释: 一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n     返回它的长度 5。\n```\n\n**思路**\n\n这一题是一个更加典型的用图建模的问题。如果每一个单词都是一个节点，那么只要和这个单词仅有一个字母不同，那么就是它的相邻节点。\n\n```javascript\n/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    let queue = [];\n    let res = 2;\n\n    queue.push(beginWord)\n\n    while(queue.length) {\n        let size = queue.length;\n        while(size --) {\n            let front = queue.shift();\n            for(let i = 0; i < wordList.length; i++) {\n                if(!isSimilar(front, wordList[i]))continue;\n                if(wordList[i] === endWord) return res;\n                queue.push(wordList[i]);\n                wordList.splice(i, 1);\n                i --;\n            }\n        }\n        res += 1;\n    }\n    return 0;\n};\n\nconst isSimilar = (a, b) => {\n    let diff = 0\n    for(let i = 0; i < a.length; i++) {\n        if(a.charAt(i) !== b.charAt(i)) diff++;\n        if(diff > 1) return false; \n    }\n    return true;\n}\n```\n\n### 打开转盘锁\n\n[No.752](https://leetcode-cn.com/problems/open-the-lock/)\n\n你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\' 。每个拨轮可以自由旋转：例如把 \'9\' 变为  \'0\'，\'0\' 变为 \'9\' 。每次旋转都只能旋转一个拨轮的一位数字。\n\n锁的初始数字为 \'0000\' ，一个代表四个拨轮的数字的字符串。\n\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n\n字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。\n\n```javascript\n输入：deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n输出：6\n解释：\n可能的移动序列为 \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\"。\n注意 \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" 这样的序列是不能解锁的，\n因为当拨动到 \"0102\" 时这个锁就会被锁定。\n```\n\n**代码**\n\n```javascript\n/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\nvar openLock = function(deadends, target) {\n    if(target == null) return -1\n    var queue = []\n    var set = new Set(deadends)\n    var res = 0\n    queue.push(\"0000\")\n\n    while(queue.length){\n        var size = queue.length\n        while(size--){\n            var cur = queue.shift()\n            if(set.has(cur)) continue\n            if(cur == target) return res\n            set.add(cur)\n            for(var i=0;i<4;i++){\n                for(var j=-1;j<2;j+=2){\n                    var tmp = cur.replace(/(.)(?=[^$])/g,\"$1,\").split(\",\");//将字符串转为字符数组\n                    tmp[i] = String((Number(tmp[i])+j+10)%10)\n                    queue.push(tmp.join(\"\"))\n                }\n            }\n        }\n        res++\n    }\n    return -1\n};\n```\n\n**重要参考**\n\n[CS-Note](https://github.com/CyC2018/CS-Notes)\n\n', '算法【BFS篇】', 1599494400, 30);

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `Id` int(11) NOT NULL AUTO_INCREMENT,
  `typeName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `orderNum` int(11) NOT NULL DEFAULT 0,
  `icon` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`Id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (1, 'JavaScript', 1, 'star');
INSERT INTO `type` VALUES (2, 'React全家桶', 2, 'book');
INSERT INTO `type` VALUES (3, '算法', 3, 'smile');
INSERT INTO `type` VALUES (4, '浏览器', 4, 'desktop');
INSERT INTO `type` VALUES (5, '性能优化', 5, 'rocket');
INSERT INTO `type` VALUES (6, '计算机网络', 6, 'global');
INSERT INTO `type` VALUES (7, '其他', 7, 'folder');

SET FOREIGN_KEY_CHECKS = 1;
